/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={916:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),s=n(645),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var p=this[o][0];null!=p&&(r[p]=!0)}for(var u=0;u<e.length;u++){var d=[].concat(e[u]);a&&r[d[0]]||(void 0!==s&&(void 0===d[5]||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=s),n&&(d[2]?(d[1]="@media ".concat(d[2]," {").concat(d[1],"}"),d[2]=n):d[2]=n),i&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=i):d[4]="".concat(i)),t.push(d))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},209:(e,t,n)=>{var a=n(916);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("2cbbc963",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,p=0,u=!1,d=function(){},l=null,c="data-vue-ssr-id",y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){u=n,l=i||{};var r=a(e,t);return T(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(p=s[o.id]).refs--,n.push(p)}for(t?T(r=a(e,t)):r=[],i=0;i<n.length;i++){var p;if(0===(p=n[i]).refs){for(var u=0;u<p.parts.length;u++)p.parts[u]();delete s[p.id]}}}}function T(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(h(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(h(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function f(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function h(e){var t,n,a=document.querySelector("style["+c+'~="'+e.id+'"]');if(a){if(u)return d;a.parentNode.removeChild(a)}if(y){var i=p++;a=o||(o=f()),t=g.bind(null,a,i,!1),n=g.bind(null,a,i,!0)}else a=f(),t=C.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var b,v=(b=[],function(e,t){return b[e]=t,b.filter(Boolean).join("\n")});function g(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function C(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(c,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function s(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return"function"==typeof e}function p(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function d(e){return"[object Object]"===u.call(e)}function l(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function c(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function y(e){return null==e?"":Array.isArray(e)||d(e)&&e.toString===u?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function T(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var f=T("slot,component",!0),h=T("key,ref,slot,slot-scope,is");function b(e,t){var n=e.length;if(n){if(t===e[n-1])return void(e.length=n-1);var a=e.indexOf(t);if(a>-1)return e.splice(a,1)}}var v=Object.prototype.hasOwnProperty;function g(e,t){return v.call(e,t)}function C(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var P=/-(\w)/g,k=C((function(e){return e.replace(P,(function(e,t){return t?t.toUpperCase():""}))})),w=C((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),_=/\B([A-Z])/g,M=C((function(e){return e.replace(_,"-$1").toLowerCase()})),A=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function x(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function q(e,t){for(var n in t)e[n]=t[n];return e}function F(e){for(var t={},n=0;n<e.length;n++)e[n]&&q(t,e[n]);return t}function R(e,t,n){}var I=function(e,t,n){return!1},E=function(e){return e};function S(e,t){if(e===t)return!0;var n=p(e),a=p(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return S(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return S(e[n],t[n])}))}catch(e){return!1}}function O(e,t){for(var n=0;n<e.length;n++)if(S(e[n],t))return n;return-1}function U(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var B="data-server-rendered",V=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],D={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:R,parsePlatformTagName:E,mustUseProp:I,async:!0,_lifecycleHooks:$},L=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function z(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var j=new RegExp("[^".concat(L.source,".$_\\d]")),G="__proto__"in{},Q="undefined"!=typeof window,H=Q&&window.navigator.userAgent.toLowerCase(),W=H&&/msie|trident/.test(H),K=H&&H.indexOf("msie 9.0")>0,J=H&&H.indexOf("edge/")>0;H&&H.indexOf("android");var Z=H&&/iphone|ipad|ipod|ios/.test(H);H&&/chrome\/\d+/.test(H),H&&/phantomjs/.test(H);var X,Y=H&&H.match(/firefox\/(\d+)/),ee={}.watch,te=!1;if(Q)try{var ne={};Object.defineProperty(ne,"passive",{get:function(){te=!0}}),window.addEventListener("test-passive",null,ne)}catch(e){}var ae=function(){return void 0===X&&(X=!Q&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),X},ie=Q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function se(e){return"function"==typeof e&&/native code/.test(e.toString())}var re,oe="undefined"!=typeof Symbol&&se(Symbol)&&"undefined"!=typeof Reflect&&se(Reflect.ownKeys);re="undefined"!=typeof Set&&se(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var pe=null;function ue(e){void 0===e&&(e=null),e||pe&&pe._scope.off(),pe=e,e&&e._scope.on()}var de=function(){function e(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),le=function(e){void 0===e&&(e="");var t=new de;return t.text=e,t.isComment=!0,t};function ce(e){return new de(void 0,void 0,void 0,String(e))}function ye(e){var t=new de(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var me=0,Te=[],fe=function(){for(var e=0;e<Te.length;e++){var t=Te[e];t.subs=t.subs.filter((function(e){return e})),t._pending=!1}Te.length=0},he=function(){function e(){this._pending=!1,this.id=me++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,Te.push(this))},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.filter((function(e){return e})),n=0,a=t.length;n<a;n++)t[n].update()},e}();he.target=null;var be=[];function ve(e){be.push(e),he.target=e}function ge(){be.pop(),he.target=be[be.length-1]}var Ce=Array.prototype,Pe=Object.create(Ce);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=Ce[e];z(Pe,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var ke=Object.getOwnPropertyNames(Pe),we={},_e=!0;function Me(e){_e=e}var Ae={notify:R,depend:R,addSub:R,removeSub:R},xe=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?Ae:new he,this.vmCount=0,z(e,"__ob__",this),t(e)){if(!a)if(G)e.__proto__=Pe;else for(var i=0,s=ke.length;i<s;i++)z(e,o=ke[i],Pe[o]);n||this.observeArray(e)}else{var r=Object.keys(e);for(i=0;i<r.length;i++){var o;Fe(e,o=r[i],we,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)qe(e[t],!1,this.mock)},e}();function qe(e,n,a){return e&&g(e,"__ob__")&&e.__ob__ instanceof xe?e.__ob__:!_e||!a&&ae()||!t(e)&&!d(e)||!Object.isExtensible(e)||e.__v_skip||Ue(e)||e instanceof de?void 0:new xe(e,n,a)}function Fe(e,n,a,i,s,r){var o=new he,p=Object.getOwnPropertyDescriptor(e,n);if(!p||!1!==p.configurable){var u=p&&p.get,d=p&&p.set;u&&!d||a!==we&&2!==arguments.length||(a=e[n]);var l=!s&&qe(a,!1,r);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=u?u.call(e):a;return he.target&&(o.depend(),l&&(l.dep.depend(),t(n)&&Ee(n))),Ue(n)&&!s?n.value:n},set:function(t){var n,i,p=u?u.call(e):a;if((n=p)===(i=t)?0===n&&1/n!=1/i:n==n||i==i){if(d)d.call(e,t);else{if(u)return;if(!s&&Ue(p)&&!Ue(t))return void(p.value=t);a=t}l=!s&&qe(t,!1,r),o.notify()}}}),o}}function Re(e,n,a){if(!Oe(e)){var i=e.__ob__;return t(e)&&l(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&qe(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(Fe(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Ie(e,n){if(t(e)&&l(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||Oe(e)||g(e,n)&&(delete e[n],a&&a.dep.notify())}}function Ee(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Ee(n)}function Se(e){return function(e,t){Oe(e)||qe(e,t,ae())}(e,!0),z(e,"__v_isShallow",!0),e}function Oe(e){return!(!e||!e.__v_isReadonly)}function Ue(e){return!(!e||!0!==e.__v_isRef)}function Be(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(Ue(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];Ue(a)&&!Ue(e)?a.value=e:t[n]=e}})}var Ve=C((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function $e(e,n){function a(){var e=a.fns;if(!t(e))return Kt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),s=0;s<i.length;s++)Kt(i[s],null,arguments,n,"v-on handler")}return a.fns=e,a}function De(e,t,n,i,r,o){var p,u,d,l;for(p in e)u=e[p],d=t[p],l=Ve(p),a(u)||(a(d)?(a(u.fns)&&(u=e[p]=$e(u,o)),s(l.once)&&(u=e[p]=r(l.name,u,l.capture)),n(l.name,u,l.capture,l.passive,l.params)):u!==d&&(d.fns=u,e[p]=d));for(p in t)a(e[p])&&i((l=Ve(p)).name,t[p],l.capture)}function Le(e,t,n){var r;e instanceof de&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function p(){n.apply(this,arguments),b(r.fns,p)}a(o)?r=$e([p]):i(o.fns)&&s(o.merged)?(r=o).fns.push(p):r=$e([o,p]),r.merged=!0,e[t]=r}function Ne(e,t,n,a,s){if(i(t)){if(g(t,n))return e[n]=t[n],s||delete t[n],!0;if(g(t,a))return e[n]=t[a],s||delete t[a],!0}return!1}function ze(e){return r(e)?[ce(e)]:t(e)?Ge(e):void 0}function je(e){return i(e)&&i(e.text)&&!1===e.isComment}function Ge(e,n){var o,p,u,d,l=[];for(o=0;o<e.length;o++)a(p=e[o])||"boolean"==typeof p||(d=l[u=l.length-1],t(p)?p.length>0&&(je((p=Ge(p,"".concat(n||"","_").concat(o)))[0])&&je(d)&&(l[u]=ce(d.text+p[0].text),p.shift()),l.push.apply(l,p)):r(p)?je(d)?l[u]=ce(d.text+p):""!==p&&l.push(ce(p)):je(p)&&je(d)?l[u]=ce(d.text+p.text):(s(e._isVList)&&i(p.tag)&&a(p.key)&&i(n)&&(p.key="__vlist".concat(n,"_").concat(o,"__")),l.push(p)));return l}var Qe=1,He=2;function We(e,n,a,u,d,l){return(t(a)||r(a))&&(d=u,u=a,a=void 0),s(l)&&(d=He),function(e,n,a,s,r){if(i(a)&&i(a.__ob__))return le();if(i(a)&&i(a.is)&&(n=a.is),!n)return le();var u,d;if(t(s)&&o(s[0])&&((a=a||{}).scopedSlots={default:s[0]},s.length=0),r===He?s=ze(s):r===Qe&&(s=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof n){var l=void 0;d=e.$vnode&&e.$vnode.ns||D.getTagNamespace(n),u=D.isReservedTag(n)?new de(D.parsePlatformTagName(n),a,s,void 0,void 0,e):a&&a.pre||!i(l=Nn(e.$options,"components",n))?new de(n,a,s,void 0,void 0,e):In(l,a,e,s,n)}else u=In(n,a,e,s);return t(u)?u:i(u)?(i(d)&&Ke(u,d),i(a)&&function(e){p(e.style)&&ln(e.style),p(e.class)&&ln(e.class)}(a),u):le()}(e,n,a,u,d)}function Ke(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var r=0,o=e.children.length;r<o;r++){var p=e.children[r];i(p.tag)&&(a(p.ns)||s(n)&&"svg"!==p.tag)&&Ke(p,t,n)}}function Je(e,n){var a,s,r,o,u=null;if(t(e)||"string"==typeof e)for(u=new Array(e.length),a=0,s=e.length;a<s;a++)u[a]=n(e[a],a);else if("number"==typeof e)for(u=new Array(e),a=0;a<e;a++)u[a]=n(a+1,a);else if(p(e))if(oe&&e[Symbol.iterator]){u=[];for(var d=e[Symbol.iterator](),l=d.next();!l.done;)u.push(n(l.value,u.length)),l=d.next()}else for(r=Object.keys(e),u=new Array(r.length),a=0,s=r.length;a<s;a++)o=r[a],u[a]=n(e[o],o,a);return i(u)||(u=[]),u._isVList=!0,u}function Ze(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=q(q({},a),n)),i=s(n)||(o(t)?t():t)):i=this.$slots[e]||(o(t)?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function Xe(e){return Nn(this.$options,"filters",e)||E}function Ye(e,n){return t(e)?-1===e.indexOf(n):e!==n}function et(e,t,n,a,i){var s=D.keyCodes[t]||n;return i&&a&&!D.keyCodes[t]?Ye(i,a):s?Ye(s,e):a?M(a)!==t:void 0===e}function tt(e,n,a,i,s){if(a&&p(a)){t(a)&&(a=F(a));var r=void 0,o=function(t){if("class"===t||"style"===t||h(t))r=e;else{var o=e.attrs&&e.attrs.type;r=i||D.mustUseProp(n,o,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var p=k(t),u=M(t);p in r||u in r||(r[t]=a[t],s&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var u in a)o(u)}return e}function nt(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||it(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function at(e,t,n){return it(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function it(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&st(e[i],"".concat(n,"_").concat(i),a);else st(e,n,a)}function st(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function rt(e,t){if(t&&d(t)){var n=e.on=e.on?q({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function ot(e,n,a,i){n=n||{$stable:!a};for(var s=0;s<e.length;s++){var r=e[s];t(r)?ot(r,n,a):r&&(r.proxy&&(r.fn.proxy=!0),n[r.key]=r.fn)}return i&&(n.$key=i),n}function pt(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function ut(e,t){return"string"==typeof e?t+e:e}function dt(e){e._o=at,e._n=m,e._s=y,e._l=Je,e._t=Ze,e._q=S,e._i=O,e._m=nt,e._f=Xe,e._k=et,e._b=tt,e._v=ce,e._e=le,e._u=ot,e._g=rt,e._d=pt,e._p=ut}function lt(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,p=n[o]||(n[o]=[]);"template"===s.tag?p.push.apply(p,s.children||[]):p.push(s)}}for(var u in n)n[u].every(ct)&&delete n[u];return n}function ct(e){return e.isComment&&!e.asyncFactory||" "===e.text}function yt(e){return e.isComment&&e.asyncFactory}function mt(t,n,a,i){var s,r=Object.keys(a).length>0,o=n?!!n.$stable:!r,p=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&i&&i!==e&&p===i.$key&&!r&&!i.$hasNormal)return i;for(var u in s={},n)n[u]&&"$"!==u[0]&&(s[u]=Tt(t,a,u,n[u]))}else s={};for(var d in a)d in s||(s[d]=ft(a,d));return n&&Object.isExtensible(n)&&(n._normalized=s),z(s,"$stable",o),z(s,"$key",p),z(s,"$hasNormal",r),s}function Tt(e,n,a,i){var s=function(){var n=pe;ue(e);var a=arguments.length?i.apply(null,arguments):i({}),s=(a=a&&"object"==typeof a&&!t(a)?[a]:ze(a))&&a[0];return ue(n),a&&(!s||1===a.length&&s.isComment&&!yt(s))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:s,enumerable:!0,configurable:!0}),s}function ft(e,t){return function(){return e[t]}}function ht(e,t,n,a,i){var s=!1;for(var r in t)r in e?t[r]!==n[r]&&(s=!0):(s=!0,bt(e,r,a,i));for(var r in e)r in t||(s=!0,delete e[r]);return s}function bt(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function vt(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var gt,Ct,Pt=null;function kt(e,t){return(e.__esModule||oe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),p(e)?t.extend(e):e}function wt(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||yt(a)))return a}}function _t(e,t){gt.$on(e,t)}function Mt(e,t){gt.$off(e,t)}function At(e,t){var n=gt;return function a(){null!==t.apply(null,arguments)&&n.$off(e,a)}}function xt(e,t,n){gt=e,De(t,n||{},_t,Mt,At,e),gt=void 0}var qt=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ct,!e&&Ct&&(this.index=(Ct.scopes||(Ct.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=Ct;try{return Ct=this,e()}finally{Ct=t}}},e.prototype.on=function(){Ct=this},e.prototype.off=function(){Ct=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},e}(),Ft=null;function Rt(e){var t=Ft;return Ft=e,function(){Ft=t}}function It(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function Et(e,t){if(t){if(e._directInactive=!1,It(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)Et(e.$children[n]);Ot(e,"activated")}}function St(e,t){if(!(t&&(e._directInactive=!0,It(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)St(e.$children[n]);Ot(e,"deactivated")}}function Ot(e,t,n,a){void 0===a&&(a=!0),ve();var i=pe,s=Ct;a&&ue(e);var r=e.$options[t],o="".concat(t," hook");if(r)for(var p=0,u=r.length;p<u;p++)Kt(r[p],e,n||null,e,o);e._hasHookEvent&&e.$emit("hook:"+t),a&&(ue(i),s&&s.on()),ge()}var Ut=[],Bt=[],Vt={},$t=!1,Dt=!1,Lt=0,Nt=0,zt=Date.now;if(Q&&!W){var jt=window.performance;jt&&"function"==typeof jt.now&&zt()>document.createEvent("Event").timeStamp&&(zt=function(){return jt.now()})}var Gt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function Qt(){var e,t;for(Nt=zt(),Dt=!0,Ut.sort(Gt),Lt=0;Lt<Ut.length;Lt++)(e=Ut[Lt]).before&&e.before(),t=e.id,Vt[t]=null,e.run();var n=Bt.slice(),a=Ut.slice();Lt=Ut.length=Bt.length=0,Vt={},$t=Dt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,Et(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&Ot(a,"updated")}}(a),fe(),ie&&D.devtools&&ie.emit("flush")}var Ht="watcher";function Wt(e,t,n){ve();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Jt(e,a,"errorCaptured hook")}}Jt(e,t,n)}finally{ge()}}function Kt(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&c(s)&&!s._handled&&(s.catch((function(e){return Wt(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){Wt(e,a,i)}return s}function Jt(e,t,n){if(D.errorHandler)try{return D.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Zt(t)}Zt(e)}function Zt(e,t,n){if(!Q||"undefined"==typeof console)throw e;console.error(e)}"".concat(Ht," callback"),"".concat(Ht," getter"),"".concat(Ht," cleanup");var Xt,Yt=!1,en=[],tn=!1;function nn(){tn=!1;var e=en.slice(0);en.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&se(Promise)){var an=Promise.resolve();Xt=function(){an.then(nn),Z&&setTimeout(R)},Yt=!0}else if(W||"undefined"==typeof MutationObserver||!se(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Xt="undefined"!=typeof setImmediate&&se(setImmediate)?function(){setImmediate(nn)}:function(){setTimeout(nn,0)};else{var sn=1,rn=new MutationObserver(nn),on=document.createTextNode(String(sn));rn.observe(on,{characterData:!0}),Xt=function(){sn=(sn+1)%2,on.data=String(sn)},Yt=!0}function pn(e,t){var n;if(en.push((function(){if(e)try{e.call(t)}catch(e){Wt(e,t,"nextTick")}else n&&n(t)})),tn||(tn=!0,Xt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function un(e){return function(t,n){if(void 0===n&&(n=pe),n)return function(e,t,n){var a=e.$options;a[t]=Vn(a[t],n)}(n,e,t)}}un("beforeMount"),un("mounted"),un("beforeUpdate"),un("updated"),un("beforeDestroy"),un("destroyed"),un("activated"),un("deactivated"),un("serverPrefetch"),un("renderTracked"),un("renderTriggered"),un("errorCaptured");var dn=new re;function ln(e){return cn(e,dn),dn.clear(),e}function cn(e,n){var a,i,s=t(e);if(!(!s&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof de)){if(e.__ob__){var r=e.__ob__.dep.id;if(n.has(r))return;n.add(r)}if(s)for(a=e.length;a--;)cn(e[a],n);else if(Ue(e))cn(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)cn(e[i[a]],n)}}var yn=0,mn=function(){function e(e,t,n,a,i){var s;void 0===(s=Ct&&!Ct._vm?Ct:e?e._scope:void 0)&&(s=Ct),s&&s.active&&s.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++yn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new re,this.newDepIds=new re,this.expression="",o(t)?this.getter=t:(this.getter=function(e){if(!j.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=R)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;ve(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Wt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&ln(e),ge(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==Vt[t]&&(e!==he.target||!e.noRecurse)){if(Vt[t]=!0,Dt){for(var n=Ut.length-1;n>Lt&&Ut[n].id>e.id;)n--;Ut.splice(n+1,0,e)}else Ut.push(e);$t||($t=!0,pn(Qt))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||p(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Kt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&b(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),Tn={enumerable:!0,configurable:!0,get:R,set:R};function fn(e,t,n){Tn.get=function(){return this[t][n]},Tn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,Tn)}function hn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=Se({}),i=e.$options._propKeys=[];!e.$parent||Me(!1);var s=function(s){i.push(s);var r=zn(s,t,n,e);Fe(a,s,r),s in e||fn(e,"_props",s)};for(var r in t)s(r);Me(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};z(n,"_v_attr_proxy",!0),ht(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||ht(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||vt(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:A(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return Be(t,e,n)}))}}}(t);ue(t),ve();var s=Kt(a,null,[t._props||Se({}),i],t,"setup");if(ge(),ue(),o(s))n.render=s;else if(p(s))if(t._setupState=s,s.__sfc){var r=t._setupProxy={};for(var u in s)"__sfc"!==u&&Be(r,s,u)}else for(var u in s)N(u)||Be(t,s,u)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?R:A(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;d(t=e._data=o(t)?function(e,t){ve();try{return e.call(t,t)}catch(e){return Wt(e,t,"data()"),{}}finally{ge()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&g(a,s)||N(s)||fn(e,"_data",s)}var r=qe(t);r&&r.vmCount++}(n);else{var i=qe(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ae();for(var i in t){var s=t[i],r=o(s)?s:s.get;a||(n[i]=new mn(e,r||R,R,bn)),i in e||vn(e,i,s)}}(n,a.computed),a.watch&&a.watch!==ee&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var s=0;s<i.length;s++)Pn(e,a,i[s]);else Pn(e,a,i)}}(n,a.watch)}var bn={lazy:!0};function vn(e,t,n){var a=!ae();o(n)?(Tn.get=a?gn(t):Cn(n),Tn.set=R):(Tn.get=n.get?a&&!1!==n.cache?gn(t):Cn(n.get):R,Tn.set=n.set||R),Object.defineProperty(e,t,Tn)}function gn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),he.target&&t.depend(),t.value}}function Cn(e){return function(){return e.call(this,this)}}function Pn(e,t,n,a){return d(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function kn(e,t){if(e){for(var n=Object.create(null),a=oe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){var r=e[s].from;if(r in t._provided)n[s]=t._provided[r];else if("default"in e[s]){var p=e[s].default;n[s]=o(p)?p.call(t):p}}}return n}}var wn=0;function _n(e){var t=e.options;if(e.super){var n=_n(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&q(e.extendOptions,a),(t=e.options=Ln(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Mn(n,a,i,r,o){var p,u=this,d=o.options;g(r,"_uid")?(p=Object.create(r))._original=r:(p=r,r=r._original);var l=s(d._compiled),c=!l;this.data=n,this.props=a,this.children=i,this.parent=r,this.listeners=n.on||e,this.injections=kn(d.inject,r),this.slots=function(){return u.$slots||mt(r,n.scopedSlots,u.$slots=lt(i,r)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return mt(r,n.scopedSlots,this.slots())}}),l&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=mt(r,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,n,a,i){var s=We(p,e,n,a,i,c);return s&&!t(s)&&(s.fnScopeId=d._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return We(p,e,t,n,a,c)}}function An(e,t,n,a,i){var s=ye(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function xn(e,t){for(var n in t)e[k(n)]=t[n]}function qn(e){return e.name||e.__name||e._componentTag}dt(Mn.prototype);var Fn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Fn.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,Ft)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,s){var r=i.data.scopedSlots,o=t.$scopedSlots,p=!!(r&&!r.$stable||o!==e&&!o.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),u=!!(s||t.$options._renderChildren||p),d=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=s;var l=i.data.attrs||e;t._attrsProxy&&ht(t._attrsProxy,l,d.data&&d.data.attrs||e,t,"$attrs")&&(u=!0),t.$attrs=l,a=a||e;var c=t.$options._parentListeners;if(t._listenersProxy&&ht(t._listenersProxy,a,c||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,xt(t,a,c),n&&t.$options.props){Me(!1);for(var y=t._props,m=t.$options._propKeys||[],T=0;T<m.length;T++){var f=m[T],h=t.$options.props;y[f]=zn(f,h,n,t)}Me(!0),t.$options.propsData=n}u&&(t.$slots=lt(s,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,Ot(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,Bt.push(t)):Et(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?St(t,!0):t.$destroy())}},Rn=Object.keys(Fn);function In(n,r,o,u,d){if(!a(n)){var l=o.$options._base;if(p(n)&&(n=l.extend(n)),"function"==typeof n){var y;if(a(n.cid)&&(n=function(e,t){if(s(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=Pt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),s(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var r=e.owners=[n],o=!0,u=null,d=null;n.$on("hook:destroyed",(function(){return b(r,n)}));var l=function(e){for(var t=0,n=r.length;t<n;t++)r[t].$forceUpdate();e&&(r.length=0,null!==u&&(clearTimeout(u),u=null),null!==d&&(clearTimeout(d),d=null))},y=U((function(n){e.resolved=kt(n,t),o?r.length=0:l(!0)})),m=U((function(t){i(e.errorComp)&&(e.error=!0,l(!0))})),T=e(y,m);return p(T)&&(c(T)?a(e.resolved)&&T.then(y,m):c(T.component)&&(T.component.then(y,m),i(T.error)&&(e.errorComp=kt(T.error,t)),i(T.loading)&&(e.loadingComp=kt(T.loading,t),0===T.delay?e.loading=!0:u=setTimeout((function(){u=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,l(!1))}),T.delay||200)),i(T.timeout)&&(d=setTimeout((function(){d=null,a(e.resolved)&&m(null)}),T.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(y=n,l),void 0===n))return function(e,t,n,a,i){var s=le();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(y,r,o,u,d);r=r||{},_n(n),i(r.model)&&function(e,n){var a=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var r=n.on||(n.on={}),o=r[s],p=n.model.callback;i(o)?(t(o)?-1===o.indexOf(p):o!==p)&&(r[s]=[p].concat(o)):r[s]=p}(n.options,r);var m=function(e,t,n){var s=t.options.props;if(!a(s)){var r={},o=e.attrs,p=e.props;if(i(o)||i(p))for(var u in s){var d=M(u);Ne(r,p,u,d,!0)||Ne(r,o,u,d,!1)}return r}}(r,n);if(s(n.options.functional))return function(n,a,s,r,o){var p=n.options,u={},d=p.props;if(i(d))for(var l in d)u[l]=zn(l,d,a||e);else i(s.attrs)&&xn(u,s.attrs),i(s.props)&&xn(u,s.props);var c=new Mn(s,u,o,r,n),y=p.render.call(null,c._c,c);if(y instanceof de)return An(y,s,c.parent,p);if(t(y)){for(var m=ze(y)||[],T=new Array(m.length),f=0;f<m.length;f++)T[f]=An(m[f],s,c.parent,p);return T}}(n,m,r,o,u);var T=r.on;if(r.on=r.nativeOn,s(n.options.abstract)){var f=r.slot;r={},f&&(r.slot=f)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<Rn.length;n++){var a=Rn[n],i=t[a],s=Fn[a];i===s||i&&i._merged||(t[a]=i?En(s,i):s)}}(r);var h=qn(n.options)||d;return new de("vue-component-".concat(n.cid).concat(h?"-".concat(h):""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:m,listeners:T,tag:d,children:u},y)}}}function En(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var Sn=R,On=D.optionMergeStrategies;function Un(e,t,n){if(void 0===n&&(n=!0),!t)return e;for(var a,i,s,r=oe?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++)"__ob__"!==(a=r[o])&&(i=e[a],s=t[a],n&&g(e,a)?i!==s&&d(i)&&d(s)&&Un(i,s):Re(e,a,s));return e}function Bn(e,t,n){return n?function(){var a=o(t)?t.call(n,n):t,i=o(e)?e.call(n,n):e;return a?Un(a,i):i}:t?e?function(){return Un(o(t)?t.call(this,this):t,o(e)?e.call(this,this):e)}:t:e}function Vn(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function $n(e,t,n,a){var i=Object.create(e||null);return t?q(i,t):i}On.data=function(e,t,n){return n?Bn(e,t,n):t&&"function"!=typeof t?e:Bn(e,t)},$.forEach((function(e){On[e]=Vn})),V.forEach((function(e){On[e+"s"]=$n})),On.watch=function(e,n,a,i){if(e===ee&&(e=void 0),n===ee&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var s={};for(var r in q(s,e),n){var o=s[r],p=n[r];o&&!t(o)&&(o=[o]),s[r]=o?o.concat(p):t(p)?p:[p]}return s},On.props=On.methods=On.inject=On.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return q(i,e),t&&q(i,t),i},On.provide=function(e,t){return e?function(){var n=Object.create(null);return Un(n,o(e)?e.call(this):e),t&&Un(n,o(t)?t.call(this):t,!1),n}:t};var Dn=function(e,t){return void 0===t?e:t};function Ln(e,n,a){if(o(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,s,r={};if(t(a))for(i=a.length;i--;)"string"==typeof(s=a[i])&&(r[k(s)]={type:null});else if(d(a))for(var o in a)s=a[o],r[k(o)]=d(s)?s:{type:s};e.props=r}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var s=0;s<a.length;s++)i[a[s]]={from:a[s]};else if(d(a))for(var r in a){var o=a[r];i[r]=d(o)?q({from:r},o):{from:o}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];o(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=Ln(e,n.extends,a)),n.mixins))for(var i=0,s=n.mixins.length;i<s;i++)e=Ln(e,n.mixins[i],a);var r,p={};for(r in e)u(r);for(r in n)g(e,r)||u(r);function u(t){var i=On[t]||Dn;p[t]=i(e[t],n[t],a,t)}return p}function Nn(e,t,n,a){if("string"==typeof n){var i=e[t];if(g(i,n))return i[n];var s=k(n);if(g(i,s))return i[s];var r=w(s);return g(i,r)?i[r]:i[n]||i[s]||i[r]}}function zn(e,t,n,a){var i=t[e],s=!g(n,e),r=n[e],p=Hn(Boolean,i.type);if(p>-1)if(s&&!g(i,"default"))r=!1;else if(""===r||r===M(e)){var u=Hn(String,i.type);(u<0||p<u)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(g(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:o(a)&&"Function"!==Gn(t.type)?a.call(e):a}}(a,i,e);var d=_e;Me(!0),qe(r),Me(d)}return r}var jn=/^\s*function (\w+)/;function Gn(e){var t=e&&e.toString().match(jn);return t?t[1]:""}function Qn(e,t){return Gn(e)===Gn(t)}function Hn(e,n){if(!t(n))return Qn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Qn(n[a],e))return a;return-1}function Wn(e){this._init(e)}function Kn(e){return e&&(qn(e.Ctor.options)||e.tag)}function Jn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==u.call(a))&&e.test(n));var a}function Zn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var r=n[s];if(r){var o=r.name;o&&!t(o)&&Xn(n,s,a,i)}}}function Xn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,b(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=wn++,n._isVue=!0,n.__v_skip=!0,n._scope=new qt(!0),n._scope._vm=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=Ln(_n(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&xt(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=lt(n._renderChildren,i),t.$scopedSlots=a?mt(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return We(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return We(t,e,n,a,i,!0)};var s=a&&a.data;Fe(t,"$attrs",s&&s.attrs||e,null,!0),Fe(t,"$listeners",n._parentListeners||e,null,!0)}(n),Ot(n,"beforeCreate",void 0,!1),function(e){var t=kn(e.$options.inject,e);t&&(Me(!1),Object.keys(t).forEach((function(n){Fe(e,n,t[n])})),Me(!0))}(n),hn(n),function(e){var t=e.$options.provide;if(t){var n=o(t)?t.call(e):t;if(!p(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=oe?Reflect.ownKeys(n):Object.keys(n),s=0;s<i.length;s++){var r=i[s];Object.defineProperty(a,r,Object.getOwnPropertyDescriptor(n,r))}}}(n),Ot(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Wn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Re,e.prototype.$delete=Ie,e.prototype.$watch=function(e,t,n){var a=this;if(d(t))return Pn(a,e,t,n);(n=n||{}).user=!0;var i=new mn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'.concat(i.expression,'"');ve(),Kt(t,a,[i.value],a,s),ge()}return function(){i.teardown()}}}(Wn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var s=0,r=e.length;s<r;s++)i.$on(e[s],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,s=e.length;i<s;i++)a.$off(e[i],n);return a}var r,o=a._events[e];if(!o)return a;if(!n)return a._events[e]=null,a;for(var p=o.length;p--;)if((r=o[p])===n||r.fn===n){o.splice(p,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?x(n):n;for(var a=x(arguments,1),i='event handler for "'.concat(e,'"'),s=0,r=n.length;s<r;s++)Kt(n[s],t,a,t,i)}return t}}(Wn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=Rt(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var r=n;r&&r.$vnode&&r.$parent&&r.$vnode===r.$parent._vnode;)r.$parent.$el=r.$el,r=r.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Ot(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||b(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Ot(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Wn),function(e){dt(e.prototype),e.prototype.$nextTick=function(e){return pn(e,this)},e.prototype._render=function(){var e,n=this,a=n.$options,i=a.render,s=a._parentVnode;s&&n._isMounted&&(n.$scopedSlots=mt(n.$parent,s.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&vt(n._slotsProxy,n.$scopedSlots)),n.$vnode=s;try{ue(n),Pt=n,e=i.call(n._renderProxy,n.$createElement)}catch(t){Wt(t,n,"render"),e=n._vnode}finally{Pt=null,ue()}return t(e)&&1===e.length&&(e=e[0]),e instanceof de||(e=le()),e.parent=s,e}}(Wn);var Yn=[String,RegExp,Array],ea={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yn,exclude:Yn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:Kn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&Xn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Xn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Zn(e,(function(e){return Jn(t,e)}))})),this.$watch("exclude",(function(t){Zn(e,(function(e){return!Jn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=wt(e),n=t&&t.componentOptions;if(n){var a=Kn(n),i=this.include,s=this.exclude;if(i&&(!a||!Jn(i,a))||s&&a&&Jn(s,a))return t;var r=this.cache,o=this.keys,p=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;r[p]?(t.componentInstance=r[p].componentInstance,b(o,p),o.push(p)):(this.vnodeToCache=t,this.keyToCache=p),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return D}};Object.defineProperty(e,"config",t),e.util={warn:Sn,extend:q,mergeOptions:Ln,defineReactive:Fe},e.set=Re,e.delete=Ie,e.nextTick=pn,e.observable=function(e){return qe(e),e},e.options=Object.create(null),V.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,q(e.options.components,ea),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=x(arguments,1);return n.unshift(this),o(e.install)?e.install.apply(e,n):o(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Ln(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=qn(e)||qn(n.options),r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=Ln(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)fn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)vn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,V.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=q({},r.options),i[a]=r,r}}(e),function(e){V.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&d(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&o(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Wn),Object.defineProperty(Wn.prototype,"$isServer",{get:ae}),Object.defineProperty(Wn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wn,"FunctionalRenderContext",{value:Mn}),Wn.version="2.7.15";var ta=T("style,class"),na=T("input,textarea,option,select,progress"),aa=function(e,t,n){return"value"===n&&na(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},ia=T("contenteditable,draggable,spellcheck"),sa=T("events,caret,typing,plaintext-only"),ra=function(e,t){return la(t)||"false"===t?"false":"contenteditable"===e&&sa(t)?t:"true"},oa=T("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),pa="http://www.w3.org/1999/xlink",ua=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},da=function(e){return ua(e)?e.slice(6,e.length):""},la=function(e){return null==e||!1===e};function ca(e,t){return{staticClass:ya(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function ya(e,t){return e?t?e+" "+t:e:t||""}function ma(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,s=e.length;a<s;a++)i(t=ma(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):p(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Ta={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},fa=T("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ha=T("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ba=function(e){return fa(e)||ha(e)};function va(e){return ha(e)?"svg":"math"===e?"math":void 0}var ga=Object.create(null),Ca=T("text,number,password,search,email,tel,url");function Pa(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var ka=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Ta[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),wa={create:function(e,t){_a(t)},update:function(e,t){e.data.ref!==t.data.ref&&(_a(e,!0),_a(t))},destroy:function(e){_a(e,!0)}};function _a(e,n){var a=e.data.ref;if(i(a)){var s=e.context,r=e.componentInstance||e.elm,p=n?null:r,u=n?void 0:r;if(o(a))Kt(a,s,[p],s,"template ref function");else{var d=e.data.refInFor,l="string"==typeof a||"number"==typeof a,c=Ue(a),y=s.$refs;if(l||c)if(d){var m=l?y[a]:a.value;n?t(m)&&b(m,r):t(m)?m.includes(r)||m.push(r):l?(y[a]=[r],Ma(s,a,y[a])):a.value=[r]}else if(l){if(n&&y[a]!==r)return;y[a]=u,Ma(s,a,p)}else if(c){if(n&&a.value!==r)return;a.value=p}}}}function Ma(e,t,n){var a=e._setupState;a&&g(a,t)&&(Ue(a[t])?a[t].value=n:a[t]=n)}var Aa=new de("",{},[]),xa=["create","activate","update","remove","destroy"];function qa(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,s=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===s||Ca(a)&&Ca(s)}(e,t)||s(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function Fa(e,t,n){var a,s,r={};for(a=t;a<=n;++a)i(s=e[a].key)&&(r[s]=a);return r}var Ra={create:Ia,update:Ia,destroy:function(e){Ia(e,Aa)}};function Ia(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===Aa,r=t===Aa,o=Sa(e.data.directives,e.context),p=Sa(t.data.directives,t.context),u=[],d=[];for(n in p)a=o[n],i=p[n],a?(i.oldValue=a.value,i.oldArg=a.arg,Ua(i,"update",t,e),i.def&&i.def.componentUpdated&&d.push(i)):(Ua(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var l=function(){for(var n=0;n<u.length;n++)Ua(u[n],"inserted",t,e)};s?Le(t,"insert",l):l()}if(d.length&&Le(t,"postpatch",(function(){for(var n=0;n<d.length;n++)Ua(d[n],"componentUpdated",t,e)})),!s)for(n in o)p[n]||Ua(o[n],"unbind",e,e,r)}(e,t)}var Ea=Object.create(null);function Sa(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Ea),i[Oa(a)]=a,t._setupState&&t._setupState.__sfc){var s=a.def||Nn(t,"_setupState","v-"+a.name);a.def="function"==typeof s?{bind:s,update:s}:s}a.def=a.def||Nn(t.$options,"directives",a.name)}return i}function Oa(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Ua(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){Wt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Ba=[wa,Ra];function Va(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var r,o,p=t.elm,u=e.data.attrs||{},d=t.data.attrs||{};for(r in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=t.data.attrs=q({},d)),d)o=d[r],u[r]!==o&&$a(p,r,o,t.data.pre);for(r in(W||J)&&d.value!==u.value&&$a(p,"value",d.value),u)a(d[r])&&(ua(r)?p.removeAttributeNS(pa,da(r)):ia(r)||p.removeAttribute(r))}}function $a(e,t,n,a){a||e.tagName.indexOf("-")>-1?Da(e,t,n):oa(t)?la(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):ia(t)?e.setAttribute(t,ra(t,n)):ua(t)?la(n)?e.removeAttributeNS(pa,da(t)):e.setAttributeNS(pa,t,n):Da(e,t,n)}function Da(e,t,n){if(la(n))e.removeAttribute(t);else{if(W&&!K&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var La={create:Va,update:Va};function Na(e,t){var n=t.elm,s=t.data,r=e.data;if(!(a(s.staticClass)&&a(s.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ca(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=ca(t,n.data));return s=t.staticClass,r=t.class,i(s)||i(r)?ya(s,ma(r)):"";var s,r}(t),p=n._transitionClasses;i(p)&&(o=ya(o,ma(p))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var za,ja,Ga,Qa,Ha,Wa,Ka={create:Na,update:Na},Ja=/[\w).+\-_$\]]/;function Za(e){var t,n,a,i,s,r=!1,o=!1,p=!1,u=!1,d=0,l=0,c=0,y=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(p)96===t&&92!==n&&(p=!1);else if(u)47===t&&92!==n&&(u=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||d||l||c){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:p=!0;break;case 40:c++;break;case 41:c--;break;case 91:l++;break;case 93:l--;break;case 123:d++;break;case 125:d--}if(47===t){for(var m=a-1,T=void 0;m>=0&&" "===(T=e.charAt(m));m--);T&&Ja.test(T)||(u=!0)}}else void 0===i?(y=a+1,i=e.slice(0,a).trim()):f();function f(){(s||(s=[])).push(e.slice(y,a).trim()),y=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==y&&f(),s)for(a=0;a<s.length;a++)i=Xa(i,s[a]);return i}function Xa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function Ya(e,t){console.error("[Vue compiler]: ".concat(e))}function ei(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function ti(e,t,n,a,i){(e.props||(e.props=[])).push(di({name:t,value:n,dynamic:i},a)),e.plain=!1}function ni(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(di({name:t,value:n,dynamic:i},a)),e.plain=!1}function ai(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(di({name:t,value:n},a))}function ii(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push(di({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function si(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function ri(t,n,a,i,s,r,o,p){var u;(i=i||e).right?p?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(p?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=si("!",n,p)),i.once&&(delete i.once,n=si("~",n,p)),i.passive&&(delete i.passive,n=si("&",n,p)),i.native?(delete i.native,u=t.nativeEvents||(t.nativeEvents={})):u=t.events||(t.events={});var d=di({value:a.trim(),dynamic:p},o);i!==e&&(d.modifiers=i);var l=u[n];Array.isArray(l)?s?l.unshift(d):l.push(d):u[n]=l?s?[d,l]:[l,d]:d,t.plain=!1}function oi(e,t,n){var a=pi(e,":"+t)||pi(e,"v-bind:"+t);if(null!=a)return Za(a);if(!1!==n){var i=pi(e,t);if(null!=i)return JSON.stringify(i)}}function pi(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function ui(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function di(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function li(e,t,n){var a=n||{},i=a.number,s="$$v",r=s;a.trim&&(r="(typeof ".concat(s," === 'string'")+"? ".concat(s,".trim()")+": ".concat(s,")")),i&&(r="_n(".concat(r,")"));var o=ci(t,r);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(s,") {").concat(o,"}")}}function ci(e,t){var n=function(e){if(e=e.trim(),za=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<za-1)return(Qa=e.lastIndexOf("."))>-1?{exp:e.slice(0,Qa),key:'"'+e.slice(Qa+1)+'"'}:{exp:e,key:null};for(ja=e,Qa=Ha=Wa=0;!mi();)Ti(Ga=yi())?hi(Ga):91===Ga&&fi(Ga);return{exp:e.slice(0,Ha),key:e.slice(Ha+1,Wa)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function yi(){return ja.charCodeAt(++Qa)}function mi(){return Qa>=za}function Ti(e){return 34===e||39===e}function fi(e){var t=1;for(Ha=Qa;!mi();)if(Ti(e=yi()))hi(e);else if(91===e&&t++,93===e&&t--,0===t){Wa=Qa;break}}function hi(e){for(var t=e;!mi()&&(e=yi())!==t;);}var bi,vi="__r",gi="__c";function Ci(e,t,n){var a=bi;return function i(){null!==t.apply(null,arguments)&&wi(e,i,n,a)}}var Pi=Yt&&!(Y&&Number(Y[1])<=53);function ki(e,t,n,a){if(Pi){var i=Nt,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}bi.addEventListener(e,t,te?{capture:n,passive:a}:n)}function wi(e,t,n,a){(a||bi).removeEventListener(e,t._wrapper||t,n)}function _i(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},s=e.data.on||{};bi=t.elm||e.elm,function(e){if(i(e[vi])){var t=W?"change":"input";e[t]=[].concat(e[vi],e[t]||[]),delete e[vi]}i(e[gi])&&(e.change=[].concat(e[gi],e.change||[]),delete e[gi])}(n),De(n,s,ki,wi,Ci,t.context),bi=void 0}}var Mi,Ai={create:_i,update:_i,destroy:function(e){return _i(e,Aa)}};function xi(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,r,o=t.elm,p=e.data.domProps||{},u=t.data.domProps||{};for(n in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=t.data.domProps=q({},u)),p)n in u||(o[n]="");for(n in u){if(r=u[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),r===p[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=r;var d=a(r)?"":String(r);qi(o,d)&&(o.value=d)}else if("innerHTML"===n&&ha(o.tagName)&&a(o.innerHTML)){(Mi=Mi||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var l=Mi.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;l.firstChild;)o.appendChild(l.firstChild)}else if(r!==p[n])try{o[n]=r}catch(e){}}}}function qi(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return m(n)!==m(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Fi={create:xi,update:xi},Ri=C((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function Ii(e){var t=Ei(e.style);return e.staticStyle?q(e.staticStyle,t):t}function Ei(e){return Array.isArray(e)?F(e):"string"==typeof e?Ri(e):e}var Si,Oi=/^--/,Ui=/\s*!important$/,Bi=function(e,t,n){if(Oi.test(t))e.style.setProperty(t,n);else if(Ui.test(n))e.style.setProperty(M(t),n.replace(Ui,""),"important");else{var a=$i(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},Vi=["Webkit","Moz","ms"],$i=C((function(e){if(Si=Si||document.createElement("div").style,"filter"!==(e=k(e))&&e in Si)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Vi.length;n++){var a=Vi[n]+t;if(a in Si)return a}}));function Di(e,t){var n=t.data,s=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(s.staticStyle)&&a(s.style))){var r,o,p=t.elm,u=s.staticStyle,d=s.normalizedStyle||s.style||{},l=u||d,c=Ei(t.data.style)||{};t.data.normalizedStyle=i(c.__ob__)?q({},c):c;var y=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=Ii(i.data))&&q(a,n);(n=Ii(e.data))&&q(a,n);for(var s=e;s=s.parent;)s.data&&(n=Ii(s.data))&&q(a,n);return a}(t);for(o in l)a(y[o])&&Bi(p,o,"");for(o in y)(r=y[o])!==l[o]&&Bi(p,o,null==r?"":r)}}var Li={create:Di,update:Di},Ni=/\s+/;function zi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ni).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function ji(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ni).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Gi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&q(t,Qi(e.name||"v")),q(t,e),t}return"string"==typeof e?Qi(e):void 0}}var Qi=C((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),Hi=Q&&!K,Wi="transition",Ki="animation",Ji="transition",Zi="transitionend",Xi="animation",Yi="animationend";Hi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ji="WebkitTransition",Zi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Xi="WebkitAnimation",Yi="webkitAnimationEnd"));var es=Q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function ts(e){es((function(){es(e)}))}function ns(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),zi(e,t))}function as(e,t){e._transitionClasses&&b(e._transitionClasses,t),ji(e,t)}function is(e,t,n){var a=rs(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===Wi?Zi:Yi,p=0,u=function(){e.removeEventListener(o,d),n()},d=function(t){t.target===e&&++p>=r&&u()};setTimeout((function(){p<r&&u()}),s+1),e.addEventListener(o,d)}var ss=/\b(transform|all)(,|$)/;function rs(e,t){var n,a=window.getComputedStyle(e),i=(a[Ji+"Delay"]||"").split(", "),s=(a[Ji+"Duration"]||"").split(", "),r=os(i,s),o=(a[Xi+"Delay"]||"").split(", "),p=(a[Xi+"Duration"]||"").split(", "),u=os(o,p),d=0,l=0;return t===Wi?r>0&&(n=Wi,d=r,l=s.length):t===Ki?u>0&&(n=Ki,d=u,l=p.length):l=(n=(d=Math.max(r,u))>0?r>u?Wi:Ki:null)?n===Wi?s.length:p.length:0,{type:n,timeout:d,propCount:l,hasTransform:n===Wi&&ss.test(a[Ji+"Property"])}}function os(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return ps(t)+ps(e[n])})))}function ps(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function us(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var s=Gi(e.data.transition);if(!a(s)&&!i(n._enterCb)&&1===n.nodeType){for(var r=s.css,u=s.type,d=s.enterClass,l=s.enterToClass,c=s.enterActiveClass,y=s.appearClass,T=s.appearToClass,f=s.appearActiveClass,h=s.beforeEnter,b=s.enter,v=s.afterEnter,g=s.enterCancelled,C=s.beforeAppear,P=s.appear,k=s.afterAppear,w=s.appearCancelled,_=s.duration,M=Ft,A=Ft.$vnode;A&&A.parent;)M=A.context,A=A.parent;var x=!M._isMounted||!e.isRootInsert;if(!x||P||""===P){var q=x&&y?y:d,F=x&&f?f:c,R=x&&T?T:l,I=x&&C||h,E=x&&o(P)?P:b,S=x&&k||v,O=x&&w||g,B=m(p(_)?_.enter:_),V=!1!==r&&!K,$=cs(E),D=n._enterCb=U((function(){V&&(as(n,R),as(n,F)),D.cancelled?(V&&as(n,q),O&&O(n)):S&&S(n),n._enterCb=null}));e.data.show||Le(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),E&&E(n,D)})),I&&I(n),V&&(ns(n,q),ns(n,F),ts((function(){as(n,q),D.cancelled||(ns(n,R),$||(ls(B)?setTimeout(D,B):is(n,u,D)))}))),e.data.show&&(t&&t(),E&&E(n,D)),V||$||D()}}}function ds(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var s=Gi(e.data.transition);if(a(s)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var r=s.css,o=s.type,u=s.leaveClass,d=s.leaveToClass,l=s.leaveActiveClass,c=s.beforeLeave,y=s.leave,T=s.afterLeave,f=s.leaveCancelled,h=s.delayLeave,b=s.duration,v=!1!==r&&!K,g=cs(y),C=m(p(b)?b.leave:b),P=n._leaveCb=U((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(as(n,d),as(n,l)),P.cancelled?(v&&as(n,u),f&&f(n)):(t(),T&&T(n)),n._leaveCb=null}));h?h(k):k()}function k(){P.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),c&&c(n),v&&(ns(n,u),ns(n,l),ts((function(){as(n,u),P.cancelled||(ns(n,d),g||(ls(C)?setTimeout(P,C):is(n,o,P)))}))),y&&y(n,P),v||g||P())}}function ls(e){return"number"==typeof e&&!isNaN(e)}function cs(e){if(a(e))return!1;var t=e.fns;return i(t)?cs(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function ys(e,t){!0!==t.data.show&&us(t)}var ms=function(e){var n,o,p={},u=e.modules,d=e.nodeOps;for(n=0;n<xa.length;++n)for(p[xa[n]]=[],o=0;o<u.length;++o)i(u[o][xa[n]])&&p[xa[n]].push(u[o][xa[n]]);function l(e){var t=d.parentNode(e);i(t)&&d.removeChild(t,e)}function c(e,t,n,a,r,o,u){if(i(e.elm)&&i(o)&&(e=o[u]=ye(e)),e.isRootInsert=!r,!function(e,t,n,a){var r=e.data;if(i(r)){var o=i(e.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(e,!1),i(e.componentInstance))return y(e,t),m(n,e.elm,a),s(o)&&function(e,t,n,a){for(var s,r=e;r.componentInstance;)if(i(s=(r=r.componentInstance._vnode).data)&&i(s=s.transition)){for(s=0;s<p.activate.length;++s)p.activate[s](Aa,r);t.push(r);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var l=e.data,c=e.children,T=e.tag;i(T)?(e.elm=e.ns?d.createElementNS(e.ns,T):d.createElement(T,e),v(e),f(e,c,t),i(l)&&b(e,t),m(n,e.elm,a)):s(e.isComment)?(e.elm=d.createComment(e.text),m(n,e.elm,a)):(e.elm=d.createTextNode(e.text),m(n,e.elm,a))}}function y(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,h(e)?(b(e,t),v(e)):(_a(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?d.parentNode(n)===e&&d.insertBefore(e,t,n):d.appendChild(e,t))}function f(e,n,a){if(t(n))for(var i=0;i<n.length;++i)c(n[i],a,e.elm,null,!0,n,i);else r(e.text)&&d.appendChild(e.elm,d.createTextNode(String(e.text)))}function h(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function b(e,t){for(var a=0;a<p.create.length;++a)p.create[a](Aa,e);i(n=e.data.hook)&&(i(n.create)&&n.create(Aa,e),i(n.insert)&&t.push(e))}function v(e){var t;if(i(t=e.fnScopeId))d.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t),n=n.parent;i(t=Ft)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t)}function g(e,t,n,a,i,s){for(;a<=i;++a)c(n[a],s,e,t,!1,n,a)}function C(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<p.destroy.length;++t)p.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)C(e.children[n])}function P(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(k(a),C(a)):l(a.elm))}}function k(e,t){if(i(t)||i(e.data)){var n,a=p.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&k(n,t),n=0;n<p.remove.length;++n)p.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else l(e.elm)}function w(e,t,n,a){for(var s=n;s<a;s++){var r=t[s];if(i(r)&&qa(e,r))return s}}function _(e,t,n,r,o,u){if(e!==t){i(t.elm)&&i(r)&&(t=r[o]=ye(t));var l=t.elm=e.elm;if(s(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?x(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(e.isStatic)&&t.key===e.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=e.componentInstance;else{var y,m=t.data;i(m)&&i(y=m.hook)&&i(y=y.prepatch)&&y(e,t);var T=e.children,f=t.children;if(i(m)&&h(t)){for(y=0;y<p.update.length;++y)p.update[y](e,t);i(y=m.hook)&&i(y=y.update)&&y(e,t)}a(t.text)?i(T)&&i(f)?T!==f&&function(e,t,n,s,r){for(var o,p,u,l=0,y=0,m=t.length-1,T=t[0],f=t[m],h=n.length-1,b=n[0],v=n[h],C=!r;l<=m&&y<=h;)a(T)?T=t[++l]:a(f)?f=t[--m]:qa(T,b)?(_(T,b,s,n,y),T=t[++l],b=n[++y]):qa(f,v)?(_(f,v,s,n,h),f=t[--m],v=n[--h]):qa(T,v)?(_(T,v,s,n,h),C&&d.insertBefore(e,T.elm,d.nextSibling(f.elm)),T=t[++l],v=n[--h]):qa(f,b)?(_(f,b,s,n,y),C&&d.insertBefore(e,f.elm,T.elm),f=t[--m],b=n[++y]):(a(o)&&(o=Fa(t,l,m)),a(p=i(b.key)?o[b.key]:w(b,t,l,m))?c(b,s,e,T.elm,!1,n,y):qa(u=t[p],b)?(_(u,b,s,n,y),t[p]=void 0,C&&d.insertBefore(e,u.elm,T.elm)):c(b,s,e,T.elm,!1,n,y),b=n[++y]);l>m?g(e,a(n[h+1])?null:n[h+1].elm,n,y,h,s):y>h&&P(t,l,m)}(l,T,f,n,u):i(f)?(i(e.text)&&d.setTextContent(l,""),g(l,null,f,0,f.length-1,n)):i(T)?P(T,0,T.length-1):i(e.text)&&d.setTextContent(l,""):e.text!==t.text&&d.setTextContent(l,t.text),i(m)&&i(y=m.hook)&&i(y=y.postpatch)&&y(e,t)}}}function M(e,t,n){if(s(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var A=T("attrs,class,staticClass,staticStyle,key");function x(e,t,n,a){var r,o=t.tag,p=t.data,u=t.children;if(a=a||p&&p.pre,t.elm=e,s(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(p)&&(i(r=p.hook)&&i(r=r.init)&&r(t,!0),i(r=t.componentInstance)))return y(t,n),!0;if(i(o)){if(i(u))if(e.hasChildNodes())if(i(r=p)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var d=!0,l=e.firstChild,c=0;c<u.length;c++){if(!l||!x(l,u[c],n,a)){d=!1;break}l=l.nextSibling}if(!d||l)return!1}else f(t,u,n);if(i(p)){var m=!1;for(var T in p)if(!A(T)){m=!0,b(t,n);break}!m&&p.class&&ln(p.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!a(t)){var o,u=!1,l=[];if(a(e))u=!0,c(t,l);else{var y=i(e.nodeType);if(!y&&qa(e,t))_(e,t,l,null,null,r);else{if(y){if(1===e.nodeType&&e.hasAttribute(B)&&(e.removeAttribute(B),n=!0),s(n)&&x(e,t,l))return M(t,l,!0),e;o=e,e=new de(d.tagName(o).toLowerCase(),{},[],void 0,o)}var m=e.elm,T=d.parentNode(m);if(c(t,l,m._leaveCb?null:T,d.nextSibling(m)),i(t.parent))for(var f=t.parent,b=h(t);f;){for(var v=0;v<p.destroy.length;++v)p.destroy[v](f);if(f.elm=t.elm,b){for(var g=0;g<p.create.length;++g)p.create[g](Aa,f);var k=f.data.hook.insert;if(k.merged)for(var w=k.fns.slice(1),A=0;A<w.length;A++)w[A]()}else _a(f);f=f.parent}i(T)?P([e],0,0):i(e.tag)&&C(e)}}return M(t,l,u),t.elm}i(e)&&C(e)}}({nodeOps:ka,modules:[La,Ka,Ai,Fi,Li,Q?{create:ys,activate:ys,remove:function(e,t){!0!==e.data.show?ds(e,t):t()}}:{}].concat(Ba)});K&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&Ps(e,"input")}));var Ts={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?Le(n,"postpatch",(function(){Ts.componentUpdated(e,t,n)})):fs(e,t,n.context),e._vOptions=[].map.call(e.options,vs)):("textarea"===n.tag||Ca(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",gs),e.addEventListener("compositionend",Cs),e.addEventListener("change",Cs),K&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){fs(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,vs);i.some((function(e,t){return!S(e,a[t])}))&&(e.multiple?t.value.some((function(e){return bs(e,i)})):t.value!==t.oldValue&&bs(t.value,i))&&Ps(e,"change")}}};function fs(e,t,n){hs(e,t),(W||J)&&setTimeout((function(){hs(e,t)}),0)}function hs(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,p=e.options.length;o<p;o++)if(r=e.options[o],i)s=O(a,vs(r))>-1,r.selected!==s&&(r.selected=s);else if(S(vs(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function bs(e,t){return t.every((function(t){return!S(t,e)}))}function vs(e){return"_value"in e?e._value:e.value}function gs(e){e.target.composing=!0}function Cs(e){e.target.composing&&(e.target.composing=!1,Ps(e.target,"input"))}function Ps(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function ks(e){return!e.componentInstance||e.data&&e.data.transition?e:ks(e.componentInstance._vnode)}var ws={model:Ts,show:{bind:function(e,t,n){var a=t.value,i=(n=ks(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,us(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=ks(n)).data&&n.data.transition?(n.data.show=!0,a?us(n,(function(){e.style.display=e.__vOriginalDisplay})):ds(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},_s={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ms(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Ms(wt(t.children)):e}function As(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[k(a)]=i[a];return t}function xs(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var qs=function(e){return e.tag||yt(e)},Fs=function(e){return"show"===e.name},Rs={name:"transition",props:_s,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(qs)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=Ms(i);if(!s)return i;if(this._leaving)return xs(e,i);var o="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var p=(s.data||(s.data={})).transition=As(this),u=this._vnode,d=Ms(u);if(s.data.directives&&s.data.directives.some(Fs)&&(s.data.show=!0),d&&d.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,d)&&!yt(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var l=d.data.transition=q({},p);if("out-in"===a)return this._leaving=!0,Le(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),xs(e,i);if("in-out"===a){if(yt(s))return u;var c,y=function(){c()};Le(p,"afterEnter",y),Le(p,"enterCancelled",y),Le(l,"delayLeave",(function(e){c=e}))}}return i}}},Is=q({tag:String,moveClass:String},_s);delete Is.mode;var Es={props:Is,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=Rt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=As(this),o=0;o<i.length;o++)(d=i[o]).tag&&null!=d.key&&0!==String(d.key).indexOf("__vlist")&&(s.push(d),n[d.key]=d,(d.data||(d.data={})).transition=r);if(a){var p=[],u=[];for(o=0;o<a.length;o++){var d;(d=a[o]).data.transition=r,d.data.pos=d.elm.getBoundingClientRect(),n[d.key]?p.push(d):u.push(d)}this.kept=e(t,null,p),this.removed=u}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Ss),e.forEach(Os),e.forEach(Us),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;ns(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Zi,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Zi,e),n._moveCb=null,as(n,t))})}})))},methods:{hasMove:function(e,t){if(!Hi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){ji(n,e)})),zi(n,t),n.style.display="none",this.$el.appendChild(n);var a=rs(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function Ss(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Os(e){e.data.newPos=e.elm.getBoundingClientRect()}function Us(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),s.transitionDuration="0s"}}var Bs={Transition:Rs,TransitionGroup:Es};Wn.config.mustUseProp=aa,Wn.config.isReservedTag=ba,Wn.config.isReservedAttr=ta,Wn.config.getTagNamespace=va,Wn.config.isUnknownElement=function(e){if(!Q)return!0;if(ba(e))return!1;if(e=e.toLowerCase(),null!=ga[e])return ga[e];var t=document.createElement(e);return e.indexOf("-")>-1?ga[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ga[e]=/HTMLUnknownElement/.test(t.toString())},q(Wn.options.directives,ws),q(Wn.options.components,Bs),Wn.prototype.__patch__=Q?ms:R,Wn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=le),Ot(e,"beforeMount"),a=function(){e._update(e._render(),n)},new mn(e,a,R,{before:function(){e._isMounted&&!e._isDestroyed&&Ot(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var s=0;s<i.length;s++)i[s].run();return null==e.$vnode&&(e._isMounted=!0,Ot(e,"mounted")),e}(this,e=e&&Q?Pa(e):void 0,t)},Q&&setTimeout((function(){D.devtools&&ie&&ie.emit("init",Wn)}),0);var Vs,$s=/\{\{((?:.|\r?\n)+?)\}\}/g,Ds=/[-.*+?^${}()|[\]\/\\]/g,Ls=C((function(e){var t=e[0].replace(Ds,"\\$&"),n=e[1].replace(Ds,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Ns={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=pi(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=oi(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},zs={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=pi(e,"style");n&&(e.staticStyle=JSON.stringify(Ri(n)));var a=oi(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},js=T("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Gs=T("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Qs=T("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Hs=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ws=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ks="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(L.source,"]*"),Js="((?:".concat(Ks,"\\:)?").concat(Ks,")"),Zs=new RegExp("^<".concat(Js)),Xs=/^\s*(\/?)>/,Ys=new RegExp("^<\\/".concat(Js,"[^>]*>")),er=/^<!DOCTYPE [^>]+>/i,tr=/^<!\--/,nr=/^<!\[/,ar=T("script,style,textarea",!0),ir={},sr={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},rr=/&(?:lt|gt|quot|amp|#39);/g,or=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,pr=T("pre,textarea",!0),ur=function(e,t){return e&&pr(e)&&"\n"===t[0]};function dr(e,t){var n=t?or:rr;return e.replace(n,(function(e){return sr[e]}))}var lr,cr,yr,mr,Tr,fr,hr,br,vr=/^@|^v-on:/,gr=/^v-|^@|^:|^#/,Cr=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Pr=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,kr=/^\(|\)$/g,wr=/^\[.*\]$/,_r=/:(.*)$/,Mr=/^:|^\.|^v-bind:/,Ar=/\.[^.\]]+(?=[^\]]*$)/g,xr=/^v-slot(:|$)|^#/,qr=/[\r\n]/,Fr=/[ \f\t\r\n]+/g,Rr=C((function(e){return(Vs=Vs||document.createElement("div")).innerHTML=e,Vs.textContent})),Ir="_empty_";function Er(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:Dr(t),rawAttrsMap:{},parent:n,children:[]}}function Sr(e,t){lr=t.warn||Ya,fr=t.isPreTag||I,hr=t.mustUseProp||I,br=t.getTagNamespace||I;t.isReservedTag;yr=ei(t.modules,"transformNode"),mr=ei(t.modules,"preTransformNode"),Tr=ei(t.modules,"postTransformNode"),cr=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,p=!1;function u(e){if(d(e),o||e.processed||(e=Or(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&Br(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,u=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),u&&u.if&&Br(u,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,u;e.children=e.children.filter((function(e){return!e.slotScope})),d(e),e.pre&&(o=!1),fr(e.tag)&&(p=!1);for(var l=0;l<Tr.length;l++)Tr[l](e,t)}function d(e){if(!p)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||I,o=t.canBeLeftOpenTag||I,p=0,u=function(){if(n=e,a&&ar(a)){var u=0,c=a.toLowerCase(),y=ir[c]||(ir[c]=new RegExp("([\\s\\S]*?)(</"+c+"[^>]*>)","i"));P=e.replace(y,(function(e,n,a){return u=a.length,ar(c)||"noscript"===c||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),ur(c,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),p+=e.length-P.length,e=P,l(c,p-u,p)}else{var m=e.indexOf("<");if(0===m){if(tr.test(e)){var T=e.indexOf("--\x3e");if(T>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,T),p,p+T+3),d(T+3),"continue"}if(nr.test(e)){var f=e.indexOf("]>");if(f>=0)return d(f+2),"continue"}var h=e.match(er);if(h)return d(h[0].length),"continue";var b=e.match(Ys);if(b){var v=p;return d(b[0].length),l(b[1],v,p),"continue"}var g=function(){var t=e.match(Zs);if(t){var n={tagName:t[1],attrs:[],start:p};d(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(Xs))&&(i=e.match(Ws)||e.match(Hs));)i.start=p,d(i[0].length),i.end=p,n.attrs.push(i);if(a)return n.unarySlash=a[1],d(a[0].length),n.end=p,n}}();if(g)return function(e){var n=e.tagName,p=e.unarySlash;s&&("p"===a&&Qs(n)&&l(a),o(n)&&a===n&&l(n));for(var u=r(n)||!!p,d=e.attrs.length,c=new Array(d),y=0;y<d;y++){var m=e.attrs[y],T=m[3]||m[4]||m[5]||"",f="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;c[y]={name:m[1],value:dr(T,f)}}u||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:c,start:e.start,end:e.end}),a=n),t.start&&t.start(n,c,u,e.start,e.end)}(g),ur(g.tagName,e)&&d(1),"continue"}var C=void 0,P=void 0,k=void 0;if(m>=0){for(P=e.slice(m);!(Ys.test(P)||Zs.test(P)||tr.test(P)||nr.test(P)||(k=P.indexOf("<",1))<0);)m+=k,P=e.slice(m);C=e.substring(0,m)}m<0&&(C=e),C&&d(C.length),t.chars&&C&&t.chars(C,p-C.length,p)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==u(););function d(t){p+=t,e=e.substring(t)}function l(e,n,s){var r,o;if(null==n&&(n=p),null==s&&(s=p),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var u=i.length-1;u>=r;u--)t.end&&t.end(i[u].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}l()}(e,{warn:lr,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,d,l){var c=a&&a.ns||br(e);W&&"svg"===c&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];Lr.test(a.name)||(a.name=a.name.replace(Nr,""),t.push(a))}return t}(s));var y,m=Er(e,s,a);c&&(m.ns=c),"style"!==(y=m).tag&&("script"!==y.tag||y.attrsMap.type&&"text/javascript"!==y.attrsMap.type)||ae()||(m.forbidden=!0);for(var T=0;T<mr.length;T++)m=mr[T](m,t)||m;o||(function(e){null!=pi(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),fr(m.tag)&&(p=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(Ur(m),function(e){var t=pi(e,"v-if");if(t)e.if=t,Br(e,{exp:t,block:e});else{null!=pi(e,"v-else")&&(e.else=!0);var n=pi(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=pi(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),r?u(m):(a=m,i.push(m))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],u(s)},chars:function(e,t,n){if(a&&(!W||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,u=a.children;if(e=p||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:Rr(e):u.length?r?"condense"===r&&qr.test(e)?"":" ":s?" ":"":""){p||"condense"!==r||(e=e.replace(Fr," "));var d=void 0,l=void 0;!o&&" "!==e&&(d=function(e,t){var n=t?Ls(t):$s;if(n.test(e)){for(var a,i,s,r=[],o=[],p=n.lastIndex=0;a=n.exec(e);){(i=a.index)>p&&(o.push(s=e.slice(p,i)),r.push(JSON.stringify(s)));var u=Za(a[1].trim());r.push("_s(".concat(u,")")),o.push({"@binding":u}),p=i+a[0].length}return p<e.length&&(o.push(s=e.slice(p)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,cr))?l={type:2,expression:d.expression,tokens:d.tokens,text:e}:" "===e&&u.length&&" "===u[u.length-1].text||(l={type:3,text:e}),l&&u.push(l)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function Or(e,t){var n;!function(e){var t=oi(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=oi(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=pi(e,"scope"),e.slotScope=t||pi(e,"slot-scope")):(t=pi(e,"slot-scope"))&&(e.slotScope=t);var n,a=oi(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||ni(e,"slot",a,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot"))),"template"===e.tag){if(n=ui(e,xr)){var i=Vr(n),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=n.value||Ir}}else if(n=ui(e,xr)){var o=e.scopedSlots||(e.scopedSlots={}),p=Vr(n),u=p.name,d=(r=p.dynamic,o[u]=Er("template",[],e));d.slotTarget=u,d.slotTargetDynamic=r,d.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=d,!0})),d.slotScope=n.value||Ir,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=oi(n,"name")),function(e){var t;(t=oi(e,"is"))&&(e.component=t),null!=pi(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<yr.length;a++)e=yr[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,p,u=e.attrsList;for(t=0,n=u.length;t<n;t++)if(a=i=u[t].name,s=u[t].value,gr.test(a))if(e.hasBindings=!0,(r=$r(a.replace(gr,"")))&&(a=a.replace(Ar,"")),Mr.test(a))a=a.replace(Mr,""),s=Za(s),(p=wr.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!p&&"innerHtml"===(a=k(a))&&(a="innerHTML"),r.camel&&!p&&(a=k(a)),r.sync&&(o=ci(s,"$event"),p?ri(e,'"update:"+('.concat(a,")"),o,null,!1,0,u[t],!0):(ri(e,"update:".concat(k(a)),o,null,!1,0,u[t]),M(a)!==k(a)&&ri(e,"update:".concat(M(a)),o,null,!1,0,u[t])))),r&&r.prop||!e.component&&hr(e.tag,e.attrsMap.type,a)?ti(e,a,s,u[t],p):ni(e,a,s,u[t],p);else if(vr.test(a))a=a.replace(vr,""),(p=wr.test(a))&&(a=a.slice(1,-1)),ri(e,a,s,r,!1,0,u[t],p);else{var d=(a=a.replace(gr,"")).match(_r),l=d&&d[1];p=!1,l&&(a=a.slice(0,-(l.length+1)),wr.test(l)&&(l=l.slice(1,-1),p=!0)),ii(e,a,i,s,l,p,r,u[t])}else ni(e,a,JSON.stringify(s),u[t]),!e.component&&"muted"===a&&hr(e.tag,e.attrsMap.type,a)&&ti(e,a,"true",u[t])}(e),e}function Ur(e){var t;if(t=pi(e,"v-for")){var n=function(e){var t=e.match(Cr);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(kr,""),i=a.match(Pr);return i?(n.alias=a.replace(Pr,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&q(e,n)}}function Br(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Vr(e){var t=e.name.replace(xr,"");return t||"#"!==e.name[0]&&(t="default"),wr.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function $r(e){var t=e.match(Ar);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function Dr(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var Lr=/^xmlns:NS\d+/,Nr=/^NS\d+:/;function zr(e){return Er(e.tag,e.attrsList.slice(),e.parent)}var jr,Gr,Qr=[Ns,zs,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=oi(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=pi(e,"v-if",!0),s=i?"&&(".concat(i,")"):"",r=null!=pi(e,"v-else",!0),o=pi(e,"v-else-if",!0),p=zr(e);Ur(p),ai(p,"type","checkbox"),Or(p,t),p.processed=!0,p.if="(".concat(a,")==='checkbox'")+s,Br(p,{exp:p.if,block:p});var u=zr(e);pi(u,"v-for",!0),ai(u,"type","radio"),Or(u,t),Br(p,{exp:"(".concat(a,")==='radio'")+s,block:u});var d=zr(e);return pi(d,"v-for",!0),ai(d,":type",a),Or(d,t),Br(p,{exp:i,block:d}),r?p.else=!0:o&&(p.elseif=o),p}}}}],Hr={expectHTML:!0,modules:Qr,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return li(e,a,i),!1;if("select"===s)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),s="var $$selectedVal = ".concat(i,";");ri(e,"change",s="".concat(s," ").concat(ci(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=oi(e,"value")||"null",s=oi(e,"true-value")||"true",r=oi(e,"false-value")||"false";ti(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===s?":(".concat(t,")"):":_q(".concat(t,",").concat(s,")"))),ri(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(s,"):(").concat(r,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(ci(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(ci(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(ci(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=oi(e,"value")||"null";i=a?"_n(".concat(i,")"):i,ti(e,"checked","_q(".concat(t,",").concat(i,")")),ri(e,"change",ci(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,p=!s&&"range"!==a,u=s?"change":"range"===a?vi:"input",d="$event.target.value";o&&(d="$event.target.value.trim()"),r&&(d="_n(".concat(d,")"));var l=ci(t,d);p&&(l="if($event.target.composing)return;".concat(l)),ti(e,"value","(".concat(t,")")),ri(e,u,l,null,!0),(o||r)&&ri(e,"blur","$forceUpdate()")}(e,a,i);else if(!D.isReservedTag(s))return li(e,a,i),!1;return!0},text:function(e,t){t.value&&ti(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&ti(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:js,mustUseProp:aa,canBeLeftOpenTag:Gs,isReservedTag:ba,getTagNamespace:va,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(Qr)},Wr=C((function(e){return T("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Kr(e,t){e&&(jr=Wr(t.staticKeys||""),Gr=t.isReservedTag||I,Jr(e),Zr(e,!1))}function Jr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||f(e.tag)||!Gr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(jr))))}(e),1===e.type){if(!Gr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Jr(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;Jr(i),i.static||(e.static=!1)}}}function Zr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Zr(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)Zr(e.ifConditions[n].block,t)}}var Xr=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Yr=/\([^)]*?\);*$/,eo=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,to={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},no={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},ao=function(e){return"if(".concat(e,")return null;")},io={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:ao("$event.target !== $event.currentTarget"),ctrl:ao("!$event.ctrlKey"),shift:ao("!$event.shiftKey"),alt:ao("!$event.altKey"),meta:ao("!$event.metaKey"),left:ao("'button' in $event && $event.button !== 0"),middle:ao("'button' in $event && $event.button !== 1"),right:ao("'button' in $event && $event.button !== 2")};function so(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=ro(e[s]);e[s]&&e[s].dynamic?i+="".concat(s,",").concat(r,","):a+='"'.concat(s,'":').concat(r,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function ro(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return ro(e)})).join(","),"]");var t=eo.test(e.value),n=Xr.test(e.value),a=eo.test(e.value.replace(Yr,""));if(e.modifiers){var i="",s="",r=[],o=function(t){if(io[t])s+=io[t],to[t]&&r.push(t);else if("exact"===t){var n=e.modifiers;s+=ao(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else r.push(t)};for(var p in e.modifiers)o(p);r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(oo).join("&&"),")return null;")}(r)),s&&(i+=s);var u=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(u,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function oo(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=to[e],a=no[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var po={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:R},uo=function(e){this.options=e,this.warn=e.warn||Ya,this.transforms=ei(e.modules,"transformCode"),this.dataGenFns=ei(e.modules,"genData"),this.directives=q(q({},po),e.directives);var t=e.isReservedTag||I;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function lo(e,t){var n=new uo(t),a=e?"script"===e.tag?"null":co(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function co(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return yo(e,t);if(e.once&&!e.onceProcessed)return mo(e,t);if(e.for&&!e.forProcessed)return ho(e,t);if(e.if&&!e.ifProcessed)return To(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=Co(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),s=e.attrs||e.dynamicAttrs?wo((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:k(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=",".concat(s)),r&&(i+="".concat(s?"":",null",",").concat(r)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:Co(t,n,!0);return"_c(".concat(e,",").concat(bo(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=bo(e,t));var s=void 0,r=t.options.bindings;i&&r&&!1!==r.__isScriptSetup&&(s=function(e,t){var n=k(t),a=w(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},s=i("setup-const")||i("setup-reactive-const");if(s)return s;var r=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return r||void 0}(r,e.tag)),s||(s="'".concat(e.tag,"'"));var o=e.inlineTemplate?null:Co(e,t,!0);n="_c(".concat(s).concat(a?",".concat(a):"").concat(o?",".concat(o):"",")")}for(var p=0;p<t.transforms.length;p++)n=t.transforms[p](e,n);return n}return Co(e,t)||"void 0"}function yo(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(co(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function mo(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return To(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(co(e,t),",").concat(t.onceId++,",").concat(n,")"):co(e,t)}return yo(e,t)}function To(e,t,n,a){return e.ifProcessed=!0,fo(e.ifConditions.slice(),t,n,a)}function fo(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(s(i.block),":").concat(fo(e,t,n,a)):"".concat(s(i.block));function s(e){return n?n(e,t):e.once?mo(e,t):co(e,t)}}function ho(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?",".concat(e.iterator1):"",o=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(s).concat(r).concat(o,"){")+"return ".concat((n||co)(e,t))+"})"}function bo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",p=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var u=t.directives[s.name];u&&(r=!!u(e,s,t.warn)),r&&(p=!0,o+='{name:"'.concat(s.name,'",rawName:"').concat(s.rawName,'"').concat(s.value?",value:(".concat(s.value,"),expression:").concat(JSON.stringify(s.value)):"").concat(s.arg?",arg:".concat(s.isDynamicArg?s.arg:'"'.concat(s.arg,'"')):"").concat(s.modifiers?",modifiers:".concat(JSON.stringify(s.modifiers)):"","},"))}return p?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(wo(e.attrs),",")),e.props&&(n+="domProps:".concat(wo(e.props),",")),e.events&&(n+="".concat(so(e.events,!1),",")),e.nativeEvents&&(n+="".concat(so(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||vo(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==Ir||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return go(t[e],n)})).join(",");return"scopedSlots:_u([".concat(r,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=lo(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);s&&(n+="".concat(s,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(wo(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function vo(e){return 1===e.type&&("slot"===e.tag||e.children.some(vo))}function go(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return To(e,t,go,"null");if(e.for&&!e.forProcessed)return ho(e,t,go);var a=e.slotScope===Ir?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(Co(e,t)||"undefined",":undefined"):Co(e,t)||"undefined":co(e,t),"}"),s=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(s,"}")}function Co(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return"".concat((a||co)(r,t)).concat(o)}var p=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(Po(i)||i.ifConditions&&i.ifConditions.some((function(e){return Po(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,u=i||ko;return"[".concat(s.map((function(e){return u(e,t)})).join(","),"]").concat(p?",".concat(p):"")}}function Po(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ko(e,t){return 1===e.type?co(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:_o(JSON.stringify(n.text)),")");var n}function wo(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=_o(i.value);i.dynamic?n+="".concat(i.name,",").concat(s,","):t+='"'.concat(i.name,'":').concat(s,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function _o(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function Mo(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),R}}function Ao(e){var t=Object.create(null);return function(n,a,i){(a=q({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},p=[];return o.render=Mo(r.render,p),o.staticRenderFns=r.staticRenderFns.map((function(e){return Mo(e,p)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var xo,qo,Fo=(xo=function(e,t){var n=Sr(e.trim(),t);!1!==t.optimize&&Kr(n,t);var a=lo(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=q(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=xo(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:Ao(t)}}),Ro=Fo(Hr).compileToFunctions;function Io(e){return(qo=qo||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',qo.innerHTML.indexOf("&#10;")>0}var Eo=!!Q&&Io(!1),So=!!Q&&Io(!0),Oo=C((function(e){var t=Pa(e);return t&&t.innerHTML})),Uo=Wn.prototype.$mount;function Bo(e,t){for(var n in t)e[n]=t[n];return e}Wn.prototype.$mount=function(e,t){if((e=e&&Pa(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=Oo(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=Ro(a,{outputSourceRange:!1,shouldDecodeNewlines:Eo,shouldDecodeNewlinesForHref:So,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return Uo.call(this,e,t)},Wn.compile=Ro;var Vo=/[!'()*]/g,$o=function(e){return"%"+e.charCodeAt(0).toString(16)},Do=/%2C/g,Lo=function(e){return encodeURIComponent(e).replace(Vo,$o).replace(Do,",")};function No(e){try{return decodeURIComponent(e)}catch(e){}return e}var zo=function(e){return null==e||"object"==typeof e?e:String(e)};function jo(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=No(n.shift()),i=n.length>0?No(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Go(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return Lo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(Lo(t)):a.push(Lo(t)+"="+Lo(e)))})),a.join("&")}return Lo(t)+"="+Lo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Qo=/\/?$/;function Ho(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=Wo(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Zo(t,i),matched:e?Jo(e):[]};return n&&(r.redirectedFrom=Zo(n,i)),Object.freeze(r)}function Wo(e){if(Array.isArray(e))return e.map(Wo);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Wo(e[n]);return t}return e}var Ko=Ho(null,{path:"/"});function Jo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Zo(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Go)(a)+i}function Xo(e,t,n){return t===Ko?e===t:!!t&&(e.path&&t.path?e.path.replace(Qo,"")===t.path.replace(Qo,"")&&(n||e.hash===t.hash&&Yo(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Yo(e.query,t.query)&&Yo(e.params,t.params)))}function Yo(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?Yo(s,r):String(s)===String(r)}))}function ep(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var tp={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,p=i.$route,u=i._routerViewCache||(i._routerViewCache={}),d=0,l=!1;i&&i._routerRoot!==i;){var c=i.$vnode?i.$vnode.data:{};c.routerView&&d++,c.keepAlive&&i._directInactive&&i._inactive&&(l=!0),i=i.$parent}if(s.routerViewDepth=d,l){var y=u[o],m=y&&y.component;return m?(y.configProps&&np(m,s,y.route,y.configProps),r(m,s,a)):r()}var T=p.matched[d],f=T&&T.components[o];if(!T||!f)return u[o]=null,r();u[o]={component:f},s.registerRouteInstance=function(e,t){var n=T.instances[o];(t&&n!==e||!t&&n===e)&&(T.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){T.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==T.instances[o]&&(T.instances[o]=e.componentInstance),ep(p)};var h=T.props&&T.props[o];return h&&(Bo(u[o],{route:p,configProps:h}),np(f,s,p,h)),r(f,s,a)}};function np(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=Bo({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function ap(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function ip(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var sp=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},rp=function e(t,n,a){return sp(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return hp(e,t)}(t,n):sp(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return hp(new RegExp("(?:"+i.join("|")+")",bp(a)),n)}(t,n,a):function(e,t,n){return vp(lp(e,n),t,n)}(t,n,a)},op=lp,pp=mp,up=vp,dp=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function lp(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=dp.exec(e));){var p=n[0],u=n[1],d=n.index;if(r+=e.slice(s,d),s=d+p.length,u)r+=u[1];else{var l=e[s],c=n[2],y=n[3],m=n[4],T=n[5],f=n[6],h=n[7];r&&(a.push(r),r="");var b=null!=c&&null!=l&&l!==c,v="+"===f||"*"===f,g="?"===f||"*"===f,C=n[2]||o,P=m||T;a.push({name:y||i++,prefix:c||"",delimiter:C,optional:g,repeat:v,partial:b,asterisk:!!h,pattern:P?fp(P):h?".*":"[^"+Tp(C)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function cp(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function yp(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function mp(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",bp(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?cp:encodeURIComponent,o=0;o<e.length;o++){var p=e[o];if("string"!=typeof p){var u,d=s[p.name];if(null==d){if(p.optional){p.partial&&(i+=p.prefix);continue}throw new TypeError('Expected "'+p.name+'" to be defined')}if(sp(d)){if(!p.repeat)throw new TypeError('Expected "'+p.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(p.optional)continue;throw new TypeError('Expected "'+p.name+'" to not be empty')}for(var l=0;l<d.length;l++){if(u=r(d[l]),!n[o].test(u))throw new TypeError('Expected all "'+p.name+'" to match "'+p.pattern+'", but received `'+JSON.stringify(u)+"`");i+=(0===l?p.prefix:p.delimiter)+u}}else{if(u=p.asterisk?yp(d):r(d),!n[o].test(u))throw new TypeError('Expected "'+p.name+'" to match "'+p.pattern+'", but received "'+u+'"');i+=p.prefix+u}}else i+=p}return i}}function Tp(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function fp(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function hp(e,t){return e.keys=t,e}function bp(e){return e&&e.sensitive?"":"i"}function vp(e,t,n){sp(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=Tp(o);else{var p=Tp(o.prefix),u="(?:"+o.pattern+")";t.push(o),o.repeat&&(u+="(?:"+p+u+")*"),s+=u=o.optional?o.partial?p+"("+u+")?":"(?:"+p+"("+u+"))?":p+"("+u+")"}}var d=Tp(n.delimiter||"/"),l=s.slice(-d.length)===d;return a||(s=(l?s.slice(0,-d.length):s)+"(?:"+d+"(?=$))?"),s+=i?"$":a&&l?"":"(?="+d+"|$)",hp(new RegExp("^"+s,bp(n)),t)}rp.parse=op,rp.compile=function(e,t){return mp(lp(e,t),t)},rp.tokensToFunction=pp,rp.tokensToRegExp=up;var gp=Object.create(null);function Cp(e,t,n){t=t||{};try{var a=gp[e]||(gp[e]=rp.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function Pp(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=Bo({},e)).params;return s&&"object"==typeof s&&(i.params=Bo({},s)),i}if(!i.path&&i.params&&t){(i=Bo({},i))._normalized=!0;var r=Bo(Bo({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=Cp(o,r,t.path)}return i}var p=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),u=t&&t.path||"/",d=p.path?ap(p.path,u,n||i.append):u,l=function(e,t,n){void 0===t&&(t={});var a,i=n||jo;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(zo):zo(r)}return a}(p.query,i.query,a&&a.options.parseQuery),c=i.hash||p.hash;return c&&"#"!==c.charAt(0)&&(c="#"+c),{_normalized:!0,path:d,query:l,hash:c}}var kp,wp=function(){},_p={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,p={},u=n.options.linkActiveClass,d=n.options.linkExactActiveClass,l=null==u?"router-link-active":u,c=null==d?"router-link-exact-active":d,y=null==this.activeClass?l:this.activeClass,m=null==this.exactActiveClass?c:this.exactActiveClass,T=r.redirectedFrom?Ho(null,Pp(r.redirectedFrom),null,n):r;p[m]=Xo(a,T,this.exactPath),p[y]=this.exact||this.exactPath?p[m]:function(e,t){return 0===e.path.replace(Qo,"/").indexOf(t.path.replace(Qo,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,T);var f=p[m]?this.ariaCurrentValue:null,h=function(e){Mp(e)&&(t.replace?n.replace(s,wp):n.push(s,wp))},b={click:Mp};Array.isArray(this.event)?this.event.forEach((function(e){b[e]=h})):b[this.event]=h;var v={class:p},g=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:h,isActive:p[y],isExactActive:p[m]});if(g){if(1===g.length)return g[0];if(g.length>1||!g.length)return 0===g.length?e():e("span",{},g)}if("a"===this.tag)v.on=b,v.attrs={href:o,"aria-current":f};else{var C=Ap(this.$slots.default);if(C){C.isStatic=!1;var P=C.data=Bo({},C.data);for(var k in P.on=P.on||{},P.on){var w=P.on[k];k in b&&(P.on[k]=Array.isArray(w)?w:[w])}for(var _ in b)_ in P.on?P.on[_].push(b[_]):P.on[_]=h;var M=C.data.attrs=Bo({},C.data.attrs);M.href=o,M["aria-current"]=f}else v.on=b}return e(this.tag,v,this.$slots.default)}};function Mp(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function Ap(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=Ap(t.children)))return t}}var xp="undefined"!=typeof window;function qp(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){Fp(s,r,o,e,i)}));for(var p=0,u=s.length;p<u;p++)"*"===s[p]&&(s.push(s.splice(p,1)[0]),u--,p--);return{pathList:s,pathMap:r,nameMap:o}}function Fp(e,t,n,a,i,s){var r=a.path,o=a.name,p=a.pathToRegexpOptions||{},u=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:ip(t.path+"/"+e)}(r,i,p.strict);"boolean"==typeof a.caseSensitive&&(p.sensitive=a.caseSensitive);var d={path:u,regex:Rp(u,p),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?ip(s+"/"+a.path):void 0;Fp(e,t,n,a,d,i)})),t[d.path]||(e.push(d.path),t[d.path]=d),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],c=0;c<l.length;++c){var y={path:l[c],children:a.children};Fp(e,t,n,y,i,d.path||"/")}o&&(n[o]||(n[o]=d))}function Rp(e,t){return rp(e,[],t)}function Ip(e,t){var n=qp(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var p=Pp(e,n,!1,t),u=p.name;if(u){var d=s[u];if(!d)return o(null,p);var l=d.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof p.params&&(p.params={}),n&&"object"==typeof n.params)for(var c in n.params)!(c in p.params)&&l.indexOf(c)>-1&&(p.params[c]=n.params[c]);return p.path=Cp(d.path,p.params),o(d,p,r)}if(p.path){p.params={};for(var y=0;y<a.length;y++){var m=a[y],T=i[m];if(Ep(T.regex,p.path,p.params))return o(T,p,r)}}return o(null,p)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(Ho(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var p=i,u=p.name,d=p.path,l=n.query,c=n.hash,y=n.params;if(l=p.hasOwnProperty("query")?p.query:l,c=p.hasOwnProperty("hash")?p.hash:c,y=p.hasOwnProperty("params")?p.params:y,u)return s[u],r({_normalized:!0,name:u,query:l,hash:c,params:y},void 0,n);if(d){var m=function(e,t){return ap(e,t.parent?t.parent.path:"/",!0)}(d,e);return r({_normalized:!0,path:Cp(m,y),query:l,hash:c},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:Cp(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):Ho(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;qp([t||e],a,i,s,n),n&&n.alias.length&&qp(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){qp(e,a,i,s)}}}function Ep(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?No(a[i]):a[i])}return!0}var Sp=xp&&window.performance&&window.performance.now?window.performance:Date;function Op(){return Sp.now().toFixed(3)}var Up=Op();function Bp(){return Up}function Vp(e){return Up=e}var $p=Object.create(null);function Dp(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=Bo({},window.history.state);return n.key=Bp(),window.history.replaceState(n,"",t),window.addEventListener("popstate",zp),function(){window.removeEventListener("popstate",zp)}}function Lp(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=Bp();if(e)return $p[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){Wp(e,s)})).catch((function(e){})):Wp(r,s))}))}}function Np(){var e=Bp();e&&($p[e]={x:window.pageXOffset,y:window.pageYOffset})}function zp(e){Np(),e.state&&e.state.key&&Vp(e.state.key)}function jp(e){return Qp(e.x)||Qp(e.y)}function Gp(e){return{x:Qp(e.x)?e.x:window.pageXOffset,y:Qp(e.y)?e.y:window.pageYOffset}}function Qp(e){return"number"==typeof e}var Hp=/^#\d/;function Wp(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Hp.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Qp((n=s).x)?n.x:0,y:Qp(n.y)?n.y:0})}else jp(e)&&(t=Gp(e))}else a&&jp(e)&&(t=Gp(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Kp,Jp=xp&&(-1===(Kp=window.navigator.userAgent).indexOf("Android 2.")&&-1===Kp.indexOf("Android 4.0")||-1===Kp.indexOf("Mobile Safari")||-1!==Kp.indexOf("Chrome")||-1!==Kp.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Zp(e,t){Np();var n=window.history;try{if(t){var a=Bo({},n.state);a.key=Bp(),n.replaceState(a,"",e)}else n.pushState({key:Vp(Op())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Xp(e){Zp(e,!0)}var Yp={redirected:2,aborted:4,cancelled:8,duplicated:16};function eu(e,t){return tu(e,t,Yp.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function tu(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var nu=["params","query","hash"];function au(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function iu(e,t){return au(e)&&e._isRouter&&(null==t||e.type===t)}function su(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}function ru(e,t){return ou(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function ou(e){return Array.prototype.concat.apply([],e)}var pu="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function uu(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var du=function(e,t){this.router=e,this.base=function(e){if(!e)if(xp){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Ko,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function lu(e,t,n,a){var i=ru(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=kp.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return ou(a?i.reverse():i)}function cu(e,t){if(t)return function(){return e.apply(t,arguments)}}du.prototype.listen=function(e){this.cb=e},du.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},du.prototype.onError=function(e){this.errorCbs.push(e)},du.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(iu(e,Yp.redirected)&&s===Ko||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},du.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!iu(e)&&au(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},p=e.matched.length-1,u=i.matched.length-1;if(Xo(e,i)&&p===u&&e.matched[p]===i.matched[u])return this.ensureURL(),e.hash&&Lp(this.router,i,e,!1),o(((r=tu(s=i,e,Yp.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var d,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),c=l.updated,y=l.deactivated,m=l.activated,T=[].concat(function(e){return lu(e,"beforeRouteLeave",cu,!0)}(y),this.router.beforeHooks,function(e){return lu(e,"beforeRouteUpdate",cu)}(c),m.map((function(e){return e.beforeEnter})),(d=m,function(e,t,n){var a=!1,i=0,s=null;ru(d,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var p,u=uu((function(t){var a;((a=t).__esModule||pu&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:kp.extend(t),r.components[o]=t,--i<=0&&n()})),d=uu((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=au(e)?e:new Error(t),n(s))}));try{p=e(u,d)}catch(e){d(e)}if(p)if("function"==typeof p.then)p.then(u,d);else{var l=p.component;l&&"function"==typeof l.then&&l.then(u,d)}}})),a||n()})),f=function(t,n){if(a.pending!==e)return o(eu(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return tu(e,t,Yp.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):au(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return tu(e,t,Yp.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return nu.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};su(T,f,(function(){var n=function(e){return lu(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(m);su(n.concat(a.router.resolveHooks),f,(function(){if(a.pending!==e)return o(eu(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){ep(e)}))}))}))},du.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},du.prototype.setupListeners=function(){},du.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Ko,this.pending=null};var yu=function(e){function t(t,n){e.call(this,t,n),this._startLocation=mu(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Jp&&n;a&&this.listeners.push(Dp());var i=function(){var n=e.current,i=mu(e.base);e.current===Ko&&i===e._startLocation||e.transitionTo(i,(function(e){a&&Lp(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Zp(ip(a.base+e.fullPath)),Lp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Xp(ip(a.base+e.fullPath)),Lp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(mu(this.base)!==this.current.fullPath){var t=ip(this.base+this.current.fullPath);e?Zp(t):Xp(t)}},t.prototype.getCurrentLocation=function(){return mu(this.base)},t}(du);function mu(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(ip(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var Tu=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=mu(e);if(!/^\/#/.test(t))return window.location.replace(ip(e+"/#"+t)),!0}(this.base)||fu()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Jp&&t;n&&this.listeners.push(Dp());var a=function(){var t=e.current;fu()&&e.transitionTo(hu(),(function(a){n&&Lp(e.router,a,t,!0),Jp||gu(a.fullPath)}))},i=Jp?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){vu(e.fullPath),Lp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){gu(e.fullPath),Lp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;hu()!==t&&(e?vu(t):gu(t))},t.prototype.getCurrentLocation=function(){return hu()},t}(du);function fu(){var e=hu();return"/"===e.charAt(0)||(gu("/"+e),!1)}function hu(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function bu(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function vu(e){Jp?Zp(bu(e)):window.location.hash=e}function gu(e){Jp?Xp(bu(e)):window.location.replace(bu(e))}var Cu=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){iu(e,Yp.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(du),Pu=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ip(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Jp&&!1!==e.fallback,this.fallback&&(t="hash"),xp||(t="abstract"),this.mode=t,t){case"history":this.history=new yu(this,e.base);break;case"hash":this.history=new Tu(this,e.base,this.fallback);break;case"abstract":this.history=new Cu(this,e.base)}},ku={currentRoute:{configurable:!0}};Pu.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},ku.currentRoute.get=function(){return this.history&&this.history.current},Pu.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof yu||n instanceof Tu){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Jp&&i&&"fullPath"in e&&Lp(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},Pu.prototype.beforeEach=function(e){return _u(this.beforeHooks,e)},Pu.prototype.beforeResolve=function(e){return _u(this.resolveHooks,e)},Pu.prototype.afterEach=function(e){return _u(this.afterHooks,e)},Pu.prototype.onReady=function(e,t){this.history.onReady(e,t)},Pu.prototype.onError=function(e){this.history.onError(e)},Pu.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},Pu.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},Pu.prototype.go=function(e){this.history.go(e)},Pu.prototype.back=function(){this.go(-1)},Pu.prototype.forward=function(){this.go(1)},Pu.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},Pu.prototype.resolve=function(e,t,n){var a=Pp(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?ip(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},Pu.prototype.getRoutes=function(){return this.matcher.getRoutes()},Pu.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Ko&&this.history.transitionTo(this.history.getCurrentLocation())},Pu.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Ko&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Pu.prototype,ku);var wu=Pu;function _u(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}Pu.install=function e(t){if(!e.installed||kp!==t){e.installed=!0,kp=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",tp),t.component("RouterLink",_p);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Pu.version="3.6.5",Pu.isNavigationFailure=iu,Pu.NavigationFailureType=Yp,Pu.START_LOCATION=Ko,xp&&window.Vue&&window.Vue.use(Pu);var Mu=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function Au(e,t,n,a,i,s,r,o){var p,u="function"==typeof e?e.options:e;if(t&&(u.render=t,u.staticRenderFns=n,u._compiled=!0),a&&(u.functional=!0),s&&(u._scopeId="data-v-"+s),r?(p=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},u._ssrRegister=p):i&&(p=o?function(){i.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:i),p)if(u.functional){u._injectStyles=p;var d=u.render;u.render=function(e,t){return p.call(t),d(e,t)}}else{var l=u.beforeCreate;u.beforeCreate=l?[].concat(l,p):[p]}return{exports:e,options:u}}Mu._withStripped=!0,n(209);const xu=Au({},Mu,[],!1,null,null,null).exports;var qu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};qu._withStripped=!0;var Fu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Fu._withStripped=!0;const Ru=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}'),Iu=Au({data:function(){return{repository:Ru.cj,name:Ru.u2}},methods:{openLink(e){window.open(e,"_blank")}}},Fu,[],!1,null,null,null).exports;var Eu=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};Eu._withStripped=!0;const Su=Au({},Eu,[],!1,null,null,null).exports;var Ou=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Ou._withStripped=!0;var Uu=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};Uu._withStripped=!0;const Bu={components:{MemberSection:Au({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Uu,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},Vu=Au(Bu,Ou,[],!1,null,null,null).exports;var $u=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};$u._withStripped=!0;var Du=Au({components:{Member:Vu},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},$u,[],!1,null,null,null);const Lu=Au({components:{Member:Vu,MemberSet:Du.exports,HeaderBar:Su,FooterBar:Iu},props:{json:{type:Object,default:()=>new Object}}},qu,[],!1,null,null,null).exports;var Nu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};Nu._withStripped=!0;var zu=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};zu._withStripped=!0;var ju=Au({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},zu,[],!1,null,null,null);const Gu=Au({components:{Branch:ju.exports,FooterBar:Iu},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Nu,[],!1,null,null,null).exports;Wn.use(wu);const Qu={"contracts/collateral/coinbase/MocCACoinbase.sol:MocCACoinbase":{source:"contracts/collateral/coinbase/MocCACoinbase.sol",name:"MocCACoinbase",title:"MocCACoinbase: Moc Collateral Asset Coinbase",notice:"Moc protocol implementation using network Coinbase as Collateral Asset",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"coinbaseFailedTransferFallback()":{inputs:[],name:"coinbaseFailedTransferFallback",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize((((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256),address,address,address,uint256,address),uint256,address))":{inputs:[{components:[{components:[{components:[{internalType:"address",name:"mocQueueAddress",type:"address"},{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams",type:"tuple"},{internalType:"uint256",name:"transferMaxGas",type:"uint256"},{internalType:"address",name:"coinbaseFailedTransferFallback",type:"address"}],internalType:"struct MocCACoinbase.InitializeParams",name:"initializeParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract      mocQueueAddress address for MocQueue contract      transferMaxGas max amount of gas forwarded on AC transfer      coinbaseFailedTransferFallback address who receives the funds when the coinbase unlock fails",params:{initializeParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"}],name:"mintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token"},"mintTCViaVendor(uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTCandTP(address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPViaVendor(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPto(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPtoViaVendor(address,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCto(uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token"},"mintTCtoViaVendor(uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTP(address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"}],name:"mintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and receives Pegged Token"},"mintTPViaVendor(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTPto(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Pegged Token"},"mintTPtoViaVendor(address,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTransferMAxGas(uint256)":{inputs:[{internalType:"uint256",name:"transferMaxGas_",type:"uint256"}],name:"setTransferMAxGas",outputs:[],stateMutability:"nonpayable",type:"function",params:{transferMaxGas_:"new max amount of gas forwarded on AC transfer"},notice:"sets max amount of gas forwarded on AC transfer"},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Pegged Token"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTCforTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Pegged Token"},"swapTCforTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTC(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives Collateral Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token"},"swapTPforTCtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTP(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives another one"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPViaVendor(address,address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPto(address,address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one"},"swapTPforTPtoViaVendor(address,address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferMaxGas()":{inputs:[],name:"transferMaxGas",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function must be overridden by the AC implementation",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/collateral/rc20/MocCARC20.sol:MocCARC20":{source:"contracts/collateral/rc20/MocCARC20.sol",name:"MocCARC20",title:"MocCARC20: Moc Collateral Asset RC20",notice:"Moc protocol implementation using a RC20 as Collateral Asset.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acToken()":{inputs:[],name:"acToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize((((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256),address,address,address,uint256,address),address))":{inputs:[{components:[{components:[{components:[{internalType:"address",name:"mocQueueAddress",type:"address"},{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams",type:"tuple"},{internalType:"address",name:"acTokenAddress",type:"address"}],internalType:"struct MocCARC20.InitializeParams",name:"initializeParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      acTokenAddress Collateral Asset Token contract address      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract      mocQueueAddress address for MocQueue contract",params:{initializeParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token Requires prior sender approval of Collateral Asset to this contract "},"mintTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract"},"mintTCandTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token and Pegged Token  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  Requires prior sender approval of Collateral Asset to this contract"},"mintTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Pegged Token Requires prior sender approval of Collateral Asset to this contract"},"mintTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Pegged Token Requires prior sender approval of Collateral Asset to this contract"},"mintTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"refreshACBalance()":{inputs:[],name:"refreshACBalance",outputs:[],stateMutability:"nonpayable",type:"function",details:"Intended to be use as notification after an RC20 AC transfer to this contract",notice:"Refreshes the AC holdings for the Bucket"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and receives Pegged Token."},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and receives Pegged Token.  `vendor_` receives a markup in Fee Token if possible or in qAC if not."},"swapTCforTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"Address who receives the Pegged Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and recipient receives Pegged Token."},"swapTCforTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"Address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and recipient receives Pegged Token.  `vendor_` receives a markup in Fee Token if possible or in qAC if not."},"swapTPforTC(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives Collateral Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token"},"swapTPforTCtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTP(address,address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives another one"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPViaVendor(address,address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPto(address,address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one"},"swapTPforTPtoViaVendor(address,address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function must be overridden by the AC implementation",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocBaseBucket.sol:MocBaseBucket":{source:"contracts/core/MocBaseBucket.sol",name:"MocBaseBucket",title:"MocBaseBucket: Moc Collateral Bag",details:"Abstracts all rw operations on the main bucket and expose all calculations relative to its state.",notice:"MocBaseBucket holds Bucket Zero state, both for the Collateral Bag and PeggedTokens Items.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCommons.sol:MocCommons":{source:"contracts/core/MocCommons.sol",name:"MocCommons",title:"MocCommons",details:"To bypass the 24kb size limitation on MocCore we use MocCoreExpansion contract. Some functions  are implemented there and MocCore delegates calls to it. To achieve that, we need both to have the  exact same storage layout and be able to access the same common functions.  MocCommons contract serves as the last shared ancestor in the line of inheritance for them,  and all storage variables must be either declared here or in a parent contract.  Declaring variables after this point could result in storage collisions.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCore.sol:MocCore":{source:"contracts/core/MocCore.sol",name:"MocCore",title:"MocCore",notice:"MocCore nucleates all the basic MoC functionality and tool set. It allows Collateral asset aware contracts to implement the main mint/redeem operations.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCoreExpansion.sol:MocCoreExpansion":{source:"contracts/core/MocCoreExpansion.sol",name:"MocCoreExpansion",title:"MocCoreExpansion",details:"IMPORTANT NOTES:  1. MocCore and MocCoreExpansion must have always the same storage layout to avoid collisions  2. Because MocCore is upgradeable and delegates calls to MocCoreExpansion, it cannot be upgradeable because      a proxy contract cannot delegate calls to another proxy contract. So, for any MocCoreExpansion upgrade      you must deploy a new implementation and set it to MocCore.",notice:"This contract is used as an expansion of MocCore because 24kb size limitation  MocCore delegate some function calls to it.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is called by MocCore contract using it's context with delegate call  Checks done there:  -  onlyAuthorizedChanger: the caller must have governance authorization.tpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements:  - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is called by MocCore contract using it's context with delegate call  Checks done there:  -  onlyAuthorizedChanger: the caller must have governance authorization.tpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTPTo(address,address,address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"sender_",type:"address"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"uint256",name:"mocACBalance",type:"uint256"}],name:"liqRedeemTPTo",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"This function is called by MocCore contract using it's context with delegate call  The equivalent AC given the liquidation frozen price(qACRedeemed) is transferred  to the `recipient_` by MocCore contract  Checks done there:  -  notPaused: the contract must be unpaused",params:{recipient_:"address who receives the AC",sender_:"address owner of the TP to be redeemed",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPto((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"i_ Pegged Token index      qTP_ amount of Pegged Token to mint      qACmax_ maximum amount of Collateral Asset that can be spent      sender_ address who sends Collateral Asset      recipient_ address who receives the Collateral Token and Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is applied",params:{params_:"mint TC and TP function parameters"},returns:{feeCalcs:"platform fee detail breakdown",qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTCtoMint:"amount of Collateral Token minted"},notice:"mint Collateral Token and Pegged Token in exchange for Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPto((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"i_ Pegged Token index      qTC_ amount of Collateral Token to redeem      qTP_ maximum amount of Pegged Token to redeem      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive      sender_ address who sends Collateral Token and Pegged Token      recipient_ address who receives the Collateral Asset      vendor_ address who receives a markup. If its address(0) no markup is applied",params:{params_:"redeem TC and TP function parameters"},returns:{feeCalcs:"platform fee detail breakdown",qACtoRedeem:"amount of AC sent to `recipient_`",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoRedeem:"amount of Pegged Token redeemed"},notice:"redeem Collateral Asset in exchange for Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPto((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calli_ Pegged Token index      qTC_ amount of Collateral Token to swap      qTPmin_ minimum amount of Pegged Token Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Collateral Token      recipient_ address who receives the Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TC for TP function parameters"},returns:{qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoMint:"amount of Pegged Token minted"},notice:"swap Collateral Token to Pegged Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCto((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calli_ Pegged Token index      qTP_ amount Pegged Token to swap      qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Pegged Token      recipient_ address who receives Collateral Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TP for TC function parameters"},returns:{feeCalcs:"struct with:",qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTCtoMint:"amount of Collateral Token minted"},notice:"swap Pegged Token to Collateral Token"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPto((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calliFrom_ owned Pegged Token index      iTo_ target Pegged Token index      qTP_ amount of owned Pegged Token to swap      qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Pegged Token      recipient_ address who receives the target Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TP for TP function parameters"},returns:{feeCalcs:"struct with:",qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoMint:"amount of Pegged Token minted"},notice:"swap Pegged Token to another one  This operation is done without checking coverage unless the target coverage for  received Pegged Token is greater than the Pegged Token sent"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocEma.sol:MocEma":{source:"contracts/core/MocEma.sol",name:"MocEma",title:"MocEma: Exponential Moving Average",details:"More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing",notice:"Moc Ema, provides a set of methods that allows to calculate and track Exponential Moving Average for each of the pegged Tokens.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocOperations.sol:MocOperations":{source:"contracts/core/MocOperations.sol",name:"MocOperations",title:"MocOperations",notice:"All the Moc Protocol operations are grouped in this contract",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = (ctargemaTP * qAC) / (qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function must be overridden by the AC implementation",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/governance/Governed.sol:Governed":{source:"contracts/governance/Governed.sol",name:"Governed",title:"Governed",details:"This contract is not usable on its own since it does not have any _productive useful_ behavior The only purpose of this contract is to define some useful modifiers and functions to be used on the governance aspect of the child contract",notice:"Base contract to be inherited by governed contracts",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"}}},"contracts/governance/MocUpgradable.sol:MocUpgradable":{source:"contracts/governance/MocUpgradable.sol",name:"MocUpgradable",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/governance/Stoppable.sol:Stoppable":{source:"contracts/governance/Stoppable.sol",name:"Stoppable",title:"Stoppable",details:"This contract was heavily based on the _Pausable_ contract of openzeppelin-eth but it was modified in order to being able to turn on and off its stoppability",notice:"Allow a contract to be paused through the stopper subsystem. This contracts is able to disable the stoppability feature through governance.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"}}},"contracts/governance/changerTemplates/AddPeggedTokenChangerTemplate.sol:AddPeggedTokenChangerTemplate":{source:"contracts/governance/changerTemplates/AddPeggedTokenChangerTemplate.sol",name:"AddPeggedTokenChangerTemplate",title:"AddPeggedTokenChangerTemplate",details:"This template only considers adding MocRC20, they are governed and use EnumerableAccessControl for roles. For any other type of Pegged Token it must be modified to achieve similar validations",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus governance system. It allows the addition of a new Pegged Token to the system.",constructor:{inputs:[{internalType:"contract MocCore",name:"mocCore_",type:"address"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"getPeggedTokenParams()":{inputs:[],name:"getPeggedTokenParams",outputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns the Pegged Token Params configurations that's going to be added"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCore",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/governance/changerTemplates/EditPeggedTokenChangerTemplate.sol:EditPeggedTokenChangerTemplate":{source:"contracts/governance/changerTemplates/EditPeggedTokenChangerTemplate.sol",name:"EditPeggedTokenChangerTemplate",title:"EditPeggedTokenChangerTemplate",details:"IMPORTANT: This template provides a basic framework for Pegged Token params editions, but it's not intended to be use out of the box. Depending on the combination of params you need to edit, you'll need to generate new methods, disable others and adjust the  `PARAMS_CHANGED` config. In this example, only the priceProvider address is used as showcase. Also please notice that params values, are not verify on the target contract, so it's desirable that the changer itself do it. See `AditPeggedTokenChangerTemplate.sol` for reference.",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus  governance system. It allows the edition of an existent Pegged Token to the system.",constructor:{inputs:[{internalType:"contract MocCore",name:"mocCore_",type:"address"},{internalType:"contract IMocRC20",name:"tpToEdit_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"getPeggedTokenParams()":{inputs:[],name:"getPeggedTokenParams",outputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns the Pegged Token Params configurations that's going to be edited"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCore",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paramSet()":{inputs:[],name:"paramSet",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setPriceProvider(address)":{inputs:[{internalType:"address",name:"priceProvider_",type:"address"}],name:"setPriceProvider",outputs:[],stateMutability:"nonpayable",type:"function",params:{priceProvider_:"new pegged token price provider"},notice:"contract initializer"},"tpToEdit()":{inputs:[],name:"tpToEdit",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/governance/changerTemplates/GovernanceChangerTemplate.sol:GovernanceChangerTemplate":{source:"contracts/governance/changerTemplates/GovernanceChangerTemplate.sol",name:"GovernanceChangerTemplate",title:"GovernanceChangerTemplate",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus  governance system.",constructor:{inputs:[{internalType:"contract Governed",name:"governed_",type:"address"},{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"governed()":{inputs:[],name:"governed",outputs:[{internalType:"contract Governed",name:"",type:"address"}],stateMutability:"view",type:"function"},"newGovernor()":{inputs:[],name:"newGovernor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/governance/changerTemplates/UpgraderUUPSChangerTemplate.sol:UpgraderUUPSChangerTemplate":{source:"contracts/governance/changerTemplates/UpgraderUUPSChangerTemplate.sol",name:"UpgraderUUPSChangerTemplate",title:"UpgraderUUPSChangerTemplate",notice:"This contract is a ChangeContract intended to be used when upgrading a MOC UUPS contract, through the Moc upgradeability system. This doesn't initialize the upgraded contract, that should be done extending this one or taking it as a guide",methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture IMPORTANT: This function should not be overridden, you should only redefine _beforeUpgrade and _afterUpgrade methods to use this template",notice:"Execute the changes."},"newImplementation()":{inputs:[],name:"newImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxy()":{inputs:[],name:"proxy",outputs:[{internalType:"contract UUPSUpgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IChangeContract.sol:IChangeContract":{source:"contracts/interfaces/IChangeContract.sol",name:"IChangeContract",title:"IChangeContract",details:"If you plan to do some changes to a system governed by this project you should write a contract that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance system is fully in place.",notice:"This interface is the one used by the governance system.",methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Override this function with a recipe of the changes to be done when this ChangeContract is executed"}}},"contracts/interfaces/IDataProvider.sol:IDataProvider":{source:"contracts/interfaces/IDataProvider.sol",name:"IDataProvider",title:"IDataProvider",details:"https://github.com/money-on-chain/Amphiraos-Oracle",notice:"Amphiraos-Oracle Interface for peeking the data from an oracle",methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"data",type:"bytes32"},{internalType:"bool",name:"valid",type:"bool"}],stateMutability:"view",type:"function",params:{data:"peeked",valid:"true if the data is valid"},notice:"returns the given `data` if `valid`"}}},"contracts/interfaces/IDispatcher.sol:IDispatcher":{source:"contracts/interfaces/IDispatcher.sol",name:"IDispatcher",title:"IDispatcher TODO: add doc",methods:{"getCombinedCglb(uint256)":{inputs:[{internalType:"uint256",name:"localCglb_",type:"uint256"}],name:"getCombinedCglb",outputs:[{internalType:"uint256",name:"combinedCglb",type:"uint256"}],stateMutability:"view",type:"function"},"getRealTCAvailableToRedeem(uint256)":{inputs:[{internalType:"uint256",name:"localTCAvailableToRedeem_",type:"uint256"}],name:"getRealTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"realTCAvailableToRedeem_",type:"uint256"}],stateMutability:"view",type:"function"},"getRealTPAvailableToMint(uint256)":{inputs:[{internalType:"uint256",name:"localTPAvailableToMint_",type:"uint256"}],name:"getRealTPAvailableToMint",outputs:[{internalType:"uint256",name:"realTCAvailableToMint_",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IGovernor.sol:IGovernor":{source:"contracts/interfaces/IGovernor.sol",name:"IGovernor",title:"IGovernor",details:"This interface **MUST** be compatible with the corresponding Governance instance used on Production, from https://github.com/money-on-chain/Areopagus-Governance",notice:"Governor interface. This functions should be overwritten to enable the communication with the rest of the system",methods:{"executeChange(address)":{inputs:[{internalType:"contract IChangeContract",name:"changeContract_",type:"address"}],name:"executeChange",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function should be protected somehow to only execute changes that benefit the system. This decision process is independent of this architecture therefore is independent of this interface too",params:{changeContract_:"Address of the contract that will execute the changes"},notice:"Function to be called to make the changes described in changeContract"},"isAuthorizedChanger(address)":{inputs:[{internalType:"address",name:"changer_",type:"address"}],name:"isAuthorizedChanger",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{changer_:"Address of the contract that will execute the changes"},notice:"Returns whether this `changer_` is authorized to execute changes."}}},"contracts/interfaces/IMocRC20.sol:IMocRC20":{source:"contracts/interfaces/IMocRC20.sol",name:"IMocRC20",title:"IMocRC20",notice:"Base Moc ERC20 Token Interface: burn, mint. It can be both Pegs and Collateral Tokens.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. See {ERC20-_burn}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/interfaces/IPriceProvider.sol:IPriceProvider":{source:"contracts/interfaces/IPriceProvider.sol",name:"IPriceProvider",title:"IPriceFeed",details:"https://github.com/money-on-chain/Amphiraos-Oracle",notice:"Amphiraos-Oracle Interface for peeking the price of a given asset",methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"price",type:"bytes32"},{internalType:"bool",name:"valid",type:"bool"}],stateMutability:"view",type:"function",params:{price:"assetPrice",valid:"true if the price is valid"},notice:"returns the given `price` for the asset if `valid`"}}},"contracts/queue/MocQueue.sol:MocQueue":{source:"contracts/queue/MocQueue.sol",name:"MocQueue",title:"MocQueue: Allows queue Operation deferral execution processing",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"OperationError(uint256,bytes4,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"bytes4",name:"errorCode_",type:"bytes4"},{indexed:!1,internalType:"string",name:"msg_",type:"string"}],name:"OperationError",type:"event"},"OperationExecuted(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"executor",type:"address"},{indexed:!0,internalType:"uint256",name:"operId_",type:"uint256"}],name:"OperationExecuted",type:"event"},"OperationQueued(address,uint256,uint8)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"bucket_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"enum MocQueueExecFees.OperType",name:"operType_",type:"uint8"}],name:"OperationQueued",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"TCMinted(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCMinted",type:"event"},"TCRedeemed(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCRedeemed",type:"event"},"TCSwappedForTP(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCSwappedForTP",type:"event"},"TCandTPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCandTPMinted",type:"event"},"TCandTPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCandTPRedeemed",type:"event"},"TPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPMinted",type:"event"},"TPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPRedeemed",type:"event"},"TPSwappedForTC(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPSwappedForTC",type:"event"},"TPSwappedForTP(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tpFrom_",type:"address"},{indexed:!1,internalType:"address",name:"tpTo_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTPfrom_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTPto_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPSwappedForTP",type:"event"},"UnhandledError(uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"bytes",name:"reason_",type:"bytes"}],name:"UnhandledError",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"execFee(uint8)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"",type:"uint8"}],name:"execFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"execute(address)":{inputs:[{internalType:"address",name:"executionFeeRecipient",type:"address"}],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"does not revert on Operation failure, throws Process and Error events according to the Oper type and result",notice:"registered executors can process Operations in the queue"},"firstOperId()":{inputs:[],name:"firstOperId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getAndVerifyExecFee(uint8,uint256)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"operType_",type:"uint8"},{internalType:"uint256",name:"value_",type:"uint256"}],name:"getAndVerifyExecFee",outputs:[{internalType:"uint256",name:"currentExecFee",type:"uint256"}],stateMutability:"view",type:"function",details:"only used for coinbase flavor",params:{operType_:"operation type registered",value_:"value sent to pay execution fee"},returns:{currentExecFee:"execution fee required for the operation"},notice:"get execution fee for the operation requested  reverts if value sent is not enough to pay the execution fee"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint128,uint128,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{internalType:"address",name:"governor_",type:"address"},{internalType:"address",name:"pauser_",type:"address"},{internalType:"uint128",name:"minOperWaitingBlk_",type:"uint128"},{internalType:"uint128",name:"maxOperPerBatch_",type:"uint128"},{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isEmpty()":{inputs:[],name:"isEmpty",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue is empty"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxOperPerBatch()":{inputs:[],name:"maxOperPerBatch",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function"},"minOperWaitingBlk()":{inputs:[],name:"minOperWaitingBlk",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function"},"mocOperations()":{inputs:[],name:"mocOperations",outputs:[{internalType:"contract MocOperations",name:"",type:"address"}],stateMutability:"view",type:"function"},"operIdCount()":{inputs:[],name:"operIdCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operationsMintTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTC",outputs:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsMintTCandTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTCandTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsMintTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTC",outputs:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTCandTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTCandTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTCforTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTCforTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTPforTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTPforTC",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTPforTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTPforTP",outputs:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"opersInfo(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"opersInfo",outputs:[{internalType:"enum MocQueueExecFees.OperType",name:"operType",type:"uint8"},{internalType:"uint248",name:"queuedBlk",type:"uint248"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"queueMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params",type:"tuple"}],name:"queueMintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params",type:"tuple"}],name:"queueMintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params",type:"tuple"}],name:"queueMintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params",type:"tuple"}],name:"queueRedeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params",type:"tuple"}],name:"queueRedeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params",type:"tuple"}],name:"queueRedeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params",type:"tuple"}],name:"queueSwapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params",type:"tuple"}],name:"queueSwapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params",type:"tuple"}],name:"queueSwapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"readyToExecute()":{inputs:[],name:"readyToExecute",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue has at least one Operation ready to be executed"},"registerBucket(address)":{inputs:[{internalType:"contract MocOperations",name:"bucket_",type:"address"}],name:"registerBucket",outputs:[],stateMutability:"nonpayable",type:"function",details:"in order to operate, the queue needs to be whitelisted as EXECUTOR on the bucket as well",params:{bucket_:"address of the mocOperations implementation to interact with May emit a {RoleGranted} event for ENQUEUER role"},notice:"registers the mocOperations bucket that would operate over this queue"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setMaxOperPerBatch(uint128)":{inputs:[{internalType:"uint128",name:"maxOperPerBatch_",type:"uint128"}],name:"setMaxOperPerBatch",outputs:[],stateMutability:"nonpayable",type:"function",params:{maxOperPerBatch_:"maximum amount of operations allowed on a batch to avoid going over the block gas limit"},notice:"sets Moc Queue maximum amount of operations per execution batch"},"setMinOperWaitingBlk(uint128)":{inputs:[{internalType:"uint128",name:"minOperWaitingBlk_",type:"uint128"}],name:"setMinOperWaitingBlk",outputs:[],stateMutability:"nonpayable",type:"function",params:{minOperWaitingBlk_:"minimum amount of blocks an operation needs to remain in the queue before it can be executed"},notice:"sets Moc Queue minimum operation waiting blocks"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateExecutionFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"updateExecutionFees",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/queue/MocQueueExecFees.sol:MocQueueExecFees":{source:"contracts/queue/MocQueueExecFees.sol",name:"MocQueueExecFees",title:"MocQueue Execution Fee: Handles Queuing execution fees",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"execFee(uint8)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"",type:"uint8"}],name:"execFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getAndVerifyExecFee(uint8,uint256)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"operType_",type:"uint8"},{internalType:"uint256",name:"value_",type:"uint256"}],name:"getAndVerifyExecFee",outputs:[{internalType:"uint256",name:"currentExecFee",type:"uint256"}],stateMutability:"view",type:"function",details:"only used for coinbase flavor",params:{operType_:"operation type registered",value_:"value sent to pay execution fee"},returns:{currentExecFee:"execution fee required for the operation"},notice:"get execution fee for the operation requested  reverts if value sent is not enough to pay the execution fee"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isEmpty()":{inputs:[],name:"isEmpty",outputs:[{internalType:"bool",name:"isEmpty",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue is empty"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateExecutionFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"updateExecutionFees",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/tokens/MocRC20.sol:MocRC20":{source:"contracts/tokens/MocRC20.sol",name:"MocRC20",title:"MocRC20",details:"ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.",notice:"Base Moc ERC20 Token: burn, mint. It can be both Pegs and Collateral Tokens.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. * See {ERC20-_burn}. Requirements: - the caller must have the `BURNER_ROLE`."},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,address,address)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"admin_",type:"address"},{internalType:"contract IGovernor",name:"governor_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"See {__MocRC20_init}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferAllRoles(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"transferAllRoles",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants all `roles` to `account` while sender renounces to all ``role`` If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. - no one else must have any other role May emit a {RoleGranted x3, RoleRevoked x3} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/tokens/MocTC.sol:MocTC":{source:"contracts/tokens/MocTC.sol",name:"MocTC",title:"MocTC",details:"ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.",notice:"Base Moc  ERC20 Collateral Tokens: Allows burn, mint and pause.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event",details:"Emitted when the pause is triggered by `account`."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event",details:"Emitted when the pause is lifted by `account`."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. * See {ERC20-_burn}. Requirements: - the caller must have the `BURNER_ROLE`."},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,address,address)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"admin_",type:"address"},{internalType:"contract IGovernor",name:"governor_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `PAUSER_ROLE` to `admin` address. See {MocRC20-constructor}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Pauses the contract. See {ERC20PausableUpgradeable-_pause}. Requirements: - the caller must have the `PAUSER_ROLE`."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferAllRoles(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"transferAllRoles",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants all `roles` to `account` while sender renounces to all ``role``. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. - no one else must have any other role May emit a {RoleGranted x4, RoleRevoked x4} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/utils/MocAccessControlled.sol:MocAccessControlled":{source:"contracts/utils/MocAccessControlled.sol",name:"MocAccessControlled",title:"MocAccessControlled",details:"grant and revoke functions are overwritten so that they are also      compatible with governance authorization mechanism.",notice:"Extends Moc Upgradable capabilities, with access control capabilities",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/utils/MocHelper.sol:MocHelper":{source:"contracts/utils/MocHelper.sol",name:"MocHelper"},"contracts/vendors/MocVendors.sol:MocVendors":{source:"contracts/vendors/MocVendors.sol",name:"MocVendors",title:"MocVendors",notice:"MocVendors allows a third-party to add a markup to all operations  A vendor can set a markup themselves or ask vendors guardian to do it on their behalf.  Considerations:  - Theres is not a markup limit or restriction  - The currency that the vendor receives is always the same that is used to pay fees(AC or Fee Token)  - A malicious vendor front running an operation increasing the markup is protected in some way      by the maximum (AC or Fee Token) that the user expect to spend(or de minimum that expect to receive)",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."},"VendorMarkupChanged(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"vendorAddress_",type:"address"},{indexed:!1,internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"VendorMarkupChanged",type:"event"}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize(address,address,address)":{inputs:[{internalType:"address",name:"vendorsGuardianAddress_",type:"address"},{internalType:"address",name:"governorAddress_",type:"address"},{internalType:"address",name:"pauserAddress_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{governorAddress_:"The address that will define when a change contract is authorized",pauserAddress_:"The address that is authorized to pause this contract",vendorsGuardianAddress_:"The address authorized to change a vendor's markup"},notice:"contract initializer"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setMarkup(uint256)":{inputs:[{internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"setMarkup",outputs:[],stateMutability:"nonpayable",type:"function",params:{newMarkup_:"new markup applied to vendor [PREC]"},notice:"vendor sets its own markup"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setVendorMarkup(address,uint256)":{inputs:[{internalType:"address",name:"vendorAddress_",type:"address"},{internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"setVendorMarkup",outputs:[],stateMutability:"nonpayable",type:"function",params:{newMarkup_:"new markup applied to vendor [PREC]",vendorAddress_:"vendor address to change markup"},notice:"guardian sets a vendor markup"},"setVendorsGuardianAddress(address)":{inputs:[{internalType:"address",name:"vendorsGuardianAddress_",type:"address"}],name:"setVendorsGuardianAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address which will be authorized to set a vendor markup.",params:{vendorsGuardianAddress_:"Address which will be authorized to set a vendor markup."}},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"vendorMarkup(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"vendorMarkup",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vendorsGuardianAddress()":{inputs:[],name:"vendorsGuardianAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}}};new Wn({el:"#app",router:new wu({routes:[{path:"/",component:Gu,props:()=>({json:Qu})},{path:"*",component:Lu,props:e=>({json:Qu[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(xu)})})()})();