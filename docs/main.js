/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={424:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),s=n(645),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var d=this[o][0];null!=d&&(r[d]=!0)}for(var p=0;p<e.length;p++){var u=[].concat(e[p]);a&&r[u[0]]||(void 0!==s&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=s),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),i&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=i):u[4]="".concat(i)),t.push(u))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},838:(e,t,n)=>{var a=n(424);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("20211576",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,d=0,p=!1,u=function(){},l=null,c="data-vue-ssr-id",y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){p=n,l=i||{};var r=a(e,t);return T(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(d=s[o.id]).refs--,n.push(d)}for(t?T(r=a(e,t)):r=[],i=0;i<n.length;i++){var d;if(0===(d=n[i]).refs){for(var p=0;p<d.parts.length;p++)d.parts[p]();delete s[d.id]}}}}function T(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(h(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(h(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function f(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function h(e){var t,n,a=document.querySelector("style["+c+'~="'+e.id+'"]');if(a){if(p)return u;a.parentNode.removeChild(a)}if(y){var i=d++;a=o||(o=f()),t=g.bind(null,a,i,!1),n=g.bind(null,a,i,!0)}else a=f(),t=C.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var b,v=(b=[],function(e,t){return b[e]=t,b.filter(Boolean).join("\n")});function g(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function C(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(c,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function s(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return"function"==typeof e}function d(e){return null!==e&&"object"==typeof e}var p=Object.prototype.toString;function u(e){return"[object Object]"===p.call(e)}function l(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function c(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function y(e){return null==e?"":Array.isArray(e)||u(e)&&e.toString===p?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function T(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var f=T("slot,component",!0),h=T("key,ref,slot,slot-scope,is");function b(e,t){var n=e.length;if(n){if(t===e[n-1])return void(e.length=n-1);var a=e.indexOf(t);if(a>-1)return e.splice(a,1)}}var v=Object.prototype.hasOwnProperty;function g(e,t){return v.call(e,t)}function C(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,P=C((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),_=C((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),w=/\B([A-Z])/g,A=C((function(e){return e.replace(w,"-$1").toLowerCase()})),M=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function q(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function x(e,t){for(var n in t)e[n]=t[n];return e}function F(e){for(var t={},n=0;n<e.length;n++)e[n]&&x(t,e[n]);return t}function R(e,t,n){}var E=function(e,t,n){return!1},I=function(e){return e};function S(e,t){if(e===t)return!0;var n=d(e),a=d(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return S(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return S(e[n],t[n])}))}catch(e){return!1}}function O(e,t){for(var n=0;n<e.length;n++)if(S(e[n],t))return n;return-1}function V(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}function B(e,t){return e===t?0===e&&1/e!=1/t:e==e||t==t}var U="data-server-rendered",D=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:E,isReservedAttr:E,isUnknownElement:E,getTagNamespace:R,parsePlatformTagName:I,mustUseProp:E,async:!0,_lifecycleHooks:$},L=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function z(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function j(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(L.source,".$_\\d]")),Q="__proto__"in{},H="undefined"!=typeof window,W=H&&window.navigator.userAgent.toLowerCase(),K=W&&/msie|trident/.test(W),J=W&&W.indexOf("msie 9.0")>0,Z=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var X=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var Y,ee=W&&W.match(/firefox\/(\d+)/),te={}.watch,ne=!1;if(H)try{var ae={};Object.defineProperty(ae,"passive",{get:function(){ne=!0}}),window.addEventListener("test-passive",null,ae)}catch(e){}var ie=function(){return void 0===Y&&(Y=!H&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),Y},se=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return"function"==typeof e&&/native code/.test(e.toString())}var oe,de="undefined"!=typeof Symbol&&re(Symbol)&&"undefined"!=typeof Reflect&&re(Reflect.ownKeys);oe="undefined"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var pe=null;function ue(e){void 0===e&&(e=null),e||pe&&pe._scope.off(),pe=e,e&&e._scope.on()}var le=function(){function e(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),ce=function(e){void 0===e&&(e="");var t=new le;return t.text=e,t.isComment=!0,t};function ye(e){return new le(void 0,void 0,void 0,String(e))}function me(e){var t=new le(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var Te=0,fe=[],he=function(){function e(){this._pending=!1,this.id=Te++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,fe.push(this))},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.filter((function(e){return e})),n=0,a=t.length;n<a;n++)t[n].update()},e}();he.target=null;var be=[];function ve(e){be.push(e),he.target=e}function ge(){be.pop(),he.target=be[be.length-1]}var Ce=Array.prototype,ke=Object.create(Ce);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=Ce[e];j(ke,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var Pe=new WeakMap;function _e(e){return function(e,t){we(e)||Ee(e,t,ie())}(e,!0),j(e,"__v_isShallow",!0),e}function we(e){return!(!e||!e.__v_isReadonly)}var Ae=Object.getOwnPropertyNames(ke),Me={},qe=!0;function xe(e){qe=e}var Fe={notify:R,depend:R,addSub:R,removeSub:R},Re=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?Fe:new he,this.vmCount=0,j(e,"__ob__",this),t(e)){if(!a)if(Q)e.__proto__=ke;else for(var i=0,s=Ae.length;i<s;i++)j(e,o=Ae[i],ke[o]);n||this.observeArray(e)}else{var r=Object.keys(e);for(i=0;i<r.length;i++){var o;Ie(e,o=r[i],Me,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Ee(e[t],!1,this.mock)},e}();function Ee(e,n,a){return e&&g(e,"__ob__")&&e.__ob__ instanceof Re?e.__ob__:!qe||!a&&ie()||!t(e)&&!u(e)||!Object.isExtensible(e)||e.__v_skip||Pe.has(e)||Be(e)||e instanceof le?void 0:new Re(e,n,a)}function Ie(e,n,a,i,s,r){var o=new he,d=Object.getOwnPropertyDescriptor(e,n);if(!d||!1!==d.configurable){var p=d&&d.get,u=d&&d.set;p&&!u||a!==Me&&2!==arguments.length||(a=e[n]);var l=!s&&Ee(a,!1,r);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=p?p.call(e):a;return he.target&&(o.depend(),l&&(l.dep.depend(),t(n)&&Ve(n))),Be(n)&&!s?n.value:n},set:function(t){var n=p?p.call(e):a;if(B(n,t)){if(u)u.call(e,t);else{if(p)return;if(!s&&Be(n)&&!Be(t))return void(n.value=t);a=t}l=!s&&Ee(t,!1,r),o.notify()}}}),o}}function Se(e,n,a){if(!we(e)){var i=e.__ob__;return t(e)&&l(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&Ee(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(Ie(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Oe(e,n){if(t(e)&&l(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||we(e)||g(e,n)&&(delete e[n],a&&a.dep.notify())}}function Ve(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Ve(n)}function Be(e){return!(!e||!0!==e.__v_isRef)}function Ue(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(Be(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];Be(a)&&!Be(e)?a.value=e:t[n]=e}})}new WeakMap,new WeakMap;var De=C((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function $e(e,n){function a(){var e=a.fns;if(!t(e))return Wt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),s=0;s<i.length;s++)Wt(i[s],null,arguments,n,"v-on handler")}return a.fns=e,a}function Ne(e,t,n,i,r,o){var d,p,u,l;for(d in e)p=e[d],u=t[d],l=De(d),a(p)||(a(u)?(a(p.fns)&&(p=e[d]=$e(p,o)),s(l.once)&&(p=e[d]=r(l.name,p,l.capture)),n(l.name,p,l.capture,l.passive,l.params)):p!==u&&(u.fns=p,e[d]=u));for(d in t)a(e[d])&&i((l=De(d)).name,t[d],l.capture)}function Le(e,t,n){var r;e instanceof le&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function d(){n.apply(this,arguments),b(r.fns,d)}a(o)?r=$e([d]):i(o.fns)&&s(o.merged)?(r=o).fns.push(d):r=$e([o,d]),r.merged=!0,e[t]=r}function ze(e,t,n,a,s){if(i(t)){if(g(t,n))return e[n]=t[n],s||delete t[n],!0;if(g(t,a))return e[n]=t[a],s||delete t[a],!0}return!1}function je(e){return r(e)?[ye(e)]:t(e)?Qe(e):void 0}function Ge(e){return i(e)&&i(e.text)&&!1===e.isComment}function Qe(e,n){var o,d,p,u,l=[];for(o=0;o<e.length;o++)a(d=e[o])||"boolean"==typeof d||(u=l[p=l.length-1],t(d)?d.length>0&&(Ge((d=Qe(d,"".concat(n||"","_").concat(o)))[0])&&Ge(u)&&(l[p]=ye(u.text+d[0].text),d.shift()),l.push.apply(l,d)):r(d)?Ge(u)?l[p]=ye(u.text+d):""!==d&&l.push(ye(d)):Ge(d)&&Ge(u)?l[p]=ye(u.text+d.text):(s(e._isVList)&&i(d.tag)&&a(d.key)&&i(n)&&(d.key="__vlist".concat(n,"_").concat(o,"__")),l.push(d)));return l}function He(e,n,a,p,u,l){return(t(a)||r(a))&&(u=p,p=a,a=void 0),s(l)&&(u=2),function(e,n,a,s,r){if(i(a)&&i(a.__ob__))return ce();if(i(a)&&i(a.is)&&(n=a.is),!n)return ce();var p,u;if(t(s)&&o(s[0])&&((a=a||{}).scopedSlots={default:s[0]},s.length=0),2===r?s=je(s):1===r&&(s=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof n){var l=void 0;u=e.$vnode&&e.$vnode.ns||N.getTagNamespace(n),p=N.isReservedTag(n)?new le(N.parsePlatformTagName(n),a,s,void 0,void 0,e):a&&a.pre||!i(l=Nn(e.$options,"components",n))?new le(n,a,s,void 0,void 0,e):Rn(l,a,e,s,n)}else p=Rn(n,a,e,s);return t(p)?p:i(p)?(i(u)&&We(p,u),i(a)&&function(e){d(e.style)&&un(e.style),d(e.class)&&un(e.class)}(a),p):ce()}(e,n,a,p,u)}function We(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var r=0,o=e.children.length;r<o;r++){var d=e.children[r];i(d.tag)&&(a(d.ns)||s(n)&&"svg"!==d.tag)&&We(d,t,n)}}function Ke(e,n){var a,s,r,o,p=null;if(t(e)||"string"==typeof e)for(p=new Array(e.length),a=0,s=e.length;a<s;a++)p[a]=n(e[a],a);else if("number"==typeof e)for(p=new Array(e),a=0;a<e;a++)p[a]=n(a+1,a);else if(d(e))if(de&&e[Symbol.iterator]){p=[];for(var u=e[Symbol.iterator](),l=u.next();!l.done;)p.push(n(l.value,p.length)),l=u.next()}else for(r=Object.keys(e),p=new Array(r.length),a=0,s=r.length;a<s;a++)o=r[a],p[a]=n(e[o],o,a);return i(p)||(p=[]),p._isVList=!0,p}function Je(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=x(x({},a),n)),i=s(n)||(o(t)?t():t)):i=this.$slots[e]||(o(t)?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function Ze(e){return Nn(this.$options,"filters",e)||I}function Xe(e,n){return t(e)?-1===e.indexOf(n):e!==n}function Ye(e,t,n,a,i){var s=N.keyCodes[t]||n;return i&&a&&!N.keyCodes[t]?Xe(i,a):s?Xe(s,e):a?A(a)!==t:void 0===e}function et(e,n,a,i,s){if(a&&d(a)){t(a)&&(a=F(a));var r=void 0,o=function(t){if("class"===t||"style"===t||h(t))r=e;else{var o=e.attrs&&e.attrs.type;r=i||N.mustUseProp(n,o,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var d=P(t),p=A(t);d in r||p in r||(r[t]=a[t],s&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var p in a)o(p)}return e}function tt(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||at(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function nt(e,t,n){return at(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function at(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&it(e[i],"".concat(n,"_").concat(i),a);else it(e,n,a)}function it(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function st(e,t){if(t&&u(t)){var n=e.on=e.on?x({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function rt(e,n,a,i){n=n||{$stable:!a};for(var s=0;s<e.length;s++){var r=e[s];t(r)?rt(r,n,a):r&&(r.proxy&&(r.fn.proxy=!0),n[r.key]=r.fn)}return i&&(n.$key=i),n}function ot(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function dt(e,t){return"string"==typeof e?t+e:e}function pt(e){e._o=nt,e._n=m,e._s=y,e._l=Ke,e._t=Je,e._q=S,e._i=O,e._m=tt,e._f=Ze,e._k=Ye,e._b=et,e._v=ye,e._e=ce,e._u=rt,e._g=st,e._d=ot,e._p=dt}function ut(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,d=n[o]||(n[o]=[]);"template"===s.tag?d.push.apply(d,s.children||[]):d.push(s)}}for(var p in n)n[p].every(lt)&&delete n[p];return n}function lt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function ct(e){return e.isComment&&e.asyncFactory}function yt(t,n,a,i){var s,r=Object.keys(a).length>0,o=n?!!n.$stable:!r,d=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&i&&i!==e&&d===i.$key&&!r&&!i.$hasNormal)return i;for(var p in s={},n)n[p]&&"$"!==p[0]&&(s[p]=mt(t,a,p,n[p]))}else s={};for(var u in a)u in s||(s[u]=Tt(a,u));return n&&Object.isExtensible(n)&&(n._normalized=s),j(s,"$stable",o),j(s,"$key",d),j(s,"$hasNormal",r),s}function mt(e,n,a,i){var s=function(){var n=pe;ue(e);var a=arguments.length?i.apply(null,arguments):i({}),s=(a=a&&"object"==typeof a&&!t(a)?[a]:je(a))&&a[0];return ue(n),a&&(!s||1===a.length&&s.isComment&&!ct(s))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:s,enumerable:!0,configurable:!0}),s}function Tt(e,t){return function(){return e[t]}}function ft(e,t,n,a,i){var s=!1;for(var r in t)r in e?t[r]!==n[r]&&(s=!0):(s=!0,ht(e,r,a,i));for(var r in e)r in t||(s=!0,delete e[r]);return s}function ht(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function bt(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var vt,gt=null;function Ct(e,t){return(e.__esModule||de&&"Module"===e[Symbol.toStringTag])&&(e=e.default),d(e)?t.extend(e):e}function kt(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||ct(a)))return a}}function Pt(e,t){vt.$on(e,t)}function _t(e,t){vt.$off(e,t)}function wt(e,t){var n=vt;return function a(){var i=t.apply(null,arguments);null!==i&&n.$off(e,a)}}function At(e,t,n){vt=e,Ne(t,n||{},Pt,_t,wt,e),vt=void 0}var Mt=null;function qt(e){var t=Mt;return Mt=e,function(){Mt=t}}function xt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function Ft(e,t){if(t){if(e._directInactive=!1,xt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)Ft(e.$children[n]);Et(e,"activated")}}function Rt(e,t){if(!(t&&(e._directInactive=!0,xt(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)Rt(e.$children[n]);Et(e,"deactivated")}}function Et(e,t,n,a){void 0===a&&(a=!0),ve();var i=pe;a&&ue(e);var s=e.$options[t],r="".concat(t," hook");if(s)for(var o=0,d=s.length;o<d;o++)Wt(s[o],e,n||null,e,r);e._hasHookEvent&&e.$emit("hook:"+t),a&&ue(i),ge()}var It=[],St=[],Ot={},Vt=!1,Bt=!1,Ut=0,Dt=0,$t=Date.now;if(H&&!K){var Nt=window.performance;Nt&&"function"==typeof Nt.now&&$t()>document.createEvent("Event").timeStamp&&($t=function(){return Nt.now()})}var Lt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function zt(){var e,t;for(Dt=$t(),Bt=!0,It.sort(Lt),Ut=0;Ut<It.length;Ut++)(e=It[Ut]).before&&e.before(),t=e.id,Ot[t]=null,e.run();var n=St.slice(),a=It.slice();Ut=It.length=St.length=0,Ot={},Vt=Bt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,Ft(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&Et(a,"updated")}}(a),function(){for(var e=0;e<fe.length;e++){var t=fe[e];t.subs=t.subs.filter((function(e){return e})),t._pending=!1}fe.length=0}(),se&&N.devtools&&se.emit("flush")}var jt,Gt="watcher";"".concat(Gt," callback"),"".concat(Gt," getter"),"".concat(Gt," cleanup");var Qt=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=jt,!e&&jt&&(this.index=(jt.scopes||(jt.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=jt;try{return jt=this,e()}finally{jt=t}}},e.prototype.on=function(){jt=this},e.prototype.off=function(){jt=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},e}();function Ht(e,t,n){ve();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Kt(e,a,"errorCaptured hook")}}Kt(e,t,n)}finally{ge()}}function Wt(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&c(s)&&!s._handled&&(s.catch((function(e){return Ht(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){Ht(e,a,i)}return s}function Kt(e,t,n){if(N.errorHandler)try{return N.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Jt(t)}Jt(e)}function Jt(e,t,n){if(!H||"undefined"==typeof console)throw e;console.error(e)}var Zt,Xt=!1,Yt=[],en=!1;function tn(){en=!1;var e=Yt.slice(0);Yt.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&re(Promise)){var nn=Promise.resolve();Zt=function(){nn.then(tn),X&&setTimeout(R)},Xt=!0}else if(K||"undefined"==typeof MutationObserver||!re(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Zt="undefined"!=typeof setImmediate&&re(setImmediate)?function(){setImmediate(tn)}:function(){setTimeout(tn,0)};else{var an=1,sn=new MutationObserver(tn),rn=document.createTextNode(String(an));sn.observe(rn,{characterData:!0}),Zt=function(){an=(an+1)%2,rn.data=String(an)},Xt=!0}function on(e,t){var n;if(Yt.push((function(){if(e)try{e.call(t)}catch(e){Ht(e,t,"nextTick")}else n&&n(t)})),en||(en=!0,Zt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function dn(e){return function(t,n){if(void 0===n&&(n=pe),n)return function(e,t,n){var a=e.$options;a[t]=Bn(a[t],n)}(n,e,t)}}dn("beforeMount"),dn("mounted"),dn("beforeUpdate"),dn("updated"),dn("beforeDestroy"),dn("destroyed"),dn("activated"),dn("deactivated"),dn("serverPrefetch"),dn("renderTracked"),dn("renderTriggered"),dn("errorCaptured");var pn=new oe;function un(e){return ln(e,pn),pn.clear(),e}function ln(e,n){var a,i,s=t(e);if(!(!s&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof le)){if(e.__ob__){var r=e.__ob__.dep.id;if(n.has(r))return;n.add(r)}if(s)for(a=e.length;a--;)ln(e[a],n);else if(Be(e))ln(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)ln(e[i[a]],n)}}var cn=0,yn=function(){function e(e,t,n,a,i){var s;void 0===(s=jt&&!jt._vm?jt:e?e._scope:void 0)&&(s=jt),s&&s.active&&s.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++cn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new oe,this.newDepIds=new oe,this.expression="",o(t)?this.getter=t:(this.getter=function(e){if(!G.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=R)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;ve(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Ht(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&un(e),ge(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==Ot[t]&&(e!==he.target||!e.noRecurse)){if(Ot[t]=!0,Bt){for(var n=It.length-1;n>Ut&&It[n].id>e.id;)n--;It.splice(n+1,0,e)}else It.push(e);Vt||(Vt=!0,on(zt))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||d(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Wt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&b(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),mn={enumerable:!0,configurable:!0,get:R,set:R};function Tn(e,t,n){mn.get=function(){return this[t][n]},mn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,mn)}function fn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=_e({}),i=e.$options._propKeys=[];e.$parent&&xe(!1);var s=function(s){i.push(s);var r=Ln(s,t,n,e);Ie(a,s,r),s in e||Tn(e,"_props",s)};for(var r in t)s(r);xe(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};j(n,"_v_attr_proxy",!0),ft(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||ft(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||bt(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:M(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return Ue(t,e,n)}))}}}(t);ue(t),ve();var s=Wt(a,null,[t._props||_e({}),i],t,"setup");if(ge(),ue(),o(s))n.render=s;else if(d(s))if(t._setupState=s,s.__sfc){var r=t._setupProxy={};for(var p in s)"__sfc"!==p&&Ue(r,s,p)}else for(var p in s)z(p)||Ue(t,s,p)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?R:M(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;u(t=e._data=o(t)?function(e,t){ve();try{return e.call(t,t)}catch(e){return Ht(e,t,"data()"),{}}finally{ge()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&g(a,s)||z(s)||Tn(e,"_data",s)}var r=Ee(t);r&&r.vmCount++}(n);else{var i=Ee(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ie();for(var i in t){var s=t[i],r=o(s)?s:s.get;a||(n[i]=new yn(e,r||R,R,hn)),i in e||bn(e,i,s)}}(n,a.computed),a.watch&&a.watch!==te&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var s=0;s<i.length;s++)Cn(e,a,i[s]);else Cn(e,a,i)}}(n,a.watch)}var hn={lazy:!0};function bn(e,t,n){var a=!ie();o(n)?(mn.get=a?vn(t):gn(n),mn.set=R):(mn.get=n.get?a&&!1!==n.cache?vn(t):gn(n.get):R,mn.set=n.set||R),Object.defineProperty(e,t,mn)}function vn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),he.target&&t.depend(),t.value}}function gn(e){return function(){return e.call(this,this)}}function Cn(e,t,n,a){return u(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function kn(e,t){if(e){for(var n=Object.create(null),a=de?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){var r=e[s].from;if(r in t._provided)n[s]=t._provided[r];else if("default"in e[s]){var d=e[s].default;n[s]=o(d)?d.call(t):d}}}return n}}var Pn=0;function _n(e){var t=e.options;if(e.super){var n=_n(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&x(e.extendOptions,a),(t=e.options=$n(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function wn(n,a,i,r,o){var d,p=this,u=o.options;g(r,"_uid")?(d=Object.create(r))._original=r:(d=r,r=r._original);var l=s(u._compiled),c=!l;this.data=n,this.props=a,this.children=i,this.parent=r,this.listeners=n.on||e,this.injections=kn(u.inject,r),this.slots=function(){return p.$slots||yt(r,n.scopedSlots,p.$slots=ut(i,r)),p.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return yt(r,n.scopedSlots,this.slots())}}),l&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=yt(r,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(e,n,a,i){var s=He(d,e,n,a,i,c);return s&&!t(s)&&(s.fnScopeId=u._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return He(d,e,t,n,a,c)}}function An(e,t,n,a,i){var s=me(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Mn(e,t){for(var n in t)e[P(n)]=t[n]}function qn(e){return e.name||e.__name||e._componentTag}pt(wn.prototype);var xn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;xn.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,Mt)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,s){var r=i.data.scopedSlots,o=t.$scopedSlots,d=!!(r&&!r.$stable||o!==e&&!o.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),p=!!(s||t.$options._renderChildren||d),u=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=s;var l=i.data.attrs||e;t._attrsProxy&&ft(t._attrsProxy,l,u.data&&u.data.attrs||e,t,"$attrs")&&(p=!0),t.$attrs=l,a=a||e;var c=t.$options._parentListeners;if(t._listenersProxy&&ft(t._listenersProxy,a,c||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,At(t,a,c),n&&t.$options.props){xe(!1);for(var y=t._props,m=t.$options._propKeys||[],T=0;T<m.length;T++){var f=m[T],h=t.$options.props;y[f]=Ln(f,h,n,t)}xe(!0),t.$options.propsData=n}p&&(t.$slots=ut(s,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,Et(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,St.push(t)):Ft(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?Rt(t,!0):t.$destroy())}},Fn=Object.keys(xn);function Rn(n,r,o,p,u){if(!a(n)){var l=o.$options._base;if(d(n)&&(n=l.extend(n)),"function"==typeof n){var y;if(a(n.cid)&&(n=function(e,t){if(s(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=gt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),s(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var r=e.owners=[n],o=!0,p=null,u=null;n.$on("hook:destroyed",(function(){return b(r,n)}));var l=function(e){for(var t=0,n=r.length;t<n;t++)r[t].$forceUpdate();e&&(r.length=0,null!==p&&(clearTimeout(p),p=null),null!==u&&(clearTimeout(u),u=null))},y=V((function(n){e.resolved=Ct(n,t),o?r.length=0:l(!0)})),m=V((function(t){i(e.errorComp)&&(e.error=!0,l(!0))})),T=e(y,m);return d(T)&&(c(T)?a(e.resolved)&&T.then(y,m):c(T.component)&&(T.component.then(y,m),i(T.error)&&(e.errorComp=Ct(T.error,t)),i(T.loading)&&(e.loadingComp=Ct(T.loading,t),0===T.delay?e.loading=!0:p=setTimeout((function(){p=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,l(!1))}),T.delay||200)),i(T.timeout)&&(u=setTimeout((function(){u=null,a(e.resolved)&&m(null)}),T.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(y=n,l),void 0===n))return function(e,t,n,a,i){var s=ce();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(y,r,o,p,u);r=r||{},_n(n),i(r.model)&&function(e,n){var a=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var r=n.on||(n.on={}),o=r[s],d=n.model.callback;i(o)?(t(o)?-1===o.indexOf(d):o!==d)&&(r[s]=[d].concat(o)):r[s]=d}(n.options,r);var m=function(e,t,n){var s=t.options.props;if(!a(s)){var r={},o=e.attrs,d=e.props;if(i(o)||i(d))for(var p in s){var u=A(p);ze(r,d,p,u,!0)||ze(r,o,p,u,!1)}return r}}(r,n);if(s(n.options.functional))return function(n,a,s,r,o){var d=n.options,p={},u=d.props;if(i(u))for(var l in u)p[l]=Ln(l,u,a||e);else i(s.attrs)&&Mn(p,s.attrs),i(s.props)&&Mn(p,s.props);var c=new wn(s,p,o,r,n),y=d.render.call(null,c._c,c);if(y instanceof le)return An(y,s,c.parent,d);if(t(y)){for(var m=je(y)||[],T=new Array(m.length),f=0;f<m.length;f++)T[f]=An(m[f],s,c.parent,d);return T}}(n,m,r,o,p);var T=r.on;if(r.on=r.nativeOn,s(n.options.abstract)){var f=r.slot;r={},f&&(r.slot=f)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<Fn.length;n++){var a=Fn[n],i=t[a],s=xn[a];i===s||i&&i._merged||(t[a]=i?En(s,i):s)}}(r);var h=qn(n.options)||u;return new le("vue-component-".concat(n.cid).concat(h?"-".concat(h):""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:m,listeners:T,tag:u,children:p},y)}}}function En(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var In=R,Sn=N.optionMergeStrategies;function On(e,t){if(!t)return e;for(var n,a,i,s=de?Reflect.ownKeys(t):Object.keys(t),r=0;r<s.length;r++)"__ob__"!==(n=s[r])&&(a=e[n],i=t[n],g(e,n)?a!==i&&u(a)&&u(i)&&On(a,i):Se(e,n,i));return e}function Vn(e,t,n){return n?function(){var a=o(t)?t.call(n,n):t,i=o(e)?e.call(n,n):e;return a?On(a,i):i}:t?e?function(){return On(o(t)?t.call(this,this):t,o(e)?e.call(this,this):e)}:t:e}function Bn(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function Un(e,t,n,a){var i=Object.create(e||null);return t?x(i,t):i}Sn.data=function(e,t,n){return n?Vn(e,t,n):t&&"function"!=typeof t?e:Vn(e,t)},$.forEach((function(e){Sn[e]=Bn})),D.forEach((function(e){Sn[e+"s"]=Un})),Sn.watch=function(e,n,a,i){if(e===te&&(e=void 0),n===te&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var s={};for(var r in x(s,e),n){var o=s[r],d=n[r];o&&!t(o)&&(o=[o]),s[r]=o?o.concat(d):t(d)?d:[d]}return s},Sn.props=Sn.methods=Sn.inject=Sn.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return x(i,e),t&&x(i,t),i},Sn.provide=Vn;var Dn=function(e,t){return void 0===t?e:t};function $n(e,n,a){if(o(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,s,r={};if(t(a))for(i=a.length;i--;)"string"==typeof(s=a[i])&&(r[P(s)]={type:null});else if(u(a))for(var o in a)s=a[o],r[P(o)]=u(s)?s:{type:s};e.props=r}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var s=0;s<a.length;s++)i[a[s]]={from:a[s]};else if(u(a))for(var r in a){var o=a[r];i[r]=u(o)?x({from:r},o):{from:o}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];o(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=$n(e,n.extends,a)),n.mixins))for(var i=0,s=n.mixins.length;i<s;i++)e=$n(e,n.mixins[i],a);var r,d={};for(r in e)p(r);for(r in n)g(e,r)||p(r);function p(t){var i=Sn[t]||Dn;d[t]=i(e[t],n[t],a,t)}return d}function Nn(e,t,n,a){if("string"==typeof n){var i=e[t];if(g(i,n))return i[n];var s=P(n);if(g(i,s))return i[s];var r=_(s);return g(i,r)?i[r]:i[n]||i[s]||i[r]}}function Ln(e,t,n,a){var i=t[e],s=!g(n,e),r=n[e],d=Qn(Boolean,i.type);if(d>-1)if(s&&!g(i,"default"))r=!1;else if(""===r||r===A(e)){var p=Qn(String,i.type);(p<0||d<p)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(g(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:o(a)&&"Function"!==jn(t.type)?a.call(e):a}}(a,i,e);var u=qe;xe(!0),Ee(r),xe(u)}return r}var zn=/^\s*function (\w+)/;function jn(e){var t=e&&e.toString().match(zn);return t?t[1]:""}function Gn(e,t){return jn(e)===jn(t)}function Qn(e,n){if(!t(n))return Gn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Gn(n[a],e))return a;return-1}function Hn(e){this._init(e)}function Wn(e){return e&&(qn(e.Ctor.options)||e.tag)}function Kn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==p.call(a))&&e.test(n));var a}function Jn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var r=n[s];if(r){var o=r.name;o&&!t(o)&&Zn(n,s,a,i)}}}function Zn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,b(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=Pn++,n._isVue=!0,n.__v_skip=!0,n._scope=new Qt(!0),n._scope._vm=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=$n(_n(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&At(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=ut(n._renderChildren,i),t.$scopedSlots=a?yt(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return He(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return He(t,e,n,a,i,!0)};var s=a&&a.data;Ie(t,"$attrs",s&&s.attrs||e,null,!0),Ie(t,"$listeners",n._parentListeners||e,null,!0)}(n),Et(n,"beforeCreate",void 0,!1),function(e){var t=kn(e.$options.inject,e);t&&(xe(!1),Object.keys(t).forEach((function(n){Ie(e,n,t[n])})),xe(!0))}(n),fn(n),function(e){var t=e.$options.provide;if(t){var n=o(t)?t.call(e):t;if(!d(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=de?Reflect.ownKeys(n):Object.keys(n),s=0;s<i.length;s++){var r=i[s];Object.defineProperty(a,r,Object.getOwnPropertyDescriptor(n,r))}}}(n),Et(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Hn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Se,e.prototype.$delete=Oe,e.prototype.$watch=function(e,t,n){var a=this;if(u(t))return Cn(a,e,t,n);(n=n||{}).user=!0;var i=new yn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'.concat(i.expression,'"');ve(),Wt(t,a,[i.value],a,s),ge()}return function(){i.teardown()}}}(Hn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var s=0,r=e.length;s<r;s++)i.$on(e[s],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,s=e.length;i<s;i++)a.$off(e[i],n);return a}var r,o=a._events[e];if(!o)return a;if(!n)return a._events[e]=null,a;for(var d=o.length;d--;)if((r=o[d])===n||r.fn===n){o.splice(d,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?q(n):n;for(var a=q(arguments,1),i='event handler for "'.concat(e,'"'),s=0,r=n.length;s<r;s++)Wt(n[s],t,a,t,i)}return t}}(Hn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=qt(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var r=n;r&&r.$vnode&&r.$parent&&r.$vnode===r.$parent._vnode;)r.$parent.$el=r.$el,r=r.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Et(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||b(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Et(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Hn),function(e){pt(e.prototype),e.prototype.$nextTick=function(e){return on(e,this)},e.prototype._render=function(){var e,n=this,a=n.$options,i=a.render,s=a._parentVnode;s&&n._isMounted&&(n.$scopedSlots=yt(n.$parent,s.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&bt(n._slotsProxy,n.$scopedSlots)),n.$vnode=s;try{ue(n),gt=n,e=i.call(n._renderProxy,n.$createElement)}catch(t){Ht(t,n,"render"),e=n._vnode}finally{gt=null,ue()}return t(e)&&1===e.length&&(e=e[0]),e instanceof le||(e=ce()),e.parent=s,e}}(Hn);var Xn=[String,RegExp,Array],Yn={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xn,exclude:Xn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:Wn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&Zn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Zn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Jn(e,(function(e){return Kn(t,e)}))})),this.$watch("exclude",(function(t){Jn(e,(function(e){return!Kn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=kt(e),n=t&&t.componentOptions;if(n){var a=Wn(n),i=this.include,s=this.exclude;if(i&&(!a||!Kn(i,a))||s&&a&&Kn(s,a))return t;var r=this.cache,o=this.keys,d=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;r[d]?(t.componentInstance=r[d].componentInstance,b(o,d),o.push(d)):(this.vnodeToCache=t,this.keyToCache=d),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return N}};Object.defineProperty(e,"config",t),e.util={warn:In,extend:x,mergeOptions:$n,defineReactive:Ie},e.set=Se,e.delete=Oe,e.nextTick=on,e.observable=function(e){return Ee(e),e},e.options=Object.create(null),D.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,x(e.options.components,Yn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=q(arguments,1);return n.unshift(this),o(e.install)?e.install.apply(e,n):o(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=$n(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=qn(e)||qn(n.options),r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=$n(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)Tn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)bn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,D.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=x({},r.options),i[a]=r,r}}(e),function(e){D.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&u(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&o(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Hn),Object.defineProperty(Hn.prototype,"$isServer",{get:ie}),Object.defineProperty(Hn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Hn,"FunctionalRenderContext",{value:wn}),Hn.version="2.7.13";var ea=T("style,class"),ta=T("input,textarea,option,select,progress"),na=function(e,t,n){return"value"===n&&ta(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},aa=T("contenteditable,draggable,spellcheck"),ia=T("events,caret,typing,plaintext-only"),sa=T("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ra="http://www.w3.org/1999/xlink",oa=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},da=function(e){return oa(e)?e.slice(6,e.length):""},pa=function(e){return null==e||!1===e};function ua(e,t){return{staticClass:la(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function la(e,t){return e?t?e+" "+t:e:t||""}function ca(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,s=e.length;a<s;a++)i(t=ca(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):d(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var ya={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ma=T("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Ta=T("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fa=function(e){return ma(e)||Ta(e)};function ha(e){return Ta(e)?"svg":"math"===e?"math":void 0}var ba=Object.create(null),va=T("text,number,password,search,email,tel,url");function ga(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var Ca=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(ya[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),ka={create:function(e,t){Pa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(Pa(e,!0),Pa(t))},destroy:function(e){Pa(e,!0)}};function Pa(e,n){var a=e.data.ref;if(i(a)){var s=e.context,r=e.componentInstance||e.elm,d=n?null:r,p=n?void 0:r;if(o(a))Wt(a,s,[d],s,"template ref function");else{var u=e.data.refInFor,l="string"==typeof a||"number"==typeof a,c=Be(a),y=s.$refs;if(l||c)if(u){var m=l?y[a]:a.value;n?t(m)&&b(m,r):t(m)?m.includes(r)||m.push(r):l?(y[a]=[r],_a(s,a,y[a])):a.value=[r]}else if(l){if(n&&y[a]!==r)return;y[a]=p,_a(s,a,d)}else if(c){if(n&&a.value!==r)return;a.value=d}}}}function _a(e,t,n){var a=e._setupState;a&&g(a,t)&&(Be(a[t])?a[t].value=n:a[t]=n)}var wa=new le("",{},[]),Aa=["create","activate","update","remove","destroy"];function Ma(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,s=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===s||va(a)&&va(s)}(e,t)||s(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function qa(e,t,n){var a,s,r={};for(a=t;a<=n;++a)i(s=e[a].key)&&(r[s]=a);return r}var xa={create:Fa,update:Fa,destroy:function(e){Fa(e,wa)}};function Fa(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===wa,r=t===wa,o=Ea(e.data.directives,e.context),d=Ea(t.data.directives,t.context),p=[],u=[];for(n in d)a=o[n],i=d[n],a?(i.oldValue=a.value,i.oldArg=a.arg,Sa(i,"update",t,e),i.def&&i.def.componentUpdated&&u.push(i)):(Sa(i,"bind",t,e),i.def&&i.def.inserted&&p.push(i));if(p.length){var l=function(){for(var n=0;n<p.length;n++)Sa(p[n],"inserted",t,e)};s?Le(t,"insert",l):l()}if(u.length&&Le(t,"postpatch",(function(){for(var n=0;n<u.length;n++)Sa(u[n],"componentUpdated",t,e)})),!s)for(n in o)d[n]||Sa(o[n],"unbind",e,e,r)}(e,t)}var Ra=Object.create(null);function Ea(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Ra),i[Ia(a)]=a,t._setupState&&t._setupState.__sfc){var s=a.def||Nn(t,"_setupState","v-"+a.name);a.def="function"==typeof s?{bind:s,update:s}:s}a.def=a.def||Nn(t.$options,"directives",a.name)}return i}function Ia(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Sa(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){Ht(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Oa=[ka,xa];function Va(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var r,o,d=t.elm,p=e.data.attrs||{},u=t.data.attrs||{};for(r in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=t.data.attrs=x({},u)),u)o=u[r],p[r]!==o&&Ba(d,r,o,t.data.pre);for(r in(K||Z)&&u.value!==p.value&&Ba(d,"value",u.value),p)a(u[r])&&(oa(r)?d.removeAttributeNS(ra,da(r)):aa(r)||d.removeAttribute(r))}}function Ba(e,t,n,a){a||e.tagName.indexOf("-")>-1?Ua(e,t,n):sa(t)?pa(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):aa(t)?e.setAttribute(t,function(e,t){return pa(t)||"false"===t?"false":"contenteditable"===e&&ia(t)?t:"true"}(t,n)):oa(t)?pa(n)?e.removeAttributeNS(ra,da(t)):e.setAttributeNS(ra,t,n):Ua(e,t,n)}function Ua(e,t,n){if(pa(n))e.removeAttribute(t);else{if(K&&!J&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var Da={create:Va,update:Va};function $a(e,t){var n=t.elm,s=t.data,r=e.data;if(!(a(s.staticClass)&&a(s.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ua(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=ua(t,n.data));return s=t.staticClass,r=t.class,i(s)||i(r)?la(s,ca(r)):"";var s,r}(t),d=n._transitionClasses;i(d)&&(o=la(o,ca(d))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Na,La,za,ja,Ga,Qa,Ha={create:$a,update:$a},Wa=/[\w).+\-_$\]]/;function Ka(e){var t,n,a,i,s,r=!1,o=!1,d=!1,p=!1,u=0,l=0,c=0,y=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(d)96===t&&92!==n&&(d=!1);else if(p)47===t&&92!==n&&(p=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||u||l||c){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:d=!0;break;case 40:c++;break;case 41:c--;break;case 91:l++;break;case 93:l--;break;case 123:u++;break;case 125:u--}if(47===t){for(var m=a-1,T=void 0;m>=0&&" "===(T=e.charAt(m));m--);T&&Wa.test(T)||(p=!0)}}else void 0===i?(y=a+1,i=e.slice(0,a).trim()):f();function f(){(s||(s=[])).push(e.slice(y,a).trim()),y=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==y&&f(),s)for(a=0;a<s.length;a++)i=Ja(i,s[a]);return i}function Ja(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function Za(e,t){console.error("[Vue compiler]: ".concat(e))}function Xa(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Ya(e,t,n,a,i){(e.props||(e.props=[])).push(di({name:t,value:n,dynamic:i},a)),e.plain=!1}function ei(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(di({name:t,value:n,dynamic:i},a)),e.plain=!1}function ti(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(di({name:t,value:n},a))}function ni(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push(di({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function ai(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function ii(t,n,a,i,s,r,o,d){var p;(i=i||e).right?d?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(d?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=ai("!",n,d)),i.once&&(delete i.once,n=ai("~",n,d)),i.passive&&(delete i.passive,n=ai("&",n,d)),i.native?(delete i.native,p=t.nativeEvents||(t.nativeEvents={})):p=t.events||(t.events={});var u=di({value:a.trim(),dynamic:d},o);i!==e&&(u.modifiers=i);var l=p[n];Array.isArray(l)?s?l.unshift(u):l.push(u):p[n]=l?s?[u,l]:[l,u]:u,t.plain=!1}function si(e,t,n){var a=ri(e,":"+t)||ri(e,"v-bind:"+t);if(null!=a)return Ka(a);if(!1!==n){var i=ri(e,t);if(null!=i)return JSON.stringify(i)}}function ri(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function oi(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function di(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function pi(e,t,n){var a=n||{},i=a.number,s="$$v",r=s;a.trim&&(r="(typeof ".concat(s," === 'string'")+"? ".concat(s,".trim()")+": ".concat(s,")")),i&&(r="_n(".concat(r,")"));var o=ui(t,r);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(s,") {").concat(o,"}")}}function ui(e,t){var n=function(e){if(e=e.trim(),Na=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Na-1)return(ja=e.lastIndexOf("."))>-1?{exp:e.slice(0,ja),key:'"'+e.slice(ja+1)+'"'}:{exp:e,key:null};for(La=e,ja=Ga=Qa=0;!ci();)yi(za=li())?Ti(za):91===za&&mi(za);return{exp:e.slice(0,Ga),key:e.slice(Ga+1,Qa)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function li(){return La.charCodeAt(++ja)}function ci(){return ja>=Na}function yi(e){return 34===e||39===e}function mi(e){var t=1;for(Ga=ja;!ci();)if(yi(e=li()))Ti(e);else if(91===e&&t++,93===e&&t--,0===t){Qa=ja;break}}function Ti(e){for(var t=e;!ci()&&(e=li())!==t;);}var fi;function hi(e,t,n){var a=fi;return function i(){var s=t.apply(null,arguments);null!==s&&gi(e,i,n,a)}}var bi=Xt&&!(ee&&Number(ee[1])<=53);function vi(e,t,n,a){if(bi){var i=Dt,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}fi.addEventListener(e,t,ne?{capture:n,passive:a}:n)}function gi(e,t,n,a){(a||fi).removeEventListener(e,t._wrapper||t,n)}function Ci(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},s=e.data.on||{};fi=t.elm||e.elm,function(e){if(i(e.__r)){var t=K?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}i(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),Ne(n,s,vi,gi,hi,t.context),fi=void 0}}var ki,Pi={create:Ci,update:Ci,destroy:function(e){return Ci(e,wa)}};function _i(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,r,o=t.elm,d=e.data.domProps||{},p=t.data.domProps||{};for(n in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=t.data.domProps=x({},p)),d)n in p||(o[n]="");for(n in p){if(r=p[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),r===d[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=r;var u=a(r)?"":String(r);wi(o,u)&&(o.value=u)}else if("innerHTML"===n&&Ta(o.tagName)&&a(o.innerHTML)){(ki=ki||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var l=ki.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;l.firstChild;)o.appendChild(l.firstChild)}else if(r!==d[n])try{o[n]=r}catch(e){}}}}function wi(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return m(n)!==m(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Ai={create:_i,update:_i},Mi=C((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function qi(e){var t=xi(e.style);return e.staticStyle?x(e.staticStyle,t):t}function xi(e){return Array.isArray(e)?F(e):"string"==typeof e?Mi(e):e}var Fi,Ri=/^--/,Ei=/\s*!important$/,Ii=function(e,t,n){if(Ri.test(t))e.style.setProperty(t,n);else if(Ei.test(n))e.style.setProperty(A(t),n.replace(Ei,""),"important");else{var a=Oi(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},Si=["Webkit","Moz","ms"],Oi=C((function(e){if(Fi=Fi||document.createElement("div").style,"filter"!==(e=P(e))&&e in Fi)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Si.length;n++){var a=Si[n]+t;if(a in Fi)return a}}));function Vi(e,t){var n=t.data,s=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(s.staticStyle)&&a(s.style))){var r,o,d=t.elm,p=s.staticStyle,u=s.normalizedStyle||s.style||{},l=p||u,c=xi(t.data.style)||{};t.data.normalizedStyle=i(c.__ob__)?x({},c):c;var y=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=qi(i.data))&&x(a,n);(n=qi(e.data))&&x(a,n);for(var s=e;s=s.parent;)s.data&&(n=qi(s.data))&&x(a,n);return a}(t);for(o in l)a(y[o])&&Ii(d,o,"");for(o in y)(r=y[o])!==l[o]&&Ii(d,o,null==r?"":r)}}var Bi={create:Vi,update:Vi},Ui=/\s+/;function Di(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function $i(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Ni(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&x(t,Li(e.name||"v")),x(t,e),t}return"string"==typeof e?Li(e):void 0}}var Li=C((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),zi=H&&!J,ji="transition",Gi="animation",Qi="transition",Hi="transitionend",Wi="animation",Ki="animationend";zi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Qi="WebkitTransition",Hi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wi="WebkitAnimation",Ki="webkitAnimationEnd"));var Ji=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Zi(e){Ji((function(){Ji(e)}))}function Xi(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Di(e,t))}function Yi(e,t){e._transitionClasses&&b(e._transitionClasses,t),$i(e,t)}function es(e,t,n){var a=ns(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===ji?Hi:Ki,d=0,p=function(){e.removeEventListener(o,u),n()},u=function(t){t.target===e&&++d>=r&&p()};setTimeout((function(){d<r&&p()}),s+1),e.addEventListener(o,u)}var ts=/\b(transform|all)(,|$)/;function ns(e,t){var n,a=window.getComputedStyle(e),i=(a[Qi+"Delay"]||"").split(", "),s=(a[Qi+"Duration"]||"").split(", "),r=as(i,s),o=(a[Wi+"Delay"]||"").split(", "),d=(a[Wi+"Duration"]||"").split(", "),p=as(o,d),u=0,l=0;return t===ji?r>0&&(n=ji,u=r,l=s.length):t===Gi?p>0&&(n=Gi,u=p,l=d.length):l=(n=(u=Math.max(r,p))>0?r>p?ji:Gi:null)?n===ji?s.length:d.length:0,{type:n,timeout:u,propCount:l,hasTransform:n===ji&&ts.test(a[Qi+"Property"])}}function as(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return is(t)+is(e[n])})))}function is(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function ss(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var s=Ni(e.data.transition);if(!a(s)&&!i(n._enterCb)&&1===n.nodeType){for(var r=s.css,p=s.type,u=s.enterClass,l=s.enterToClass,c=s.enterActiveClass,y=s.appearClass,T=s.appearToClass,f=s.appearActiveClass,h=s.beforeEnter,b=s.enter,v=s.afterEnter,g=s.enterCancelled,C=s.beforeAppear,k=s.appear,P=s.afterAppear,_=s.appearCancelled,w=s.duration,A=Mt,M=Mt.$vnode;M&&M.parent;)A=M.context,M=M.parent;var q=!A._isMounted||!e.isRootInsert;if(!q||k||""===k){var x=q&&y?y:u,F=q&&f?f:c,R=q&&T?T:l,E=q&&C||h,I=q&&o(k)?k:b,S=q&&P||v,O=q&&_||g,B=m(d(w)?w.enter:w),U=!1!==r&&!J,D=ds(I),$=n._enterCb=V((function(){U&&(Yi(n,R),Yi(n,F)),$.cancelled?(U&&Yi(n,x),O&&O(n)):S&&S(n),n._enterCb=null}));e.data.show||Le(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),I&&I(n,$)})),E&&E(n),U&&(Xi(n,x),Xi(n,F),Zi((function(){Yi(n,x),$.cancelled||(Xi(n,R),D||(os(B)?setTimeout($,B):es(n,p,$)))}))),e.data.show&&(t&&t(),I&&I(n,$)),U||D||$()}}}function rs(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var s=Ni(e.data.transition);if(a(s)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var r=s.css,o=s.type,p=s.leaveClass,u=s.leaveToClass,l=s.leaveActiveClass,c=s.beforeLeave,y=s.leave,T=s.afterLeave,f=s.leaveCancelled,h=s.delayLeave,b=s.duration,v=!1!==r&&!J,g=ds(y),C=m(d(b)?b.leave:b),k=n._leaveCb=V((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(Yi(n,u),Yi(n,l)),k.cancelled?(v&&Yi(n,p),f&&f(n)):(t(),T&&T(n)),n._leaveCb=null}));h?h(P):P()}function P(){k.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),c&&c(n),v&&(Xi(n,p),Xi(n,l),Zi((function(){Yi(n,p),k.cancelled||(Xi(n,u),g||(os(C)?setTimeout(k,C):es(n,o,k)))}))),y&&y(n,k),v||g||k())}}function os(e){return"number"==typeof e&&!isNaN(e)}function ds(e){if(a(e))return!1;var t=e.fns;return i(t)?ds(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function ps(e,t){!0!==t.data.show&&ss(t)}var us=function(e){var n,o,d={},p=e.modules,u=e.nodeOps;for(n=0;n<Aa.length;++n)for(d[Aa[n]]=[],o=0;o<p.length;++o)i(p[o][Aa[n]])&&d[Aa[n]].push(p[o][Aa[n]]);function l(e){var t=u.parentNode(e);i(t)&&u.removeChild(t,e)}function c(e,t,n,a,r,o,p){if(i(e.elm)&&i(o)&&(e=o[p]=me(e)),e.isRootInsert=!r,!function(e,t,n,a){var r=e.data;if(i(r)){var o=i(e.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(e,!1),i(e.componentInstance))return y(e,t),m(n,e.elm,a),s(o)&&function(e,t,n,a){for(var s,r=e;r.componentInstance;)if(i(s=(r=r.componentInstance._vnode).data)&&i(s=s.transition)){for(s=0;s<d.activate.length;++s)d.activate[s](wa,r);t.push(r);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var l=e.data,c=e.children,T=e.tag;i(T)?(e.elm=e.ns?u.createElementNS(e.ns,T):u.createElement(T,e),v(e),f(e,c,t),i(l)&&b(e,t),m(n,e.elm,a)):s(e.isComment)?(e.elm=u.createComment(e.text),m(n,e.elm,a)):(e.elm=u.createTextNode(e.text),m(n,e.elm,a))}}function y(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,h(e)?(b(e,t),v(e)):(Pa(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?u.parentNode(n)===e&&u.insertBefore(e,t,n):u.appendChild(e,t))}function f(e,n,a){if(t(n))for(var i=0;i<n.length;++i)c(n[i],a,e.elm,null,!0,n,i);else r(e.text)&&u.appendChild(e.elm,u.createTextNode(String(e.text)))}function h(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function b(e,t){for(var a=0;a<d.create.length;++a)d.create[a](wa,e);i(n=e.data.hook)&&(i(n.create)&&n.create(wa,e),i(n.insert)&&t.push(e))}function v(e){var t;if(i(t=e.fnScopeId))u.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t),n=n.parent;i(t=Mt)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t)}function g(e,t,n,a,i,s){for(;a<=i;++a)c(n[a],s,e,t,!1,n,a)}function C(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<d.destroy.length;++t)d.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)C(e.children[n])}function k(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(P(a),C(a)):l(a.elm))}}function P(e,t){if(i(t)||i(e.data)){var n,a=d.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&P(n,t),n=0;n<d.remove.length;++n)d.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else l(e.elm)}function _(e,t,n,a){for(var s=n;s<a;s++){var r=t[s];if(i(r)&&Ma(e,r))return s}}function w(e,t,n,r,o,p){if(e!==t){i(t.elm)&&i(r)&&(t=r[o]=me(t));var l=t.elm=e.elm;if(s(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?q(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(e.isStatic)&&t.key===e.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=e.componentInstance;else{var y,m=t.data;i(m)&&i(y=m.hook)&&i(y=y.prepatch)&&y(e,t);var T=e.children,f=t.children;if(i(m)&&h(t)){for(y=0;y<d.update.length;++y)d.update[y](e,t);i(y=m.hook)&&i(y=y.update)&&y(e,t)}a(t.text)?i(T)&&i(f)?T!==f&&function(e,t,n,s,r){for(var o,d,p,l=0,y=0,m=t.length-1,T=t[0],f=t[m],h=n.length-1,b=n[0],v=n[h],C=!r;l<=m&&y<=h;)a(T)?T=t[++l]:a(f)?f=t[--m]:Ma(T,b)?(w(T,b,s,n,y),T=t[++l],b=n[++y]):Ma(f,v)?(w(f,v,s,n,h),f=t[--m],v=n[--h]):Ma(T,v)?(w(T,v,s,n,h),C&&u.insertBefore(e,T.elm,u.nextSibling(f.elm)),T=t[++l],v=n[--h]):Ma(f,b)?(w(f,b,s,n,y),C&&u.insertBefore(e,f.elm,T.elm),f=t[--m],b=n[++y]):(a(o)&&(o=qa(t,l,m)),a(d=i(b.key)?o[b.key]:_(b,t,l,m))?c(b,s,e,T.elm,!1,n,y):Ma(p=t[d],b)?(w(p,b,s,n,y),t[d]=void 0,C&&u.insertBefore(e,p.elm,T.elm)):c(b,s,e,T.elm,!1,n,y),b=n[++y]);l>m?g(e,a(n[h+1])?null:n[h+1].elm,n,y,h,s):y>h&&k(t,l,m)}(l,T,f,n,p):i(f)?(i(e.text)&&u.setTextContent(l,""),g(l,null,f,0,f.length-1,n)):i(T)?k(T,0,T.length-1):i(e.text)&&u.setTextContent(l,""):e.text!==t.text&&u.setTextContent(l,t.text),i(m)&&i(y=m.hook)&&i(y=y.postpatch)&&y(e,t)}}}function A(e,t,n){if(s(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var M=T("attrs,class,staticClass,staticStyle,key");function q(e,t,n,a){var r,o=t.tag,d=t.data,p=t.children;if(a=a||d&&d.pre,t.elm=e,s(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(d)&&(i(r=d.hook)&&i(r=r.init)&&r(t,!0),i(r=t.componentInstance)))return y(t,n),!0;if(i(o)){if(i(p))if(e.hasChildNodes())if(i(r=d)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var u=!0,l=e.firstChild,c=0;c<p.length;c++){if(!l||!q(l,p[c],n,a)){u=!1;break}l=l.nextSibling}if(!u||l)return!1}else f(t,p,n);if(i(d)){var m=!1;for(var T in d)if(!M(T)){m=!0,b(t,n);break}!m&&d.class&&un(d.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!a(t)){var o,p=!1,l=[];if(a(e))p=!0,c(t,l);else{var y=i(e.nodeType);if(!y&&Ma(e,t))w(e,t,l,null,null,r);else{if(y){if(1===e.nodeType&&e.hasAttribute(U)&&(e.removeAttribute(U),n=!0),s(n)&&q(e,t,l))return A(t,l,!0),e;o=e,e=new le(u.tagName(o).toLowerCase(),{},[],void 0,o)}var m=e.elm,T=u.parentNode(m);if(c(t,l,m._leaveCb?null:T,u.nextSibling(m)),i(t.parent))for(var f=t.parent,b=h(t);f;){for(var v=0;v<d.destroy.length;++v)d.destroy[v](f);if(f.elm=t.elm,b){for(var g=0;g<d.create.length;++g)d.create[g](wa,f);var P=f.data.hook.insert;if(P.merged)for(var _=1;_<P.fns.length;_++)P.fns[_]()}else Pa(f);f=f.parent}i(T)?k([e],0,0):i(e.tag)&&C(e)}}return A(t,l,p),t.elm}i(e)&&C(e)}}({nodeOps:Ca,modules:[Da,Ha,Pi,Ai,Bi,H?{create:ps,activate:ps,remove:function(e,t){!0!==e.data.show?rs(e,t):t()}}:{}].concat(Oa)});J&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&bs(e,"input")}));var ls={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?Le(n,"postpatch",(function(){ls.componentUpdated(e,t,n)})):cs(e,t,n.context),e._vOptions=[].map.call(e.options,Ts)):("textarea"===n.tag||va(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",fs),e.addEventListener("compositionend",hs),e.addEventListener("change",hs),J&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){cs(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,Ts);i.some((function(e,t){return!S(e,a[t])}))&&(e.multiple?t.value.some((function(e){return ms(e,i)})):t.value!==t.oldValue&&ms(t.value,i))&&bs(e,"change")}}};function cs(e,t,n){ys(e,t),(K||Z)&&setTimeout((function(){ys(e,t)}),0)}function ys(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,d=e.options.length;o<d;o++)if(r=e.options[o],i)s=O(a,Ts(r))>-1,r.selected!==s&&(r.selected=s);else if(S(Ts(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function ms(e,t){return t.every((function(t){return!S(t,e)}))}function Ts(e){return"_value"in e?e._value:e.value}function fs(e){e.target.composing=!0}function hs(e){e.target.composing&&(e.target.composing=!1,bs(e.target,"input"))}function bs(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function vs(e){return!e.componentInstance||e.data&&e.data.transition?e:vs(e.componentInstance._vnode)}var gs={model:ls,show:{bind:function(e,t,n){var a=t.value,i=(n=vs(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,ss(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=vs(n)).data&&n.data.transition?(n.data.show=!0,a?ss(n,(function(){e.style.display=e.__vOriginalDisplay})):rs(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},Cs={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ks(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?ks(kt(t.children)):e}function Ps(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[P(a)]=i[a];return t}function _s(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var ws=function(e){return e.tag||ct(e)},As=function(e){return"show"===e.name},Ms={name:"transition",props:Cs,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(ws)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=ks(i);if(!s)return i;if(this._leaving)return _s(e,i);var o="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var d=(s.data||(s.data={})).transition=Ps(this),p=this._vnode,u=ks(p);if(s.data.directives&&s.data.directives.some(As)&&(s.data.show=!0),u&&u.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,u)&&!ct(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var l=u.data.transition=x({},d);if("out-in"===a)return this._leaving=!0,Le(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),_s(e,i);if("in-out"===a){if(ct(s))return p;var c,y=function(){c()};Le(d,"afterEnter",y),Le(d,"enterCancelled",y),Le(l,"delayLeave",(function(e){c=e}))}}return i}}},qs=x({tag:String,moveClass:String},Cs);delete qs.mode;var xs={props:qs,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=qt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=Ps(this),o=0;o<i.length;o++)(u=i[o]).tag&&null!=u.key&&0!==String(u.key).indexOf("__vlist")&&(s.push(u),n[u.key]=u,(u.data||(u.data={})).transition=r);if(a){var d=[],p=[];for(o=0;o<a.length;o++){var u;(u=a[o]).data.transition=r,u.data.pos=u.elm.getBoundingClientRect(),n[u.key]?d.push(u):p.push(u)}this.kept=e(t,null,d),this.removed=p}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Fs),e.forEach(Rs),e.forEach(Es),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Xi(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Hi,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Hi,e),n._moveCb=null,Yi(n,t))})}})))},methods:{hasMove:function(e,t){if(!zi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){$i(n,e)})),Di(n,t),n.style.display="none",this.$el.appendChild(n);var a=ns(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function Fs(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Rs(e){e.data.newPos=e.elm.getBoundingClientRect()}function Es(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),s.transitionDuration="0s"}}var Is={Transition:Ms,TransitionGroup:xs};Hn.config.mustUseProp=na,Hn.config.isReservedTag=fa,Hn.config.isReservedAttr=ea,Hn.config.getTagNamespace=ha,Hn.config.isUnknownElement=function(e){if(!H)return!0;if(fa(e))return!1;if(e=e.toLowerCase(),null!=ba[e])return ba[e];var t=document.createElement(e);return e.indexOf("-")>-1?ba[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ba[e]=/HTMLUnknownElement/.test(t.toString())},x(Hn.options.directives,gs),x(Hn.options.components,Is),Hn.prototype.__patch__=H?us:R,Hn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=ce),Et(e,"beforeMount"),a=function(){e._update(e._render(),n)},new yn(e,a,R,{before:function(){e._isMounted&&!e._isDestroyed&&Et(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var s=0;s<i.length;s++)i[s].run();return null==e.$vnode&&(e._isMounted=!0,Et(e,"mounted")),e}(this,e=e&&H?ga(e):void 0,t)},H&&setTimeout((function(){N.devtools&&se&&se.emit("init",Hn)}),0);var Ss,Os=/\{\{((?:.|\r?\n)+?)\}\}/g,Vs=/[-.*+?^${}()|[\]\/\\]/g,Bs=C((function(e){var t=e[0].replace(Vs,"\\$&"),n=e[1].replace(Vs,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Us={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ri(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=si(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},Ds={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ri(e,"style");n&&(e.staticStyle=JSON.stringify(Mi(n)));var a=si(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},$s=T("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Ns=T("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ls=T("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),zs=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,js=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Gs="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(L.source,"]*"),Qs="((?:".concat(Gs,"\\:)?").concat(Gs,")"),Hs=new RegExp("^<".concat(Qs)),Ws=/^\s*(\/?)>/,Ks=new RegExp("^<\\/".concat(Qs,"[^>]*>")),Js=/^<!DOCTYPE [^>]+>/i,Zs=/^<!\--/,Xs=/^<!\[/,Ys=T("script,style,textarea",!0),er={},tr={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},nr=/&(?:lt|gt|quot|amp|#39);/g,ar=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,ir=T("pre,textarea",!0),sr=function(e,t){return e&&ir(e)&&"\n"===t[0]};function rr(e,t){var n=t?ar:nr;return e.replace(n,(function(e){return tr[e]}))}var or,dr,pr,ur,lr,cr,yr,mr,Tr=/^@|^v-on:/,fr=/^v-|^@|^:|^#/,hr=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,br=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,vr=/^\(|\)$/g,gr=/^\[.*\]$/,Cr=/:(.*)$/,kr=/^:|^\.|^v-bind:/,Pr=/\.[^.\]]+(?=[^\]]*$)/g,_r=/^v-slot(:|$)|^#/,wr=/[\r\n]/,Ar=/[ \f\t\r\n]+/g,Mr=C((function(e){return(Ss=Ss||document.createElement("div")).innerHTML=e,Ss.textContent})),qr="_empty_";function xr(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:Vr(t),rawAttrsMap:{},parent:n,children:[]}}function Fr(e,t){or=t.warn||Za,cr=t.isPreTag||E,yr=t.mustUseProp||E,mr=t.getTagNamespace||E;t.isReservedTag;pr=Xa(t.modules,"transformNode"),ur=Xa(t.modules,"preTransformNode"),lr=Xa(t.modules,"postTransformNode"),dr=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,d=!1;function p(e){if(u(e),o||e.processed||(e=Rr(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&Ir(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,p=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),p&&p.if&&Ir(p,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,p;e.children=e.children.filter((function(e){return!e.slotScope})),u(e),e.pre&&(o=!1),cr(e.tag)&&(d=!1);for(var l=0;l<lr.length;l++)lr[l](e,t)}function u(e){if(!d)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||E,o=t.canBeLeftOpenTag||E,d=0,p=function(){if(n=e,a&&Ys(a)){var p=0,c=a.toLowerCase(),y=er[c]||(er[c]=new RegExp("([\\s\\S]*?)(</"+c+"[^>]*>)","i"));k=e.replace(y,(function(e,n,a){return p=a.length,Ys(c)||"noscript"===c||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),sr(c,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),d+=e.length-k.length,e=k,l(c,d-p,d)}else{var m=e.indexOf("<");if(0===m){if(Zs.test(e)){var T=e.indexOf("--\x3e");if(T>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,T),d,d+T+3),u(T+3),"continue"}if(Xs.test(e)){var f=e.indexOf("]>");if(f>=0)return u(f+2),"continue"}var h=e.match(Js);if(h)return u(h[0].length),"continue";var b=e.match(Ks);if(b){var v=d;return u(b[0].length),l(b[1],v,d),"continue"}var g=function(){var t=e.match(Hs);if(t){var n={tagName:t[1],attrs:[],start:d};u(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(Ws))&&(i=e.match(js)||e.match(zs));)i.start=d,u(i[0].length),i.end=d,n.attrs.push(i);if(a)return n.unarySlash=a[1],u(a[0].length),n.end=d,n}}();if(g)return function(e){var n=e.tagName,d=e.unarySlash;s&&("p"===a&&Ls(n)&&l(a),o(n)&&a===n&&l(n));for(var p=r(n)||!!d,u=e.attrs.length,c=new Array(u),y=0;y<u;y++){var m=e.attrs[y],T=m[3]||m[4]||m[5]||"",f="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;c[y]={name:m[1],value:rr(T,f)}}p||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:c,start:e.start,end:e.end}),a=n),t.start&&t.start(n,c,p,e.start,e.end)}(g),sr(g.tagName,e)&&u(1),"continue"}var C=void 0,k=void 0,P=void 0;if(m>=0){for(k=e.slice(m);!(Ks.test(k)||Hs.test(k)||Zs.test(k)||Xs.test(k)||(P=k.indexOf("<",1))<0);)m+=P,k=e.slice(m);C=e.substring(0,m)}m<0&&(C=e),C&&u(C.length),t.chars&&C&&t.chars(C,d-C.length,d)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==p(););function u(t){d+=t,e=e.substring(t)}function l(e,n,s){var r,o;if(null==n&&(n=d),null==s&&(s=d),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var p=i.length-1;p>=r;p--)t.end&&t.end(i[p].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}l()}(e,{warn:or,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,u,l){var c=a&&a.ns||mr(e);K&&"svg"===c&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];Br.test(a.name)||(a.name=a.name.replace(Ur,""),t.push(a))}return t}(s));var y,m=xr(e,s,a);c&&(m.ns=c),"style"!==(y=m).tag&&("script"!==y.tag||y.attrsMap.type&&"text/javascript"!==y.attrsMap.type)||ie()||(m.forbidden=!0);for(var T=0;T<ur.length;T++)m=ur[T](m,t)||m;o||(function(e){null!=ri(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),cr(m.tag)&&(d=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(Er(m),function(e){var t=ri(e,"v-if");if(t)e.if=t,Ir(e,{exp:t,block:e});else{null!=ri(e,"v-else")&&(e.else=!0);var n=ri(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=ri(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),r?p(m):(a=m,i.push(m))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],p(s)},chars:function(e,t,n){if(a&&(!K||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,p=a.children;if(e=d||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:Mr(e):p.length?r?"condense"===r&&wr.test(e)?"":" ":s?" ":"":""){d||"condense"!==r||(e=e.replace(Ar," "));var u=void 0,l=void 0;!o&&" "!==e&&(u=function(e,t){var n=t?Bs(t):Os;if(n.test(e)){for(var a,i,s,r=[],o=[],d=n.lastIndex=0;a=n.exec(e);){(i=a.index)>d&&(o.push(s=e.slice(d,i)),r.push(JSON.stringify(s)));var p=Ka(a[1].trim());r.push("_s(".concat(p,")")),o.push({"@binding":p}),d=i+a[0].length}return d<e.length&&(o.push(s=e.slice(d)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,dr))?l={type:2,expression:u.expression,tokens:u.tokens,text:e}:" "===e&&p.length&&" "===p[p.length-1].text||(l={type:3,text:e}),l&&p.push(l)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function Rr(e,t){var n;!function(e){var t=si(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=si(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ri(e,"scope"),e.slotScope=t||ri(e,"slot-scope")):(t=ri(e,"slot-scope"))&&(e.slotScope=t);var n,a=si(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||ei(e,"slot",a,function(e,t){return e.rawAttrsMap[":slot"]||e.rawAttrsMap["v-bind:slot"]||e.rawAttrsMap.slot}(e))),"template"===e.tag){if(n=oi(e,_r)){var i=Sr(n),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=n.value||qr}}else if(n=oi(e,_r)){var o=e.scopedSlots||(e.scopedSlots={}),d=Sr(n),p=d.name,u=(r=d.dynamic,o[p]=xr("template",[],e));u.slotTarget=p,u.slotTargetDynamic=r,u.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=u,!0})),u.slotScope=n.value||qr,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=si(n,"name")),function(e){var t;(t=si(e,"is"))&&(e.component=t),null!=ri(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<pr.length;a++)e=pr[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,d,p=e.attrsList;for(t=0,n=p.length;t<n;t++)if(a=i=p[t].name,s=p[t].value,fr.test(a))if(e.hasBindings=!0,(r=Or(a.replace(fr,"")))&&(a=a.replace(Pr,"")),kr.test(a))a=a.replace(kr,""),s=Ka(s),(d=gr.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!d&&"innerHtml"===(a=P(a))&&(a="innerHTML"),r.camel&&!d&&(a=P(a)),r.sync&&(o=ui(s,"$event"),d?ii(e,'"update:"+('.concat(a,")"),o,null,!1,0,p[t],!0):(ii(e,"update:".concat(P(a)),o,null,!1,0,p[t]),A(a)!==P(a)&&ii(e,"update:".concat(A(a)),o,null,!1,0,p[t])))),r&&r.prop||!e.component&&yr(e.tag,e.attrsMap.type,a)?Ya(e,a,s,p[t],d):ei(e,a,s,p[t],d);else if(Tr.test(a))a=a.replace(Tr,""),(d=gr.test(a))&&(a=a.slice(1,-1)),ii(e,a,s,r,!1,0,p[t],d);else{var u=(a=a.replace(fr,"")).match(Cr),l=u&&u[1];d=!1,l&&(a=a.slice(0,-(l.length+1)),gr.test(l)&&(l=l.slice(1,-1),d=!0)),ni(e,a,i,s,l,d,r,p[t])}else ei(e,a,JSON.stringify(s),p[t]),!e.component&&"muted"===a&&yr(e.tag,e.attrsMap.type,a)&&Ya(e,a,"true",p[t])}(e),e}function Er(e){var t;if(t=ri(e,"v-for")){var n=function(e){var t=e.match(hr);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(vr,""),i=a.match(br);return i?(n.alias=a.replace(br,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&x(e,n)}}function Ir(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Sr(e){var t=e.name.replace(_r,"");return t||"#"!==e.name[0]&&(t="default"),gr.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function Or(e){var t=e.match(Pr);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function Vr(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var Br=/^xmlns:NS\d+/,Ur=/^NS\d+:/;function Dr(e){return xr(e.tag,e.attrsList.slice(),e.parent)}var $r,Nr,Lr=[Us,Ds,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=si(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=ri(e,"v-if",!0),s=i?"&&(".concat(i,")"):"",r=null!=ri(e,"v-else",!0),o=ri(e,"v-else-if",!0),d=Dr(e);Er(d),ti(d,"type","checkbox"),Rr(d,t),d.processed=!0,d.if="(".concat(a,")==='checkbox'")+s,Ir(d,{exp:d.if,block:d});var p=Dr(e);ri(p,"v-for",!0),ti(p,"type","radio"),Rr(p,t),Ir(d,{exp:"(".concat(a,")==='radio'")+s,block:p});var u=Dr(e);return ri(u,"v-for",!0),ti(u,":type",a),Rr(u,t),Ir(d,{exp:i,block:u}),r?d.else=!0:o&&(d.elseif=o),d}}}}],zr={expectHTML:!0,modules:Lr,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return pi(e,a,i),!1;if("select"===s)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),s="var $$selectedVal = ".concat(i,";");ii(e,"change",s="".concat(s," ").concat(ui(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=si(e,"value")||"null",s=si(e,"true-value")||"true",r=si(e,"false-value")||"false";Ya(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===s?":(".concat(t,")"):":_q(".concat(t,",").concat(s,")"))),ii(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(s,"):(").concat(r,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(ui(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(ui(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(ui(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=si(e,"value")||"null";i=a?"_n(".concat(i,")"):i,Ya(e,"checked","_q(".concat(t,",").concat(i,")")),ii(e,"change",ui(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,d=!s&&"range"!==a,p=s?"change":"range"===a?"__r":"input",u="$event.target.value";o&&(u="$event.target.value.trim()"),r&&(u="_n(".concat(u,")"));var l=ui(t,u);d&&(l="if($event.target.composing)return;".concat(l)),Ya(e,"value","(".concat(t,")")),ii(e,p,l,null,!0),(o||r)&&ii(e,"blur","$forceUpdate()")}(e,a,i);else if(!N.isReservedTag(s))return pi(e,a,i),!1;return!0},text:function(e,t){t.value&&Ya(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&Ya(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:$s,mustUseProp:na,canBeLeftOpenTag:Ns,isReservedTag:fa,getTagNamespace:ha,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(Lr)},jr=C((function(e){return T("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Gr(e,t){e&&($r=jr(t.staticKeys||""),Nr=t.isReservedTag||E,Qr(e),Hr(e,!1))}function Qr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||f(e.tag)||!Nr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every($r))))}(e),1===e.type){if(!Nr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Qr(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;Qr(i),i.static||(e.static=!1)}}}function Hr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Hr(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)Hr(e.ifConditions[n].block,t)}}var Wr=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Kr=/\([^)]*?\);*$/,Jr=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Zr={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Xr={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Yr=function(e){return"if(".concat(e,")return null;")},eo={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Yr("$event.target !== $event.currentTarget"),ctrl:Yr("!$event.ctrlKey"),shift:Yr("!$event.shiftKey"),alt:Yr("!$event.altKey"),meta:Yr("!$event.metaKey"),left:Yr("'button' in $event && $event.button !== 0"),middle:Yr("'button' in $event && $event.button !== 1"),right:Yr("'button' in $event && $event.button !== 2")};function to(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=no(e[s]);e[s]&&e[s].dynamic?i+="".concat(s,",").concat(r,","):a+='"'.concat(s,'":').concat(r,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function no(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return no(e)})).join(","),"]");var t=Jr.test(e.value),n=Wr.test(e.value),a=Jr.test(e.value.replace(Kr,""));if(e.modifiers){var i="",s="",r=[],o=function(t){if(eo[t])s+=eo[t],Zr[t]&&r.push(t);else if("exact"===t){var n=e.modifiers;s+=Yr(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else r.push(t)};for(var d in e.modifiers)o(d);r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(ao).join("&&"),")return null;")}(r)),s&&(i+=s);var p=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(p,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function ao(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=Zr[e],a=Xr[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var io={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:R},so=function(e){this.options=e,this.warn=e.warn||Za,this.transforms=Xa(e.modules,"transformCode"),this.dataGenFns=Xa(e.modules,"genData"),this.directives=x(x({},io),e.directives);var t=e.isReservedTag||E;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function ro(e,t){var n=new so(t),a=e?"script"===e.tag?"null":oo(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function oo(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return po(e,t);if(e.once&&!e.onceProcessed)return uo(e,t);if(e.for&&!e.forProcessed)return yo(e,t);if(e.if&&!e.ifProcessed)return lo(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=ho(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),s=e.attrs||e.dynamicAttrs?go((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:P(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=",".concat(s)),r&&(i+="".concat(s?"":",null",",").concat(r)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:ho(t,n,!0);return"_c(".concat(e,",").concat(mo(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=mo(e,t));var s=void 0,r=t.options.bindings;i&&r&&!1!==r.__isScriptSetup&&(s=function(e,t){var n=P(t),a=_(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},s=i("setup-const")||i("setup-reactive-const");if(s)return s;var r=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return r||void 0}(r,e.tag)),s||(s="'".concat(e.tag,"'"));var o=e.inlineTemplate?null:ho(e,t,!0);n="_c(".concat(s).concat(a?",".concat(a):"").concat(o?",".concat(o):"",")")}for(var d=0;d<t.transforms.length;d++)n=t.transforms[d](e,n);return n}return ho(e,t)||"void 0"}function po(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(oo(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function uo(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return lo(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(oo(e,t),",").concat(t.onceId++,",").concat(n,")"):oo(e,t)}return po(e,t)}function lo(e,t,n,a){return e.ifProcessed=!0,co(e.ifConditions.slice(),t,n,a)}function co(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(s(i.block),":").concat(co(e,t,n,a)):"".concat(s(i.block));function s(e){return n?n(e,t):e.once?uo(e,t):oo(e,t)}}function yo(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?",".concat(e.iterator1):"",o=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(s).concat(r).concat(o,"){")+"return ".concat((n||oo)(e,t))+"})"}function mo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",d=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var p=t.directives[s.name];p&&(r=!!p(e,s,t.warn)),r&&(d=!0,o+='{name:"'.concat(s.name,'",rawName:"').concat(s.rawName,'"').concat(s.value?",value:(".concat(s.value,"),expression:").concat(JSON.stringify(s.value)):"").concat(s.arg?",arg:".concat(s.isDynamicArg?s.arg:'"'.concat(s.arg,'"')):"").concat(s.modifiers?",modifiers:".concat(JSON.stringify(s.modifiers)):"","},"))}return d?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(go(e.attrs),",")),e.props&&(n+="domProps:".concat(go(e.props),",")),e.events&&(n+="".concat(to(e.events,!1),",")),e.nativeEvents&&(n+="".concat(to(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||To(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==qr||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return fo(t[e],n)})).join(",");return"scopedSlots:_u([".concat(r,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=ro(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);s&&(n+="".concat(s,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(go(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function To(e){return 1===e.type&&("slot"===e.tag||e.children.some(To))}function fo(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return lo(e,t,fo,"null");if(e.for&&!e.forProcessed)return yo(e,t,fo);var a=e.slotScope===qr?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(ho(e,t)||"undefined",":undefined"):ho(e,t)||"undefined":oo(e,t),"}"),s=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(s,"}")}function ho(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return"".concat((a||oo)(r,t)).concat(o)}var d=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(bo(i)||i.ifConditions&&i.ifConditions.some((function(e){return bo(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,p=i||vo;return"[".concat(s.map((function(e){return p(e,t)})).join(","),"]").concat(d?",".concat(d):"")}}function bo(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function vo(e,t){return 1===e.type?oo(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:Co(JSON.stringify(n.text)),")");var n}function go(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=Co(i.value);i.dynamic?n+="".concat(i.name,",").concat(s,","):t+='"'.concat(i.name,'":').concat(s,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function Co(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function ko(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),R}}function Po(e){var t=Object.create(null);return function(n,a,i){(a=x({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},d=[];return o.render=ko(r.render,d),o.staticRenderFns=r.staticRenderFns.map((function(e){return ko(e,d)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var _o,wo,Ao=(_o=function(e,t){var n=Fr(e.trim(),t);!1!==t.optimize&&Gr(n,t);var a=ro(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=x(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=_o(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:Po(t)}}),Mo=Ao(zr).compileToFunctions;function qo(e){return(wo=wo||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',wo.innerHTML.indexOf("&#10;")>0}var xo=!!H&&qo(!1),Fo=!!H&&qo(!0),Ro=C((function(e){var t=ga(e);return t&&t.innerHTML})),Eo=Hn.prototype.$mount;function Io(e,t){for(var n in t)e[n]=t[n];return e}Hn.prototype.$mount=function(e,t){if((e=e&&ga(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=Ro(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=Mo(a,{outputSourceRange:!1,shouldDecodeNewlines:xo,shouldDecodeNewlinesForHref:Fo,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return Eo.call(this,e,t)},Hn.compile=Mo;var So=/[!'()*]/g,Oo=function(e){return"%"+e.charCodeAt(0).toString(16)},Vo=/%2C/g,Bo=function(e){return encodeURIComponent(e).replace(So,Oo).replace(Vo,",")};function Uo(e){try{return decodeURIComponent(e)}catch(e){}return e}var Do=function(e){return null==e||"object"==typeof e?e:String(e)};function $o(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=Uo(n.shift()),i=n.length>0?Uo(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function No(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return Bo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(Bo(t)):a.push(Bo(t)+"="+Bo(e)))})),a.join("&")}return Bo(t)+"="+Bo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Lo=/\/?$/;function zo(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=jo(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Ho(t,i),matched:e?Qo(e):[]};return n&&(r.redirectedFrom=Ho(n,i)),Object.freeze(r)}function jo(e){if(Array.isArray(e))return e.map(jo);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=jo(e[n]);return t}return e}var Go=zo(null,{path:"/"});function Qo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Ho(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||No)(a)+i}function Wo(e,t,n){return t===Go?e===t:!!t&&(e.path&&t.path?e.path.replace(Lo,"")===t.path.replace(Lo,"")&&(n||e.hash===t.hash&&Ko(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Ko(e.query,t.query)&&Ko(e.params,t.params)))}function Ko(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?Ko(s,r):String(s)===String(r)}))}function Jo(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var Zo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,d=i.$route,p=i._routerViewCache||(i._routerViewCache={}),u=0,l=!1;i&&i._routerRoot!==i;){var c=i.$vnode?i.$vnode.data:{};c.routerView&&u++,c.keepAlive&&i._directInactive&&i._inactive&&(l=!0),i=i.$parent}if(s.routerViewDepth=u,l){var y=p[o],m=y&&y.component;return m?(y.configProps&&Xo(m,s,y.route,y.configProps),r(m,s,a)):r()}var T=d.matched[u],f=T&&T.components[o];if(!T||!f)return p[o]=null,r();p[o]={component:f},s.registerRouteInstance=function(e,t){var n=T.instances[o];(t&&n!==e||!t&&n===e)&&(T.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){T.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==T.instances[o]&&(T.instances[o]=e.componentInstance),Jo(d)};var h=T.props&&T.props[o];return h&&(Io(p[o],{route:d,configProps:h}),Xo(f,s,d,h)),r(f,s,a)}};function Xo(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=Io({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function Yo(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function ed(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var td=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},nd=function e(t,n,a){return td(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return yd(e,t)}(t,n):td(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return yd(new RegExp("(?:"+i.join("|")+")",md(a)),n)}(t,n,a):function(e,t,n){return Td(od(e,n),t,n)}(t,n,a)},ad=od,id=ud,sd=Td,rd=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function od(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=rd.exec(e));){var d=n[0],p=n[1],u=n.index;if(r+=e.slice(s,u),s=u+d.length,p)r+=p[1];else{var l=e[s],c=n[2],y=n[3],m=n[4],T=n[5],f=n[6],h=n[7];r&&(a.push(r),r="");var b=null!=c&&null!=l&&l!==c,v="+"===f||"*"===f,g="?"===f||"*"===f,C=n[2]||o,k=m||T;a.push({name:y||i++,prefix:c||"",delimiter:C,optional:g,repeat:v,partial:b,asterisk:!!h,pattern:k?cd(k):h?".*":"[^"+ld(C)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function dd(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function pd(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function ud(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",md(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?dd:encodeURIComponent,o=0;o<e.length;o++){var d=e[o];if("string"!=typeof d){var p,u=s[d.name];if(null==u){if(d.optional){d.partial&&(i+=d.prefix);continue}throw new TypeError('Expected "'+d.name+'" to be defined')}if(td(u)){if(!d.repeat)throw new TypeError('Expected "'+d.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(d.optional)continue;throw new TypeError('Expected "'+d.name+'" to not be empty')}for(var l=0;l<u.length;l++){if(p=r(u[l]),!n[o].test(p))throw new TypeError('Expected all "'+d.name+'" to match "'+d.pattern+'", but received `'+JSON.stringify(p)+"`");i+=(0===l?d.prefix:d.delimiter)+p}}else{if(p=d.asterisk?pd(u):r(u),!n[o].test(p))throw new TypeError('Expected "'+d.name+'" to match "'+d.pattern+'", but received "'+p+'"');i+=d.prefix+p}}else i+=d}return i}}function ld(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function cd(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function yd(e,t){return e.keys=t,e}function md(e){return e&&e.sensitive?"":"i"}function Td(e,t,n){td(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=ld(o);else{var d=ld(o.prefix),p="(?:"+o.pattern+")";t.push(o),o.repeat&&(p+="(?:"+d+p+")*"),s+=p=o.optional?o.partial?d+"("+p+")?":"(?:"+d+"("+p+"))?":d+"("+p+")"}}var u=ld(n.delimiter||"/"),l=s.slice(-u.length)===u;return a||(s=(l?s.slice(0,-u.length):s)+"(?:"+u+"(?=$))?"),s+=i?"$":a&&l?"":"(?="+u+"|$)",yd(new RegExp("^"+s,md(n)),t)}nd.parse=ad,nd.compile=function(e,t){return ud(od(e,t),t)},nd.tokensToFunction=id,nd.tokensToRegExp=sd;var fd=Object.create(null);function hd(e,t,n){t=t||{};try{var a=fd[e]||(fd[e]=nd.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function bd(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=Io({},e)).params;return s&&"object"==typeof s&&(i.params=Io({},s)),i}if(!i.path&&i.params&&t){(i=Io({},i))._normalized=!0;var r=Io(Io({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=hd(o,r,t.path)}return i}var d=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),p=t&&t.path||"/",u=d.path?Yo(d.path,p,n||i.append):p,l=function(e,t,n){void 0===t&&(t={});var a,i=n||$o;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(Do):Do(r)}return a}(d.query,i.query,a&&a.options.parseQuery),c=i.hash||d.hash;return c&&"#"!==c.charAt(0)&&(c="#"+c),{_normalized:!0,path:u,query:l,hash:c}}var vd,gd=function(){},Cd={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,d={},p=n.options.linkActiveClass,u=n.options.linkExactActiveClass,l=null==p?"router-link-active":p,c=null==u?"router-link-exact-active":u,y=null==this.activeClass?l:this.activeClass,m=null==this.exactActiveClass?c:this.exactActiveClass,T=r.redirectedFrom?zo(null,bd(r.redirectedFrom),null,n):r;d[m]=Wo(a,T,this.exactPath),d[y]=this.exact||this.exactPath?d[m]:function(e,t){return 0===e.path.replace(Lo,"/").indexOf(t.path.replace(Lo,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,T);var f=d[m]?this.ariaCurrentValue:null,h=function(e){kd(e)&&(t.replace?n.replace(s,gd):n.push(s,gd))},b={click:kd};Array.isArray(this.event)?this.event.forEach((function(e){b[e]=h})):b[this.event]=h;var v={class:d},g=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:h,isActive:d[y],isExactActive:d[m]});if(g){if(1===g.length)return g[0];if(g.length>1||!g.length)return 0===g.length?e():e("span",{},g)}if("a"===this.tag)v.on=b,v.attrs={href:o,"aria-current":f};else{var C=Pd(this.$slots.default);if(C){C.isStatic=!1;var k=C.data=Io({},C.data);for(var P in k.on=k.on||{},k.on){var _=k.on[P];P in b&&(k.on[P]=Array.isArray(_)?_:[_])}for(var w in b)w in k.on?k.on[w].push(b[w]):k.on[w]=h;var A=C.data.attrs=Io({},C.data.attrs);A.href=o,A["aria-current"]=f}else v.on=b}return e(this.tag,v,this.$slots.default)}};function kd(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function Pd(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=Pd(t.children)))return t}}var _d="undefined"!=typeof window;function wd(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){Ad(s,r,o,e,i)}));for(var d=0,p=s.length;d<p;d++)"*"===s[d]&&(s.push(s.splice(d,1)[0]),p--,d--);return{pathList:s,pathMap:r,nameMap:o}}function Ad(e,t,n,a,i,s){var r=a.path,o=a.name,d=a.pathToRegexpOptions||{},p=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:ed(t.path+"/"+e)}(r,i,d.strict);"boolean"==typeof a.caseSensitive&&(d.sensitive=a.caseSensitive);var u={path:p,regex:Md(p,d),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?ed(s+"/"+a.path):void 0;Ad(e,t,n,a,u,i)})),t[u.path]||(e.push(u.path),t[u.path]=u),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],c=0;c<l.length;++c){var y={path:l[c],children:a.children};Ad(e,t,n,y,i,u.path||"/")}o&&(n[o]||(n[o]=u))}function Md(e,t){return nd(e,[],t)}function qd(e,t){var n=wd(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var d=bd(e,n,!1,t),p=d.name;if(p){var u=s[p];if(!u)return o(null,d);var l=u.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof d.params&&(d.params={}),n&&"object"==typeof n.params)for(var c in n.params)!(c in d.params)&&l.indexOf(c)>-1&&(d.params[c]=n.params[c]);return d.path=hd(u.path,d.params),o(u,d,r)}if(d.path){d.params={};for(var y=0;y<a.length;y++){var m=a[y],T=i[m];if(xd(T.regex,d.path,d.params))return o(T,d,r)}}return o(null,d)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(zo(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var d=i,p=d.name,u=d.path,l=n.query,c=n.hash,y=n.params;if(l=d.hasOwnProperty("query")?d.query:l,c=d.hasOwnProperty("hash")?d.hash:c,y=d.hasOwnProperty("params")?d.params:y,p)return s[p],r({_normalized:!0,name:p,query:l,hash:c,params:y},void 0,n);if(u){var m=function(e,t){return Yo(e,t.parent?t.parent.path:"/",!0)}(u,e);return r({_normalized:!0,path:hd(m,y),query:l,hash:c},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:hd(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):zo(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;wd([t||e],a,i,s,n),n&&n.alias.length&&wd(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){wd(e,a,i,s)}}}function xd(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?Uo(a[i]):a[i])}return!0}var Fd=_d&&window.performance&&window.performance.now?window.performance:Date;function Rd(){return Fd.now().toFixed(3)}var Ed=Rd();function Id(){return Ed}function Sd(e){return Ed=e}var Od=Object.create(null);function Vd(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=Io({},window.history.state);return n.key=Id(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Dd),function(){window.removeEventListener("popstate",Dd)}}function Bd(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=Id();if(e)return Od[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){jd(e,s)})).catch((function(e){})):jd(r,s))}))}}function Ud(){var e=Id();e&&(Od[e]={x:window.pageXOffset,y:window.pageYOffset})}function Dd(e){Ud(),e.state&&e.state.key&&Sd(e.state.key)}function $d(e){return Ld(e.x)||Ld(e.y)}function Nd(e){return{x:Ld(e.x)?e.x:window.pageXOffset,y:Ld(e.y)?e.y:window.pageYOffset}}function Ld(e){return"number"==typeof e}var zd=/^#\d/;function jd(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=zd.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Ld((n=s).x)?n.x:0,y:Ld(n.y)?n.y:0})}else $d(e)&&(t=Nd(e))}else a&&$d(e)&&(t=Nd(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Gd,Qd=_d&&(-1===(Gd=window.navigator.userAgent).indexOf("Android 2.")&&-1===Gd.indexOf("Android 4.0")||-1===Gd.indexOf("Mobile Safari")||-1!==Gd.indexOf("Chrome")||-1!==Gd.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Hd(e,t){Ud();var n=window.history;try{if(t){var a=Io({},n.state);a.key=Id(),n.replaceState(a,"",e)}else n.pushState({key:Sd(Rd())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Wd(e){Hd(e,!0)}var Kd={redirected:2,aborted:4,cancelled:8,duplicated:16};function Jd(e,t){return Zd(e,t,Kd.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Zd(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var Xd=["params","query","hash"];function Yd(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function ep(e,t){return Yd(e)&&e._isRouter&&(null==t||e.type===t)}function tp(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}function np(e,t){return ap(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function ap(e){return Array.prototype.concat.apply([],e)}var ip="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function sp(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var rp=function(e,t){this.router=e,this.base=function(e){if(!e)if(_d){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Go,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function op(e,t,n,a){var i=np(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=vd.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return ap(a?i.reverse():i)}function dp(e,t){if(t)return function(){return e.apply(t,arguments)}}rp.prototype.listen=function(e){this.cb=e},rp.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},rp.prototype.onError=function(e){this.errorCbs.push(e)},rp.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(ep(e,Kd.redirected)&&s===Go||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},rp.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!ep(e)&&Yd(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},d=e.matched.length-1,p=i.matched.length-1;if(Wo(e,i)&&d===p&&e.matched[d]===i.matched[p])return this.ensureURL(),e.hash&&Bd(this.router,i,e,!1),o(((r=Zd(s=i,e,Kd.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var u,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),c=l.updated,y=l.deactivated,m=l.activated,T=[].concat(function(e){return op(e,"beforeRouteLeave",dp,!0)}(y),this.router.beforeHooks,function(e){return op(e,"beforeRouteUpdate",dp)}(c),m.map((function(e){return e.beforeEnter})),(u=m,function(e,t,n){var a=!1,i=0,s=null;np(u,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var d,p=sp((function(t){var a;((a=t).__esModule||ip&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:vd.extend(t),r.components[o]=t,--i<=0&&n()})),u=sp((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=Yd(e)?e:new Error(t),n(s))}));try{d=e(p,u)}catch(e){u(e)}if(d)if("function"==typeof d.then)d.then(p,u);else{var l=d.component;l&&"function"==typeof l.then&&l.then(p,u)}}})),a||n()})),f=function(t,n){if(a.pending!==e)return o(Jd(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return Zd(e,t,Kd.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):Yd(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return Zd(e,t,Kd.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return Xd.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};tp(T,f,(function(){var n=function(e){return op(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(m);tp(n.concat(a.router.resolveHooks),f,(function(){if(a.pending!==e)return o(Jd(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Jo(e)}))}))}))},rp.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},rp.prototype.setupListeners=function(){},rp.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Go,this.pending=null};var pp=function(e){function t(t,n){e.call(this,t,n),this._startLocation=up(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Qd&&n;a&&this.listeners.push(Vd());var i=function(){var n=e.current,i=up(e.base);e.current===Go&&i===e._startLocation||e.transitionTo(i,(function(e){a&&Bd(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Hd(ed(a.base+e.fullPath)),Bd(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Wd(ed(a.base+e.fullPath)),Bd(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(up(this.base)!==this.current.fullPath){var t=ed(this.base+this.current.fullPath);e?Hd(t):Wd(t)}},t.prototype.getCurrentLocation=function(){return up(this.base)},t}(rp);function up(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(ed(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var lp=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=up(e);if(!/^\/#/.test(t))return window.location.replace(ed(e+"/#"+t)),!0}(this.base)||cp()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Qd&&t;n&&this.listeners.push(Vd());var a=function(){var t=e.current;cp()&&e.transitionTo(yp(),(function(a){n&&Bd(e.router,a,t,!0),Qd||fp(a.fullPath)}))},i=Qd?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Tp(e.fullPath),Bd(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){fp(e.fullPath),Bd(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;yp()!==t&&(e?Tp(t):fp(t))},t.prototype.getCurrentLocation=function(){return yp()},t}(rp);function cp(){var e=yp();return"/"===e.charAt(0)||(fp("/"+e),!1)}function yp(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function mp(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function Tp(e){Qd?Hd(mp(e)):window.location.hash=e}function fp(e){Qd?Wd(mp(e)):window.location.replace(mp(e))}var hp=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){ep(e,Kd.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(rp),bp=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=qd(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Qd&&!1!==e.fallback,this.fallback&&(t="hash"),_d||(t="abstract"),this.mode=t,t){case"history":this.history=new pp(this,e.base);break;case"hash":this.history=new lp(this,e.base,this.fallback);break;case"abstract":this.history=new hp(this,e.base)}},vp={currentRoute:{configurable:!0}};bp.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},vp.currentRoute.get=function(){return this.history&&this.history.current},bp.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof pp||n instanceof lp){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Qd&&i&&"fullPath"in e&&Bd(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},bp.prototype.beforeEach=function(e){return Cp(this.beforeHooks,e)},bp.prototype.beforeResolve=function(e){return Cp(this.resolveHooks,e)},bp.prototype.afterEach=function(e){return Cp(this.afterHooks,e)},bp.prototype.onReady=function(e,t){this.history.onReady(e,t)},bp.prototype.onError=function(e){this.history.onError(e)},bp.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},bp.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},bp.prototype.go=function(e){this.history.go(e)},bp.prototype.back=function(){this.go(-1)},bp.prototype.forward=function(){this.go(1)},bp.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},bp.prototype.resolve=function(e,t,n){var a=bd(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?ed(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},bp.prototype.getRoutes=function(){return this.matcher.getRoutes()},bp.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Go&&this.history.transitionTo(this.history.getCurrentLocation())},bp.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Go&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(bp.prototype,vp);var gp=bp;function Cp(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}bp.install=function e(t){if(!e.installed||vd!==t){e.installed=!0,vd=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Zo),t.component("RouterLink",Cd);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},bp.version="3.6.5",bp.isNavigationFailure=ep,bp.NavigationFailureType=Kd,bp.START_LOCATION=Go,_d&&window.Vue&&window.Vue.use(bp);var kp=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function Pp(e,t,n,a,i,s,r,o){var d,p="function"==typeof e?e.options:e;if(t&&(p.render=t,p.staticRenderFns=n,p._compiled=!0),a&&(p.functional=!0),s&&(p._scopeId="data-v-"+s),r?(d=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},p._ssrRegister=d):i&&(d=o?function(){i.call(this,(p.functional?this.parent:this).$root.$options.shadowRoot)}:i),d)if(p.functional){p._injectStyles=d;var u=p.render;p.render=function(e,t){return d.call(t),u(e,t)}}else{var l=p.beforeCreate;p.beforeCreate=l?[].concat(l,d):[d]}return{exports:e,options:p}}kp._withStripped=!0,n(838);const _p=Pp({},kp,[],!1,null,null,null).exports;var wp=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};wp._withStripped=!0;var Ap=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Ap._withStripped=!0;const Mp=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}'),qp=Pp({data:function(){return{repository:Mp.cj,name:Mp.u2}},methods:{openLink(e){window.open(e,"_blank")}}},Ap,[],!1,null,null,null).exports;var xp=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};xp._withStripped=!0;const Fp=Pp({},xp,[],!1,null,null,null).exports;var Rp=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Rp._withStripped=!0;var Ep=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};Ep._withStripped=!0;const Ip={components:{MemberSection:Pp({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Ep,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},Sp=Pp(Ip,Rp,[],!1,null,null,null).exports;var Op=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};Op._withStripped=!0;var Vp=Pp({components:{Member:Sp},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Op,[],!1,null,null,null);const Bp=Pp({components:{Member:Sp,MemberSet:Vp.exports,HeaderBar:Fp,FooterBar:qp},props:{json:{type:Object,default:()=>new Object}}},wp,[],!1,null,null,null).exports;var Up=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};Up._withStripped=!0;var Dp=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};Dp._withStripped=!0;var $p=Pp({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Dp,[],!1,null,null,null);const Np=Pp({components:{Branch:$p.exports,FooterBar:qp},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Up,[],!1,null,null,null).exports;Hn.use(gp);const Lp={"contracts/collateral/coinbase/MocCACoinbase.sol:MocCACoinbase":{source:"contracts/collateral/coinbase/MocCACoinbase.sol",name:"MocCACoinbase",title:"MocCACoinbase: Moc Collateral Asset Coinbase",notice:"Moc protocol implementation using network Coinbase as Collateral Asset",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TCMinted(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCMinted",type:"event"},"TCRedeemed(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCRedeemed",type:"event"},"TCSwappedForTP(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCSwappedForTP",type:"event"},"TCandTPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCandTPMinted",type:"event"},"TCandTPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCandTPRedeemed",type:"event"},"TPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPMinted",type:"event"},"TPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPRedeemed",type:"event"},"TPSwappedForTC(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPSwappedForTC",type:"event"},"TPSwappedForTP(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tpFrom_",type:"address"},{indexed:!1,internalType:"address",name:"tpTo_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTPfrom_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTPto_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPSwappedForTP",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"int256",name:"tcAvailableToRedeem",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize(((address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256),address,address,address,uint256,address))":{inputs:[{components:[{components:[{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract",params:{initializeCoreParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"}],name:"mintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token"},"mintTCViaVendor(uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTCandTP(address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPViaVendor(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends coinbase as Collateral Asset and receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPto(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPtoViaVendor(address,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCto(uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token"},"mintTCtoViaVendor(uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTP(address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"}],name:"mintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and receives Pegged Token"},"mintTPViaVendor(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTPto(address,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and recipient receives Pegged Token"},"mintTPtoViaVendor(address,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends coinbase as Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that the sender expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to the sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and receives coinbase as Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that the sender expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to the sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and receives coinbase as Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to the `recipient_`",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to the `recipient_`",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token to redeem"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token to redeem"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and receives Pegged Token"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTCforTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and recipient receives Pegged Token"},"swapTCforTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTC(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and receives Collateral Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and recipient receives Collateral Token"},"swapTPforTCtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTP(address,address,uint256,uint256)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and receives another one"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPViaVendor(address,address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPto(address,address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and recipient receives another one"},"swapTPforTPtoViaVendor(address,address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/collateral/rc20/MocCARC20.sol:MocCARC20":{source:"contracts/collateral/rc20/MocCARC20.sol",name:"MocCARC20",title:"MocCARC20: Moc Collateral Asset RC20",notice:"Moc protocol implementation using a RC20 as Collateral Asset.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TCMinted(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCMinted",type:"event"},"TCRedeemed(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCRedeemed",type:"event"},"TCSwappedForTP(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCSwappedForTP",type:"event"},"TCandTPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCandTPMinted",type:"event"},"TCandTPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCandTPRedeemed",type:"event"},"TPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPMinted",type:"event"},"TPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPRedeemed",type:"event"},"TPSwappedForTC(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPSwappedForTC",type:"event"},"TPSwappedForTP(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tpFrom_",type:"address"},{indexed:!1,internalType:"address",name:"tpTo_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTPfrom_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTPto_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPSwappedForTP",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acToken()":{inputs:[],name:"acToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"int256",name:"tcAvailableToRedeem",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize((((address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256),address,address,address,uint256,address),address))":{inputs:[{components:[{components:[{components:[{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams",type:"tuple"},{internalType:"address",name:"acTokenAddress",type:"address"}],internalType:"struct MocCARC20.InitializeParams",name:"initializeParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      acTokenAddress Collateral Asset Token contract address      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract",params:{initializeParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and receives Collateral Token Requires prior sender approval of Collateral Asset to this contract "},"mintTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract"},"mintTCandTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends Collateral Asset and receives Collateral Token and Pegged Token  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends Collateral Asset and receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  Requires prior sender approval of Collateral Asset to this contract"},"mintTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTC",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and receives Pegged Token Requires prior sender approval of Collateral Asset to this contract "},"mintTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and recipient receives Pegged Token Requires prior sender approval of Collateral Asset to this contract "},"mintTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{qACtotalNeeded:"amount of AC used to mint qTP",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that the sender expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to the sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and receives coinbase as Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that the sender expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to the sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and receives coinbase as Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to the `recipient_`",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to the `recipient_`",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token to redeem"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token to redeem"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"refreshACBalance()":{inputs:[],name:"refreshACBalance",outputs:[],stateMutability:"nonpayable",type:"function",details:"Intended to be use as notification after an RC20 AC transfer to this contract",notice:"Refreshes the AC holdings for the Bucket"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and receives Pegged Token"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTCforTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and recipient receives Pegged Token"},"swapTCforTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTC_:"amount of Collateral Token to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends Collateral Token and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTC(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and receives Collateral Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and recipient receives Collateral Token"},"swapTPforTCtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTCMinted:"amount of Collateral Token minted"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTP(address,address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and receives another one"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPViaVendor(address,address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPto(address,address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and recipient receives another one"},"swapTPforTPtoViaVendor(address,address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{qACFee:"amount of AC used to pay fee",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPMinted:"amount of Pegged Token minted"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/collateral/rc20/MocCARC20Deferred.sol:MocCARC20Deferred":{source:"contracts/collateral/rc20/MocCARC20Deferred.sol",name:"MocCARC20Deferred",title:"MocCARC20Deferred: Moc Collateral Asset RC20 with deferred operations",notice:"Moc protocol implementation using a RC20 as Collateral Asset.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acToken()":{inputs:[],name:"acToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"int256",name:"tcAvailableToRedeem",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize((((address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256),address,address,address,uint256,address),address,address))":{inputs:[{components:[{components:[{components:[{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams",type:"tuple"},{internalType:"address",name:"acTokenAddress",type:"address"},{internalType:"address",name:"mocQueue",type:"address"}],internalType:"struct MocCARC20Deferred.InitializeParams",name:"initializeParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      acTokenAddress Collateral Asset Token contract address      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract",params:{initializeParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token Requires prior sender approval of Collateral Asset to this contract "},"mintTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract"},"mintTCandTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token and Pegged Token  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  Requires prior sender approval of Collateral Asset to this contract"},"mintTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"mintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Pegged Token Requires prior sender approval of Collateral Asset to this contract"},"mintTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"mintTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Pegged Token Requires prior sender approval of Collateral Asset to this contract"},"mintTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"contract MocQueue",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that the sender expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"refreshACBalance()":{inputs:[],name:"refreshACBalance",outputs:[],stateMutability:"nonpayable",type:"function",details:"Intended to be use as notification after an RC20 AC transfer to this contract",notice:"Refreshes the AC holdings for the Bucket"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address",name:"mocQueue_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueue_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and receives Pegged Token."},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that the sender expects to receive",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and receives Pegged Token.  `vendor_` receives a markup in Fee Token if possible or in qAC if not."},"swapTCforTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"Address who receives the Pegged Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and recipient receives Pegged Token."},"swapTCforTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"Address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"Address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and recipient receives Pegged Token.  `vendor_` receives a markup in Fee Token if possible or in qAC if not."},"swapTPforTC(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives Collateral Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that the sender expects to receive",qTP_:"amount of owned Pegged Token to swap",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token"},"swapTPforTCtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTCtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTP(address,address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives another one"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPViaVendor(address,address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that the sender expects to receive",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPto(address,address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one"},"swapTPforTPtoViaVendor(address,address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTPtoViaVendor",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocBaseBucket.sol:MocBaseBucket":{source:"contracts/core/MocBaseBucket.sol",name:"MocBaseBucket",title:"MocBaseBucket: Moc Collateral Bag",details:"Abstracts all rw operations on the main bucket and expose all calculations relative to its state.",notice:"MocBaseBucket holds Bucket Zero state, both for the Collateral Bag and PeggedTokens Items.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCommons.sol:MocCommons":{source:"contracts/core/MocCommons.sol",name:"MocCommons",title:"MocCommons",details:"To bypass the 24kb size limitation on MocCore we use MocCoreExpansion contract. Some functions  are implemented there and MocCore delegates calls to it. To achieve that, we need both to have the  exact same storage layout and be able to access the same common functions.  MocCommons contract serves as the last shared ancestor in the line of inheritance for them,  and all storage variables must be either declared here or in a parent contract.  Declaring variables after this point could result in storage collisions.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCore.sol:MocCore":{source:"contracts/core/MocCore.sol",name:"MocCore",title:"MocCore",notice:"MocCore nucleates all the basic MoC functionality and tool set. It allows Collateral asset aware contracts to implement the main mint/redeem operations.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"int256",name:"tcAvailableToRedeem",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCoreExpansion.sol:MocCoreExpansion":{source:"contracts/core/MocCoreExpansion.sol",name:"MocCoreExpansion",title:"MocCoreExpansion",details:"IMPORTANT NOTES:  1. MocCore and MocCoreExpansion must have always the same storage layout to avoid collisions  2. Because MocCore is upgradeable and delegates calls to MocCoreExpansion, it cannot be upgradeable because      a proxy contract cannot delegate calls to another proxy contract. So, for any MocCoreExpansion upgrade      you must deploy a new implementation and set it to MocCore.",notice:"This contract is used as an expansion of MocCore because 24kb size limitation  MocCore delegate some function calls to it.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is called by MocCore contract using it's context with delegate call  Checks done there:  -  onlyAuthorizedChanger: the caller must have governance authorization.tpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements:  - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is called by MocCore contract using it's context with delegate call  Checks done there:  -  onlyAuthorizedChanger: the caller must have governance authorization.tpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTPTo(address,address,address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"sender_",type:"address"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"uint256",name:"mocACBalance",type:"uint256"}],name:"liqRedeemTPTo",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"This function is called by MocCore contract using it's context with delegate call  The equivalent AC given the liquidation frozen price(qACRedeemed) is transferred  to the `recipient_` by MocCore contract  Checks done there:  -  notPaused: the contract must be unpaused",params:{recipient_:"address who receives the AC",sender_:"address owner of the TP to be redeemed",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPto((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"i_ Pegged Token index      qTP_ amount of Pegged Token to mint      qACmax_ maximum amount of Collateral Asset that can be spent      sender_ address who sends Collateral Asset      recipient_ address who receives the Collateral Token and Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is applied",params:{params_:"mint TC and TP function parameters"},returns:{feeCalcs:"platform fee detail breakdown",qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTCtoMint:"amount of Collateral Token minted"},notice:"mint Collateral Token and Pegged Token in exchange for Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPto((address,uint256,uint256,uint256,address,address,address),address)":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"},{internalType:"address",name:"operator",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"i_ Pegged Token index      qTC_ amount of Collateral Token to redeem      qTP_ maximum amount of Pegged Token to redeem      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive      sender_ address who sends Collateral Token and Pegged Token      recipient_ address who receives the Collateral Asset      vendor_ address who receives a markup. If its address(0) no markup is applied",params:{params_:"redeem TC and TP function parameters"},returns:{feeCalcs:"platform fee detail breakdown",qACtoRedeem:"amount of AC sent to `recipient_`",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoRedeem:"amount of Pegged Token redeemed"},notice:"redeem Collateral Asset in exchange for Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPto((address,uint256,uint256,uint256,address,address,address),address)":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"},{internalType:"address",name:"operator",type:"address"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calli_ Pegged Token index      qTC_ amount of Collateral Token to swap      qTPmin_ minimum amount of Pegged Token Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Collateral Token      recipient_ address who receives the Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TC for TP function parameters"},returns:{qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoMint:"amount of Pegged Token minted"},notice:"swap Collateral Token to Pegged Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCto((address,uint256,uint256,uint256,address,address,address),address)":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"},{internalType:"address",name:"operator",type:"address"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calli_ Pegged Token index      qTP_ amount Pegged Token to swap      qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Pegged Token      recipient_ address who receives Collateral Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TP for TC function parameters"},returns:{feeCalcs:"struct with:",qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTCtoMint:"amount of Collateral Token minted"},notice:"swap Pegged Token to Collateral Token"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPto((address,address,uint256,uint256,uint256,address,address,address),address)":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"},{internalType:"address",name:"operator",type:"address"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calliFrom_ owned Pegged Token index      iTo_ target Pegged Token index      qTP_ amount of owned Pegged Token to swap      qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Pegged Token      recipient_ address who receives the target Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TP for TP function parameters"},returns:{feeCalcs:"struct with:",qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoMint:"amount of Pegged Token minted"},notice:"swap Pegged Token to another one  This operation is done without checking coverage unless the target coverage for  received Pegged Token is greater than the Pegged Token sent"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCoreShared.sol:MocCoreShared":{source:"contracts/core/MocCoreShared.sol",name:"MocCoreShared",title:"MocCoreShared",details:"This abstract contracts, is a just a middle step between MocCore and RC20 and Coinbase implementation, as they share all redeem methods and events.",notice:"Extends MocCore, with redeem external shared redeem functions and definitions.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TCMinted(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCMinted",type:"event"},"TCRedeemed(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCRedeemed",type:"event"},"TCSwappedForTP(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCSwappedForTP",type:"event"},"TCandTPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCandTPMinted",type:"event"},"TCandTPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TCandTPRedeemed",type:"event"},"TPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPMinted",type:"event"},"TPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPRedeemed",type:"event"},"TPSwappedForTC(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPSwappedForTC",type:"event"},"TPSwappedForTP(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tpFrom_",type:"address"},{indexed:!1,internalType:"address",name:"tpTo_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTPfrom_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTPto_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"}],name:"TPSwappedForTP",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"int256",name:"tcAvailableToRedeem",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to sender"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqRedeemTPto(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTC(uint256,uint256)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and receives Collateral Asset"},"redeemTCViaVendor(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTC_:"amount of Collateral Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that the sender expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to the sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and receives coinbase as Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPViaVendor(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that the sender expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to the sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and receives coinbase as Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPto(address,uint256,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to the `recipient_`",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPtoViaVendor(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"maximum amount of Collateral Token to redeem",qTP_:"maximum amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to the `recipient_`",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead",qTPRedeemed:"amount of Pegged Token redeemed"},notice:"caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCto(uint256,uint256,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTCto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and recipient receives Collateral Asset"},"redeemTCtoViaVendor(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTP(address,uint256,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token to redeem"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and receives Collateral Asset"},"redeemTPViaVendor(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that sender expects to receive",qTP_:"amount of Pegged Token to redeem",tp_:"Pegged Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to sender",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTPto(address,uint256,uint256,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"}],name:"redeemTPto",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token to redeem"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and recipient receives Collateral Asset"},"redeemTPtoViaVendor(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTPtoViaVendor",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token to redeem",vendor_:"address who receives a markup"},returns:{qACRedeemed:"amount of AC sent to 'recipient_'",qFeeToken:"amount of Fee Token used by sender to pay fees. 0 if qAC is used instead"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocEma.sol:MocEma":{source:"contracts/core/MocEma.sol",name:"MocEma",title:"MocEma: Exponential Moving Average",details:"More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing",notice:"Moc Ema, provides a set of methods that allows to calculate and track Exponential Moving Average for each of the pegged Tokens.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/governance/Governed.sol:Governed":{source:"contracts/governance/Governed.sol",name:"Governed",title:"Governed",details:"This contract is not usable on its own since it does not have any _productive useful_ behavior The only purpose of this contract is to define some useful modifiers and functions to be used on the governance aspect of the child contract",notice:"Base contract to be inherited by governed contracts",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"}}},"contracts/governance/MocUpgradable.sol:MocUpgradable":{source:"contracts/governance/MocUpgradable.sol",name:"MocUpgradable",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/governance/Stoppable.sol:Stoppable":{source:"contracts/governance/Stoppable.sol",name:"Stoppable",title:"Stoppable",details:"This contract was heavily based on the _Pausable_ contract of openzeppelin-eth but it was modified in order to being able to turn on and off its stoppability",notice:"Allow a contract to be paused through the stopper subsystem. This contracts is able to disable the stoppability feature through governance.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"}}},"contracts/governance/changerTemplates/AddPeggedTokenChangerTemplate.sol:AddPeggedTokenChangerTemplate":{source:"contracts/governance/changerTemplates/AddPeggedTokenChangerTemplate.sol",name:"AddPeggedTokenChangerTemplate",title:"AddPeggedTokenChangerTemplate",details:"This template only considers adding MocRC20, they are governed and use EnumerableAccessControl for roles. For any other type of Pegged Token it must be modified to achieve similar validations",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus governance system. It allows the addition of a new Pegged Token to the system.",constructor:{inputs:[{internalType:"contract MocCore",name:"mocCore_",type:"address"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"getPeggedTokenParams()":{inputs:[],name:"getPeggedTokenParams",outputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns the Pegged Token Params configurations that's going to be added"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCore",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/governance/changerTemplates/EditPeggedTokenChangerTemplate.sol:EditPeggedTokenChangerTemplate":{source:"contracts/governance/changerTemplates/EditPeggedTokenChangerTemplate.sol",name:"EditPeggedTokenChangerTemplate",title:"EditPeggedTokenChangerTemplate",details:"IMPORTANT: This template provides a basic framework for Pegged Token params editions, but it's not intended to be use out of the box. Depending on the combination of params you need to edit, you'll need to generate new methods, disable others and adjust the  `PARAMS_CHANGED` config. In this example, only the priceProvider address is used as showcase. Also please notice that params values, are not verify on the target contract, so it's desirable that the changer itself do it. See `AditPeggedTokenChangerTemplate.sol` for reference.",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus  governance system. It allows the edition of an existent Pegged Token to the system.",constructor:{inputs:[{internalType:"contract MocCore",name:"mocCore_",type:"address"},{internalType:"contract IMocRC20",name:"tpToEdit_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"getPeggedTokenParams()":{inputs:[],name:"getPeggedTokenParams",outputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns the Pegged Token Params configurations that's going to be edited"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCore",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paramSet()":{inputs:[],name:"paramSet",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setPriceProvider(address)":{inputs:[{internalType:"address",name:"priceProvider_",type:"address"}],name:"setPriceProvider",outputs:[],stateMutability:"nonpayable",type:"function",params:{priceProvider_:"new pegged token price provider"},notice:"contract initializer"},"tpToEdit()":{inputs:[],name:"tpToEdit",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/governance/changerTemplates/GovernanceChangerTemplate.sol:GovernanceChangerTemplate":{source:"contracts/governance/changerTemplates/GovernanceChangerTemplate.sol",name:"GovernanceChangerTemplate",title:"GovernanceChangerTemplate",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus  governance system.",constructor:{inputs:[{internalType:"contract Governed",name:"governed_",type:"address"},{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"governed()":{inputs:[],name:"governed",outputs:[{internalType:"contract Governed",name:"",type:"address"}],stateMutability:"view",type:"function"},"newGovernor()":{inputs:[],name:"newGovernor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/governance/changerTemplates/UpgraderUUPSChangerTemplate.sol:UpgraderUUPSChangerTemplate":{source:"contracts/governance/changerTemplates/UpgraderUUPSChangerTemplate.sol",name:"UpgraderUUPSChangerTemplate",title:"UpgraderUUPSChangerTemplate",notice:"This contract is a ChangeContract intended to be used when upgrading a MOC UUPS contract, through the Moc upgradeability system. This doesn't initialize the upgraded contract, that should be done extending this one or taking it as a guide",methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture IMPORTANT: This function should not be overridden, you should only redefine _beforeUpgrade and _afterUpgrade methods to use this template",notice:"Execute the changes."},"newImplementation()":{inputs:[],name:"newImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxy()":{inputs:[],name:"proxy",outputs:[{internalType:"contract UUPSUpgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IChangeContract.sol:IChangeContract":{source:"contracts/interfaces/IChangeContract.sol",name:"IChangeContract",title:"IChangeContract",details:"If you plan to do some changes to a system governed by this project you should write a contract that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance system is fully in place.",notice:"This interface is the one used by the governance system.",methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Override this function with a recipe of the changes to be done when this ChangeContract is executed"}}},"contracts/interfaces/IDataProvider.sol:IDataProvider":{source:"contracts/interfaces/IDataProvider.sol",name:"IDataProvider",title:"IDataProvider",details:"https://github.com/money-on-chain/Amphiraos-Oracle",notice:"Amphiraos-Oracle Interface for peeking the data from an oracle",methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"data",type:"bytes32"},{internalType:"bool",name:"valid",type:"bool"}],stateMutability:"view",type:"function",params:{data:"peeked",valid:"true if the data is valid"},notice:"returns the given `data` if `valid`"}}},"contracts/interfaces/IDispatcher.sol:IDispatcher":{source:"contracts/interfaces/IDispatcher.sol",name:"IDispatcher",title:"IDispatcher TODO: add doc",methods:{"getCombinedCglb(uint256)":{inputs:[{internalType:"uint256",name:"localCglb_",type:"uint256"}],name:"getCombinedCglb",outputs:[{internalType:"uint256",name:"combinedCglb",type:"uint256"}],stateMutability:"view",type:"function"},"getRealTCAvailableToRedeem(uint256)":{inputs:[{internalType:"uint256",name:"localTCAvailableToRedeem_",type:"uint256"}],name:"getRealTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"realTCAvailableToRedeem_",type:"uint256"}],stateMutability:"view",type:"function"},"getRealTPAvailableToMint(uint256)":{inputs:[{internalType:"uint256",name:"localTPAvailableToMint_",type:"uint256"}],name:"getRealTPAvailableToMint",outputs:[{internalType:"uint256",name:"realTCAvailableToMint_",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IGovernor.sol:IGovernor":{source:"contracts/interfaces/IGovernor.sol",name:"IGovernor",title:"IGovernor",details:"This interface **MUST** be compatible with the corresponding Governance instance used on Production, from https://github.com/money-on-chain/Areopagus-Governance",notice:"Governor interface. This functions should be overwritten to enable the communication with the rest of the system",methods:{"executeChange(address)":{inputs:[{internalType:"contract IChangeContract",name:"changeContract_",type:"address"}],name:"executeChange",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function should be protected somehow to only execute changes that benefit the system. This decision process is independent of this architecture therefore is independent of this interface too",params:{changeContract_:"Address of the contract that will execute the changes"},notice:"Function to be called to make the changes described in changeContract"},"isAuthorizedChanger(address)":{inputs:[{internalType:"address",name:"changer_",type:"address"}],name:"isAuthorizedChanger",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{changer_:"Address of the contract that will execute the changes"},notice:"Returns whether this `changer_` is authorized to execute changes."}}},"contracts/interfaces/IMocRC20.sol:IMocRC20":{source:"contracts/interfaces/IMocRC20.sol",name:"IMocRC20",title:"IMocRC20",notice:"Base Moc ERC20 Token Interface: burn, mint. It can be both Pegs and Collateral Tokens.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. See {ERC20-_burn}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/interfaces/IPriceProvider.sol:IPriceProvider":{source:"contracts/interfaces/IPriceProvider.sol",name:"IPriceProvider",title:"IPriceFeed",details:"https://github.com/money-on-chain/Amphiraos-Oracle",notice:"Amphiraos-Oracle Interface for peeking the price of a given asset",methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"price",type:"bytes32"},{internalType:"bool",name:"valid",type:"bool"}],stateMutability:"view",type:"function",params:{price:"assetPrice",valid:"true if the price is valid"},notice:"returns the given `price` for the asset if `valid`"}}},"contracts/queue/MocQueue.sol:MocQueue":{source:"contracts/queue/MocQueue.sol",name:"MocQueue",title:"MocQueue: Allows queue Operation deferral execution processing",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"OperationError(uint256,bytes4,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"bytes4",name:"errorCode_",type:"bytes4"},{indexed:!1,internalType:"string",name:"msg_",type:"string"}],name:"OperationError",type:"event"},"OperationExecuted(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"executor",type:"address"},{indexed:!0,internalType:"uint256",name:"operId_",type:"uint256"}],name:"OperationExecuted",type:"event"},"OperationQueued(address,uint256,uint8)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"bucket_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"enum MocQueue.OperType",name:"operType_",type:"uint8"}],name:"OperationQueued",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"TCMinted(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCMinted",type:"event"},"TCRedeemed(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCRedeemed",type:"event"},"TCSwappedForTP(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCSwappedForTP",type:"event"},"TCandTPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCandTPMinted",type:"event"},"TCandTPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCandTPRedeemed",type:"event"},"TPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPMinted",type:"event"},"TPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPRedeemed",type:"event"},"TPSwappedForTC(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPSwappedForTC",type:"event"},"TPSwappedForTP(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tpFrom_",type:"address"},{indexed:!1,internalType:"address",name:"tpTo_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTPfrom_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTPto_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPSwappedForTP",type:"event"},"UnhandledError(uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"bytes",name:"reason_",type:"bytes"}],name:"UnhandledError",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MAX_OPER_PER_BATCH()":{inputs:[],name:"MAX_OPER_PER_BATCH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"execute(address)":{inputs:[{internalType:"address",name:"executionFeeRecipient",type:"address"}],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"does not revert on Operation failure, throws Process and Error events according to the Oper type and result",notice:"registered executors can process Operations in the queue"},"firstOperId()":{inputs:[],name:"firstOperId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{internalType:"address",name:"governor_",type:"address"},{internalType:"address",name:"pauser_",type:"address"},{internalType:"uint256",name:"minOperWaitingBlk_",type:"uint256"},{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isEmpty()":{inputs:[],name:"isEmpty",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue is empty"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"minOperWaitingBlk()":{inputs:[],name:"minOperWaitingBlk",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPExecFee()":{inputs:[],name:"mintTCandTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCARC20Deferred",name:"",type:"address"}],stateMutability:"view",type:"function"},"operIdCount()":{inputs:[],name:"operIdCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operationsMintTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTC",outputs:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsMintTCandTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTCandTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsMintTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTC",outputs:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTCandTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTCandTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTCforTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTCforTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTPforTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTPforTC",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTPforTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTPforTP",outputs:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"opersInfo(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"opersInfo",outputs:[{internalType:"enum MocQueue.OperType",name:"operType",type:"uint8"},{internalType:"uint248",name:"queuedBlk",type:"uint248"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"queueMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params",type:"tuple"}],name:"queueMintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params",type:"tuple"}],name:"queueMintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params",type:"tuple"}],name:"queueMintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params",type:"tuple"}],name:"queueRedeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params",type:"tuple"}],name:"queueRedeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params",type:"tuple"}],name:"queueRedeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params",type:"tuple"}],name:"queueSwapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params",type:"tuple"}],name:"queueSwapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params",type:"tuple"}],name:"queueSwapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"redeemTCandTPExecFee()":{inputs:[],name:"redeemTCandTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"registerBucket(address)":{inputs:[{internalType:"contract MocCARC20Deferred",name:"bucket",type:"address"}],name:"registerBucket",outputs:[],stateMutability:"nonpayable",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setMinOperWaitingBlk(uint256)":{inputs:[{internalType:"uint256",name:"minOperWaitingBlk_",type:"uint256"}],name:"setMinOperWaitingBlk",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue minimum operation waiting blocks",params:{minOperWaitingBlk_:"minimum amount of blocks an operation needs to remain in the queue before it can be executed"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"swapTCforTPExecFee()":{inputs:[],name:"swapTCforTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCExecFee()":{inputs:[],name:"swapTPforTCExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPExecFee()":{inputs:[],name:"swapTPforTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintExecFee()":{inputs:[],name:"tcMintExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemExecFee()":{inputs:[],name:"tcRedeemExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintExecFee()":{inputs:[],name:"tpMintExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemExecFee()":{inputs:[],name:"tpRedeemExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateExecutionFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"updateExecutionFees",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/queue/MocQueueExecFees.sol:MocQueueExecFees":{source:"contracts/queue/MocQueueExecFees.sol",name:"MocQueueExecFees",title:"MocQueue Execution Fee: Handles Queuing execution fees",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isEmpty()":{inputs:[],name:"isEmpty",outputs:[{internalType:"bool",name:"isEmpty",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue is empty"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"mintTCandTPExecFee()":{inputs:[],name:"mintTCandTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"redeemTCandTPExecFee()":{inputs:[],name:"redeemTCandTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"swapTCforTPExecFee()":{inputs:[],name:"swapTCforTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCExecFee()":{inputs:[],name:"swapTPforTCExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPExecFee()":{inputs:[],name:"swapTPforTPExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintExecFee()":{inputs:[],name:"tcMintExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemExecFee()":{inputs:[],name:"tcRedeemExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintExecFee()":{inputs:[],name:"tpMintExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemExecFee()":{inputs:[],name:"tpRedeemExecFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"updateExecutionFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"updateExecutionFees",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/tokens/MocRC20.sol:MocRC20":{source:"contracts/tokens/MocRC20.sol",name:"MocRC20",title:"MocRC20",details:"ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.",notice:"Base Moc ERC20 Token: burn, mint. It can be both Pegs and Collateral Tokens.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. * See {ERC20-_burn}. Requirements: - the caller must have the `BURNER_ROLE`."},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,address,address)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"admin_",type:"address"},{internalType:"contract IGovernor",name:"governor_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"See {__MocRC20_init}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferAllRoles(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"transferAllRoles",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants all `roles` to `account` while sender renounces to all ``role`` If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. - no one else must have any other role May emit a {RoleGranted x3, RoleRevoked x3} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/tokens/MocTC.sol:MocTC":{source:"contracts/tokens/MocTC.sol",name:"MocTC",title:"MocTC",details:"ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.",notice:"Base Moc  ERC20 Collateral Tokens: Allows burn, mint and pause.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event",details:"Emitted when the pause is triggered by `account`."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event",details:"Emitted when the pause is lifted by `account`."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. * See {ERC20-_burn}. Requirements: - the caller must have the `BURNER_ROLE`."},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,address,address)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"admin_",type:"address"},{internalType:"contract IGovernor",name:"governor_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `PAUSER_ROLE` to `admin` address. See {MocRC20-constructor}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Pauses the contract. See {ERC20PausableUpgradeable-_pause}. Requirements: - the caller must have the `PAUSER_ROLE`."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferAllRoles(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"transferAllRoles",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants all `roles` to `account` while sender renounces to all ``role``. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. - no one else must have any other role May emit a {RoleGranted x4, RoleRevoked x4} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/utils/MocAccessControlled.sol:MocAccessControlled":{source:"contracts/utils/MocAccessControlled.sol",name:"MocAccessControlled",title:"MocAccessControlled",details:"grant and revoke functions are overwritten so that they are also      compatible with governance authorization mechanism.",notice:"Extends Moc Upgradable capabilities, with access control capabilities",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/utils/MocHelper.sol:MocHelper":{source:"contracts/utils/MocHelper.sol",name:"MocHelper"},"contracts/utils/PriceProviderShifter.sol:PriceProviderShifter":{source:"contracts/utils/PriceProviderShifter.sol",name:"PriceProviderShifter",title:"PriceProviderShifter",details:"This simple contract, wraps a IPriceProvider and shift the returned price value in either direction.",constructor:{inputs:[{internalType:"contract IPriceProvider",name:"priceProvider_",type:"address"},{internalType:"int8",name:"shift_",type:"int8"}],stateMutability:"nonpayable",type:"constructor"},methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"price",type:"bytes32"},{internalType:"bool",name:"hasPrice",type:"bool"}],stateMutability:"view",type:"function",params:{price:"assetPrice",valid:"true if the price is valid"},notice:"returns the given `price` for the asset if `valid`"},"priceProvider()":{inputs:[],name:"priceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"shift()":{inputs:[],name:"shift",outputs:[{internalType:"int8",name:"",type:"int8"}],stateMutability:"view",type:"function"}}},"contracts/vendors/MocVendors.sol:MocVendors":{source:"contracts/vendors/MocVendors.sol",name:"MocVendors",title:"MocVendors",notice:"MocVendors allows a third-party to add a markup to all operations  A vendor can set a markup themselves or ask vendors guardian to do it on their behalf.  Considerations:  - Theres is not a markup limit or restriction  - The currency that the vendor receives is always the same that is used to pay fees(AC or Fee Token)  - A malicious vendor front running an operation increasing the markup is protected in some way      by the maximum (AC or Fee Token) that the user expect to spend(or de minimum that expect to receive)",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."},"VendorMarkupChanged(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"vendorAddress_",type:"address"},{indexed:!1,internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"VendorMarkupChanged",type:"event"}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize(address,address,address)":{inputs:[{internalType:"address",name:"vendorsGuardianAddress_",type:"address"},{internalType:"address",name:"governorAddress_",type:"address"},{internalType:"address",name:"pauserAddress_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{governorAddress_:"The address that will define when a change contract is authorized",pauserAddress_:"The address that is authorized to pause this contract",vendorsGuardianAddress_:"The address authorized to change a vendor's markup"},notice:"contract initializer"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setMarkup(uint256)":{inputs:[{internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"setMarkup",outputs:[],stateMutability:"nonpayable",type:"function",params:{newMarkup_:"new markup applied to vendor [PREC]"},notice:"vendor sets its own markup"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setVendorMarkup(address,uint256)":{inputs:[{internalType:"address",name:"vendorAddress_",type:"address"},{internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"setVendorMarkup",outputs:[],stateMutability:"nonpayable",type:"function",params:{newMarkup_:"new markup applied to vendor [PREC]",vendorAddress_:"vendor address to change markup"},notice:"guardian sets a vendor markup"},"setVendorsGuardianAddress(address)":{inputs:[{internalType:"address",name:"vendorsGuardianAddress_",type:"address"}],name:"setVendorsGuardianAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address which will be authorized to set a vendor markup.",params:{vendorsGuardianAddress_:"Address which will be authorized to set a vendor markup."}},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"vendorMarkup(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"vendorMarkup",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vendorsGuardianAddress()":{inputs:[],name:"vendorsGuardianAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}}};new Hn({el:"#app",router:new gp({routes:[{path:"/",component:Np,props:()=>({json:Lp})},{path:"*",component:Bp,props:e=>({json:Lp[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(_p)})})()})();