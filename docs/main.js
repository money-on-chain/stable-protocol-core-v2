/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={837:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(601),i=n.n(a),s=n(314),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},314:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var p=this[o][0];null!=p&&(r[p]=!0)}for(var u=0;u<e.length;u++){var d=[].concat(e[u]);a&&r[d[0]]||(void 0!==s&&(void 0===d[5]||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=s),n&&(d[2]?(d[1]="@media ".concat(d[2]," {").concat(d[1],"}"),d[2]=n):d[2]=n),i&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=i):d[4]="".concat(i)),t.push(d))}},t}},601:e=>{"use strict";e.exports=function(e){return e[1]}},884:(e,t,n)=>{var a=n(837);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(534).A)("2cbbc963",a,!1,{})},534:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{A:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,p=0,u=!1,d=function(){},l=null,c="data-vue-ssr-id",y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){u=n,l=i||{};var r=a(e,t);return f(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(p=s[o.id]).refs--,n.push(p)}for(t?f(r=a(e,t)):r=[],i=0;i<n.length;i++){var p;if(0===(p=n[i]).refs){for(var u=0;u<p.parts.length;u++)p.parts[u]();delete s[p.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(h(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(h(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function T(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function h(e){var t,n,a=document.querySelector("style["+c+'~="'+e.id+'"]');if(a){if(u)return d;a.parentNode.removeChild(a)}if(y){var i=p++;a=o||(o=T()),t=g.bind(null,a,i,!1),n=g.bind(null,a,i,!0)}else a=T(),t=C.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var b,v=(b=[],function(e,t){return b[e]=t,b.filter(Boolean).join("\n")});function g(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function C(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(c,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function s(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return"function"==typeof e}function p(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function d(e){return"[object Object]"===u.call(e)}function l(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function c(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function y(e){return null==e?"":Array.isArray(e)||d(e)&&e.toString===u?JSON.stringify(e,m,2):String(e)}function m(e,t){return t&&t.__v_isRef?t.value:t}function f(e){var t=parseFloat(e);return isNaN(t)?e:t}function T(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var h=T("slot,component",!0),b=T("key,ref,slot,slot-scope,is");function v(e,t){var n=e.length;if(n){if(t===e[n-1])return void(e.length=n-1);var a=e.indexOf(t);if(a>-1)return e.splice(a,1)}}var g=Object.prototype.hasOwnProperty;function C(e,t){return g.call(e,t)}function w(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var P=/-(\w)/g,k=w((function(e){return e.replace(P,(function(e,t){return t?t.toUpperCase():""}))})),M=w((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),_=/\B([A-Z])/g,A=w((function(e){return e.replace(_,"-$1").toLowerCase()})),x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function F(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function R(e,t){for(var n in t)e[n]=t[n];return e}function q(e){for(var t={},n=0;n<e.length;n++)e[n]&&R(t,e[n]);return t}function E(e,t,n){}var I=function(e,t,n){return!1},S=function(e){return e};function O(e,t){if(e===t)return!0;var n=p(e),a=p(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return O(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return O(e[n],t[n])}))}catch(e){return!1}}function U(e,t){for(var n=0;n<e.length;n++)if(O(e[n],t))return n;return-1}function D(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var B="data-server-rendered",$=["component","directive","filter"],L=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:E,parsePlatformTagName:S,mustUseProp:I,async:!0,_lifecycleHooks:L},z=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function j(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function V(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(z.source,".$_\\d]")),Q="__proto__"in{},H="undefined"!=typeof window,W=H&&window.navigator.userAgent.toLowerCase(),K=W&&/msie|trident/.test(W),J=W&&W.indexOf("msie 9.0")>0,Z=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var X=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var Y,ee=W&&W.match(/firefox\/(\d+)/),te={}.watch,ne=!1;if(H)try{var ae={};Object.defineProperty(ae,"passive",{get:function(){ne=!0}}),window.addEventListener("test-passive",null,ae)}catch(e){}var ie=function(){return void 0===Y&&(Y=!H&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),Y},se=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return"function"==typeof e&&/native code/.test(e.toString())}var oe,pe="undefined"!=typeof Symbol&&re(Symbol)&&"undefined"!=typeof Reflect&&re(Reflect.ownKeys);oe="undefined"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ue=null;function de(e){void 0===e&&(e=null),e||ue&&ue._scope.off(),ue=e,e&&e._scope.on()}var le=function(){function e(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),ce=function(e){void 0===e&&(e="");var t=new le;return t.text=e,t.isComment=!0,t};function ye(e){return new le(void 0,void 0,void 0,String(e))}function me(e){var t=new le(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}"function"==typeof SuppressedError&&SuppressedError;var fe=0,Te=[],he=function(){for(var e=0;e<Te.length;e++){var t=Te[e];t.subs=t.subs.filter((function(e){return e})),t._pending=!1}Te.length=0},be=function(){function e(){this._pending=!1,this.id=fe++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,Te.push(this))},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.filter((function(e){return e})),n=0,a=t.length;n<a;n++)t[n].update()},e}();be.target=null;var ve=[];function ge(e){ve.push(e),be.target=e}function Ce(){ve.pop(),be.target=ve[ve.length-1]}var we=Array.prototype,Pe=Object.create(we);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=we[e];V(Pe,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var ke=Object.getOwnPropertyNames(Pe),Me={},_e=!0;function Ae(e){_e=e}var xe={notify:E,depend:E,addSub:E,removeSub:E},Fe=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?xe:new be,this.vmCount=0,V(e,"__ob__",this),t(e)){if(!a)if(Q)e.__proto__=Pe;else for(var i=0,s=ke.length;i<s;i++)V(e,o=ke[i],Pe[o]);n||this.observeArray(e)}else{var r=Object.keys(e);for(i=0;i<r.length;i++){var o;qe(e,o=r[i],Me,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Re(e[t],!1,this.mock)},e}();function Re(e,n,a){return e&&C(e,"__ob__")&&e.__ob__ instanceof Fe?e.__ob__:!_e||!a&&ie()||!t(e)&&!d(e)||!Object.isExtensible(e)||e.__v_skip||De(e)||e instanceof le?void 0:new Fe(e,n,a)}function qe(e,n,a,i,s,r,o){void 0===o&&(o=!1);var p=new be,u=Object.getOwnPropertyDescriptor(e,n);if(!u||!1!==u.configurable){var d=u&&u.get,l=u&&u.set;d&&!l||a!==Me&&2!==arguments.length||(a=e[n]);var c=s?a&&a.__ob__:Re(a,!1,r);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=d?d.call(e):a;return be.target&&(p.depend(),c&&(c.dep.depend(),t(n)&&Se(n))),De(n)&&!s?n.value:n},set:function(t){var n,i,o=d?d.call(e):a;if((n=o)===(i=t)?0===n&&1/n!=1/i:n==n||i==i){if(l)l.call(e,t);else{if(d)return;if(!s&&De(o)&&!De(t))return void(o.value=t);a=t}c=s?t&&t.__ob__:Re(t,!1,r),p.notify()}}}),p}}function Ee(e,n,a){if(!Ue(e)){var i=e.__ob__;return t(e)&&l(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&Re(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(qe(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Ie(e,n){if(t(e)&&l(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||Ue(e)||C(e,n)&&(delete e[n],a&&a.dep.notify())}}function Se(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Se(n)}function Oe(e){return function(e,t){Ue(e)||Re(e,t,ie())}(e,!0),V(e,"__v_isShallow",!0),e}function Ue(e){return!(!e||!e.__v_isReadonly)}function De(e){return!(!e||!0!==e.__v_isRef)}function Be(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(De(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];De(a)&&!De(e)?a.value=e:t[n]=e}})}var $e=w((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function Le(e,n){function a(){var e=a.fns;if(!t(e))return Jt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),s=0;s<i.length;s++)Jt(i[s],null,arguments,n,"v-on handler")}return a.fns=e,a}function Ne(e,t,n,i,r,o){var p,u,d,l;for(p in e)u=e[p],d=t[p],l=$e(p),a(u)||(a(d)?(a(u.fns)&&(u=e[p]=Le(u,o)),s(l.once)&&(u=e[p]=r(l.name,u,l.capture)),n(l.name,u,l.capture,l.passive,l.params)):u!==d&&(d.fns=u,e[p]=d));for(p in t)a(e[p])&&i((l=$e(p)).name,t[p],l.capture)}function ze(e,t,n){var r;e instanceof le&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function p(){n.apply(this,arguments),v(r.fns,p)}a(o)?r=Le([p]):i(o.fns)&&s(o.merged)?(r=o).fns.push(p):r=Le([o,p]),r.merged=!0,e[t]=r}function je(e,t,n,a,s){if(i(t)){if(C(t,n))return e[n]=t[n],s||delete t[n],!0;if(C(t,a))return e[n]=t[a],s||delete t[a],!0}return!1}function Ve(e){return r(e)?[ye(e)]:t(e)?Qe(e):void 0}function Ge(e){return i(e)&&i(e.text)&&!1===e.isComment}function Qe(e,n){var o,p,u,d,l=[];for(o=0;o<e.length;o++)a(p=e[o])||"boolean"==typeof p||(d=l[u=l.length-1],t(p)?p.length>0&&(Ge((p=Qe(p,"".concat(n||"","_").concat(o)))[0])&&Ge(d)&&(l[u]=ye(d.text+p[0].text),p.shift()),l.push.apply(l,p)):r(p)?Ge(d)?l[u]=ye(d.text+p):""!==p&&l.push(ye(p)):Ge(p)&&Ge(d)?l[u]=ye(d.text+p.text):(s(e._isVList)&&i(p.tag)&&a(p.key)&&i(n)&&(p.key="__vlist".concat(n,"_").concat(o,"__")),l.push(p)));return l}var He=1,We=2;function Ke(e,n,a,u,d,l){return(t(a)||r(a))&&(d=u,u=a,a=void 0),s(l)&&(d=We),function(e,n,a,s,r){if(i(a)&&i(a.__ob__))return ce();if(i(a)&&i(a.is)&&(n=a.is),!n)return ce();var u,d;if(t(s)&&o(s[0])&&((a=a||{}).scopedSlots={default:s[0]},s.length=0),r===We?s=Ve(s):r===He&&(s=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof n){var l=void 0;d=e.$vnode&&e.$vnode.ns||N.getTagNamespace(n),u=N.isReservedTag(n)?new le(N.parsePlatformTagName(n),a,s,void 0,void 0,e):a&&a.pre||!i(l=jn(e.$options,"components",n))?new le(n,a,s,void 0,void 0,e):In(l,a,e,s,n)}else u=In(n,a,e,s);return t(u)?u:i(u)?(i(d)&&Je(u,d),i(a)&&function(e){p(e.style)&&cn(e.style),p(e.class)&&cn(e.class)}(a),u):ce()}(e,n,a,u,d)}function Je(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var r=0,o=e.children.length;r<o;r++){var p=e.children[r];i(p.tag)&&(a(p.ns)||s(n)&&"svg"!==p.tag)&&Je(p,t,n)}}function Ze(e,n){var a,s,r,o,u=null;if(t(e)||"string"==typeof e)for(u=new Array(e.length),a=0,s=e.length;a<s;a++)u[a]=n(e[a],a);else if("number"==typeof e)for(u=new Array(e),a=0;a<e;a++)u[a]=n(a+1,a);else if(p(e))if(pe&&e[Symbol.iterator]){u=[];for(var d=e[Symbol.iterator](),l=d.next();!l.done;)u.push(n(l.value,u.length)),l=d.next()}else for(r=Object.keys(e),u=new Array(r.length),a=0,s=r.length;a<s;a++)o=r[a],u[a]=n(e[o],o,a);return i(u)||(u=[]),u._isVList=!0,u}function Xe(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=R(R({},a),n)),i=s(n)||(o(t)?t():t)):i=this.$slots[e]||(o(t)?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function Ye(e){return jn(this.$options,"filters",e)||S}function et(e,n){return t(e)?-1===e.indexOf(n):e!==n}function tt(e,t,n,a,i){var s=N.keyCodes[t]||n;return i&&a&&!N.keyCodes[t]?et(i,a):s?et(s,e):a?A(a)!==t:void 0===e}function nt(e,n,a,i,s){if(a&&p(a)){t(a)&&(a=q(a));var r=void 0,o=function(t){if("class"===t||"style"===t||b(t))r=e;else{var o=e.attrs&&e.attrs.type;r=i||N.mustUseProp(n,o,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var p=k(t),u=A(t);p in r||u in r||(r[t]=a[t],s&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var u in a)o(u)}return e}function at(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||st(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function it(e,t,n){return st(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function st(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&rt(e[i],"".concat(n,"_").concat(i),a);else rt(e,n,a)}function rt(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function ot(e,t){if(t&&d(t)){var n=e.on=e.on?R({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function pt(e,n,a,i){n=n||{$stable:!a};for(var s=0;s<e.length;s++){var r=e[s];t(r)?pt(r,n,a):r&&(r.proxy&&(r.fn.proxy=!0),n[r.key]=r.fn)}return i&&(n.$key=i),n}function ut(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function dt(e,t){return"string"==typeof e?t+e:e}function lt(e){e._o=it,e._n=f,e._s=y,e._l=Ze,e._t=Xe,e._q=O,e._i=U,e._m=at,e._f=Ye,e._k=tt,e._b=nt,e._v=ye,e._e=ce,e._u=pt,e._g=ot,e._d=ut,e._p=dt}function ct(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,p=n[o]||(n[o]=[]);"template"===s.tag?p.push.apply(p,s.children||[]):p.push(s)}}for(var u in n)n[u].every(yt)&&delete n[u];return n}function yt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function mt(e){return e.isComment&&e.asyncFactory}function ft(t,n,a,i){var s,r=Object.keys(a).length>0,o=n?!!n.$stable:!r,p=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&i&&i!==e&&p===i.$key&&!r&&!i.$hasNormal)return i;for(var u in s={},n)n[u]&&"$"!==u[0]&&(s[u]=Tt(t,a,u,n[u]))}else s={};for(var d in a)d in s||(s[d]=ht(a,d));return n&&Object.isExtensible(n)&&(n._normalized=s),V(s,"$stable",o),V(s,"$key",p),V(s,"$hasNormal",r),s}function Tt(e,n,a,i){var s=function(){var n=ue;de(e);var a=arguments.length?i.apply(null,arguments):i({}),s=(a=a&&"object"==typeof a&&!t(a)?[a]:Ve(a))&&a[0];return de(n),a&&(!s||1===a.length&&s.isComment&&!mt(s))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:s,enumerable:!0,configurable:!0}),s}function ht(e,t){return function(){return e[t]}}function bt(e,t,n,a,i){var s=!1;for(var r in t)r in e?t[r]!==n[r]&&(s=!0):(s=!0,vt(e,r,a,i));for(var r in e)r in t||(s=!0,delete e[r]);return s}function vt(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function gt(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var Ct,wt,Pt=null;function kt(e,t){return(e.__esModule||pe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),p(e)?t.extend(e):e}function Mt(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||mt(a)))return a}}function _t(e,t){Ct.$on(e,t)}function At(e,t){Ct.$off(e,t)}function xt(e,t){var n=Ct;return function a(){null!==t.apply(null,arguments)&&n.$off(e,a)}}function Ft(e,t,n){Ct=e,Ne(t,n||{},_t,At,xt,e),Ct=void 0}var Rt=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=wt,!e&&wt&&(this.index=(wt.scopes||(wt.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=wt;try{return wt=this,e()}finally{wt=t}}},e.prototype.on=function(){wt=this},e.prototype.off=function(){wt=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},e}(),qt=null;function Et(e){var t=qt;return qt=e,function(){qt=t}}function It(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function St(e,t){if(t){if(e._directInactive=!1,It(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)St(e.$children[n]);Ut(e,"activated")}}function Ot(e,t){if(!(t&&(e._directInactive=!0,It(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)Ot(e.$children[n]);Ut(e,"deactivated")}}function Ut(e,t,n,a){void 0===a&&(a=!0),ge();var i=ue,s=wt;a&&de(e);var r=e.$options[t],o="".concat(t," hook");if(r)for(var p=0,u=r.length;p<u;p++)Jt(r[p],e,n||null,e,o);e._hasHookEvent&&e.$emit("hook:"+t),a&&(de(i),s&&s.on()),Ce()}var Dt=[],Bt=[],$t={},Lt=!1,Nt=!1,zt=0,jt=0,Vt=Date.now;if(H&&!K){var Gt=window.performance;Gt&&"function"==typeof Gt.now&&Vt()>document.createEvent("Event").timeStamp&&(Vt=function(){return Gt.now()})}var Qt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function Ht(){var e,t;for(jt=Vt(),Nt=!0,Dt.sort(Qt),zt=0;zt<Dt.length;zt++)(e=Dt[zt]).before&&e.before(),t=e.id,$t[t]=null,e.run();var n=Bt.slice(),a=Dt.slice();zt=Dt.length=Bt.length=0,$t={},Lt=Nt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,St(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&Ut(a,"updated")}}(a),he(),se&&N.devtools&&se.emit("flush")}var Wt="watcher";function Kt(e,t,n){ge();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Zt(e,a,"errorCaptured hook")}}Zt(e,t,n)}finally{Ce()}}function Jt(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&c(s)&&!s._handled&&(s.catch((function(e){return Kt(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){Kt(e,a,i)}return s}function Zt(e,t,n){if(N.errorHandler)try{return N.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Xt(t)}Xt(e)}function Xt(e,t,n){if(!H||"undefined"==typeof console)throw e;console.error(e)}"".concat(Wt," callback"),"".concat(Wt," getter"),"".concat(Wt," cleanup");var Yt,en=!1,tn=[],nn=!1;function an(){nn=!1;var e=tn.slice(0);tn.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&re(Promise)){var sn=Promise.resolve();Yt=function(){sn.then(an),X&&setTimeout(E)},en=!0}else if(K||"undefined"==typeof MutationObserver||!re(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Yt="undefined"!=typeof setImmediate&&re(setImmediate)?function(){setImmediate(an)}:function(){setTimeout(an,0)};else{var rn=1,on=new MutationObserver(an),pn=document.createTextNode(String(rn));on.observe(pn,{characterData:!0}),Yt=function(){rn=(rn+1)%2,pn.data=String(rn)},en=!0}function un(e,t){var n;if(tn.push((function(){if(e)try{e.call(t)}catch(e){Kt(e,t,"nextTick")}else n&&n(t)})),nn||(nn=!0,Yt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function dn(e){return function(t,n){if(void 0===n&&(n=ue),n)return function(e,t,n){var a=e.$options;a[t]=$n(a[t],n)}(n,e,t)}}dn("beforeMount"),dn("mounted"),dn("beforeUpdate"),dn("updated"),dn("beforeDestroy"),dn("destroyed"),dn("activated"),dn("deactivated"),dn("serverPrefetch"),dn("renderTracked"),dn("renderTriggered"),dn("errorCaptured");var ln=new oe;function cn(e){return yn(e,ln),ln.clear(),e}function yn(e,n){var a,i,s=t(e);if(!(!s&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof le)){if(e.__ob__){var r=e.__ob__.dep.id;if(n.has(r))return;n.add(r)}if(s)for(a=e.length;a--;)yn(e[a],n);else if(De(e))yn(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)yn(e[i[a]],n)}}var mn=0,fn=function(){function e(e,t,n,a,i){var s;void 0===(s=wt&&!wt._vm?wt:e?e._scope:void 0)&&(s=wt),s&&s.active&&s.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++mn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new oe,this.newDepIds=new oe,this.expression="",o(t)?this.getter=t:(this.getter=function(e){if(!G.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=E)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;ge(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Kt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&cn(e),Ce(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==$t[t]&&(e!==be.target||!e.noRecurse)){if($t[t]=!0,Nt){for(var n=Dt.length-1;n>zt&&Dt[n].id>e.id;)n--;Dt.splice(n+1,0,e)}else Dt.push(e);Lt||(Lt=!0,un(Ht))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||p(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Jt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&v(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),Tn={enumerable:!0,configurable:!0,get:E,set:E};function hn(e,t,n){Tn.get=function(){return this[t][n]},Tn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,Tn)}function bn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=Oe({}),i=e.$options._propKeys=[];!e.$parent||Ae(!1);var s=function(s){i.push(s);var r=Vn(s,t,n,e);qe(a,s,r,void 0,!0),s in e||hn(e,"_props",s)};for(var r in t)s(r);Ae(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};V(n,"_v_attr_proxy",!0),bt(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||bt(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||gt(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:x(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return Be(t,e,n)}))}}}(t);de(t),ge();var s=Jt(a,null,[t._props||Oe({}),i],t,"setup");if(Ce(),de(),o(s))n.render=s;else if(p(s))if(t._setupState=s,s.__sfc){var r=t._setupProxy={};for(var u in s)"__sfc"!==u&&Be(r,s,u)}else for(var u in s)j(u)||Be(t,s,u)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?E:x(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;d(t=e._data=o(t)?function(e,t){ge();try{return e.call(t,t)}catch(e){return Kt(e,t,"data()"),{}}finally{Ce()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&C(a,s)||j(s)||hn(e,"_data",s)}var r=Re(t);r&&r.vmCount++}(n);else{var i=Re(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ie();for(var i in t){var s=t[i],r=o(s)?s:s.get;a||(n[i]=new fn(e,r||E,E,vn)),i in e||gn(e,i,s)}}(n,a.computed),a.watch&&a.watch!==te&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var s=0;s<i.length;s++)Pn(e,a,i[s]);else Pn(e,a,i)}}(n,a.watch)}var vn={lazy:!0};function gn(e,t,n){var a=!ie();o(n)?(Tn.get=a?Cn(t):wn(n),Tn.set=E):(Tn.get=n.get?a&&!1!==n.cache?Cn(t):wn(n.get):E,Tn.set=n.set||E),Object.defineProperty(e,t,Tn)}function Cn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),be.target&&t.depend(),t.value}}function wn(e){return function(){return e.call(this,this)}}function Pn(e,t,n,a){return d(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function kn(e,t){if(e){for(var n=Object.create(null),a=pe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){var r=e[s].from;if(r in t._provided)n[s]=t._provided[r];else if("default"in e[s]){var p=e[s].default;n[s]=o(p)?p.call(t):p}}}return n}}var Mn=0;function _n(e){var t=e.options;if(e.super){var n=_n(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&R(e.extendOptions,a),(t=e.options=zn(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function An(n,a,i,r,o){var p,u=this,d=o.options;C(r,"_uid")?(p=Object.create(r))._original=r:(p=r,r=r._original);var l=s(d._compiled),c=!l;this.data=n,this.props=a,this.children=i,this.parent=r,this.listeners=n.on||e,this.injections=kn(d.inject,r),this.slots=function(){return u.$slots||ft(r,n.scopedSlots,u.$slots=ct(i,r)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ft(r,n.scopedSlots,this.slots())}}),l&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=ft(r,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,n,a,i){var s=Ke(p,e,n,a,i,c);return s&&!t(s)&&(s.fnScopeId=d._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return Ke(p,e,t,n,a,c)}}function xn(e,t,n,a,i){var s=me(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Fn(e,t){for(var n in t)e[k(n)]=t[n]}function Rn(e){return e.name||e.__name||e._componentTag}lt(An.prototype);var qn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;qn.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,qt)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,s){var r=i.data.scopedSlots,o=t.$scopedSlots,p=!!(r&&!r.$stable||o!==e&&!o.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),u=!!(s||t.$options._renderChildren||p),d=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=s;var l=i.data.attrs||e;t._attrsProxy&&bt(t._attrsProxy,l,d.data&&d.data.attrs||e,t,"$attrs")&&(u=!0),t.$attrs=l,a=a||e;var c=t.$options._parentListeners;if(t._listenersProxy&&bt(t._listenersProxy,a,c||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,Ft(t,a,c),n&&t.$options.props){Ae(!1);for(var y=t._props,m=t.$options._propKeys||[],f=0;f<m.length;f++){var T=m[f],h=t.$options.props;y[T]=Vn(T,h,n,t)}Ae(!0),t.$options.propsData=n}u&&(t.$slots=ct(s,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,Ut(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,Bt.push(t)):St(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?Ot(t,!0):t.$destroy())}},En=Object.keys(qn);function In(n,r,o,u,d){if(!a(n)){var l=o.$options._base;if(p(n)&&(n=l.extend(n)),"function"==typeof n){var y;if(a(n.cid)&&(n=function(e,t){if(s(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=Pt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),s(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var r=e.owners=[n],o=!0,u=null,d=null;n.$on("hook:destroyed",(function(){return v(r,n)}));var l=function(e){for(var t=0,n=r.length;t<n;t++)r[t].$forceUpdate();e&&(r.length=0,null!==u&&(clearTimeout(u),u=null),null!==d&&(clearTimeout(d),d=null))},y=D((function(n){e.resolved=kt(n,t),o?r.length=0:l(!0)})),m=D((function(t){i(e.errorComp)&&(e.error=!0,l(!0))})),f=e(y,m);return p(f)&&(c(f)?a(e.resolved)&&f.then(y,m):c(f.component)&&(f.component.then(y,m),i(f.error)&&(e.errorComp=kt(f.error,t)),i(f.loading)&&(e.loadingComp=kt(f.loading,t),0===f.delay?e.loading=!0:u=setTimeout((function(){u=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,l(!1))}),f.delay||200)),i(f.timeout)&&(d=setTimeout((function(){d=null,a(e.resolved)&&m(null)}),f.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(y=n,l),void 0===n))return function(e,t,n,a,i){var s=ce();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(y,r,o,u,d);r=r||{},_n(n),i(r.model)&&function(e,n){var a=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var r=n.on||(n.on={}),o=r[s],p=n.model.callback;i(o)?(t(o)?-1===o.indexOf(p):o!==p)&&(r[s]=[p].concat(o)):r[s]=p}(n.options,r);var m=function(e,t,n){var s=t.options.props;if(!a(s)){var r={},o=e.attrs,p=e.props;if(i(o)||i(p))for(var u in s){var d=A(u);je(r,p,u,d,!0)||je(r,o,u,d,!1)}return r}}(r,n);if(s(n.options.functional))return function(n,a,s,r,o){var p=n.options,u={},d=p.props;if(i(d))for(var l in d)u[l]=Vn(l,d,a||e);else i(s.attrs)&&Fn(u,s.attrs),i(s.props)&&Fn(u,s.props);var c=new An(s,u,o,r,n),y=p.render.call(null,c._c,c);if(y instanceof le)return xn(y,s,c.parent,p);if(t(y)){for(var m=Ve(y)||[],f=new Array(m.length),T=0;T<m.length;T++)f[T]=xn(m[T],s,c.parent,p);return f}}(n,m,r,o,u);var f=r.on;if(r.on=r.nativeOn,s(n.options.abstract)){var T=r.slot;r={},T&&(r.slot=T)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<En.length;n++){var a=En[n],i=t[a],s=qn[a];i===s||i&&i._merged||(t[a]=i?Sn(s,i):s)}}(r);var h=Rn(n.options)||d;return new le("vue-component-".concat(n.cid).concat(h?"-".concat(h):""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:m,listeners:f,tag:d,children:u},y)}}}function Sn(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var On=E,Un=N.optionMergeStrategies;function Dn(e,t,n){if(void 0===n&&(n=!0),!t)return e;for(var a,i,s,r=pe?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++)"__ob__"!==(a=r[o])&&(i=e[a],s=t[a],n&&C(e,a)?i!==s&&d(i)&&d(s)&&Dn(i,s):Ee(e,a,s));return e}function Bn(e,t,n){return n?function(){var a=o(t)?t.call(n,n):t,i=o(e)?e.call(n,n):e;return a?Dn(a,i):i}:t?e?function(){return Dn(o(t)?t.call(this,this):t,o(e)?e.call(this,this):e)}:t:e}function $n(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function Ln(e,t,n,a){var i=Object.create(e||null);return t?R(i,t):i}Un.data=function(e,t,n){return n?Bn(e,t,n):t&&"function"!=typeof t?e:Bn(e,t)},L.forEach((function(e){Un[e]=$n})),$.forEach((function(e){Un[e+"s"]=Ln})),Un.watch=function(e,n,a,i){if(e===te&&(e=void 0),n===te&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var s={};for(var r in R(s,e),n){var o=s[r],p=n[r];o&&!t(o)&&(o=[o]),s[r]=o?o.concat(p):t(p)?p:[p]}return s},Un.props=Un.methods=Un.inject=Un.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return R(i,e),t&&R(i,t),i},Un.provide=function(e,t){return e?function(){var n=Object.create(null);return Dn(n,o(e)?e.call(this):e),t&&Dn(n,o(t)?t.call(this):t,!1),n}:t};var Nn=function(e,t){return void 0===t?e:t};function zn(e,n,a){if(o(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,s,r={};if(t(a))for(i=a.length;i--;)"string"==typeof(s=a[i])&&(r[k(s)]={type:null});else if(d(a))for(var o in a)s=a[o],r[k(o)]=d(s)?s:{type:s};e.props=r}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var s=0;s<a.length;s++)i[a[s]]={from:a[s]};else if(d(a))for(var r in a){var o=a[r];i[r]=d(o)?R({from:r},o):{from:o}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];o(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=zn(e,n.extends,a)),n.mixins))for(var i=0,s=n.mixins.length;i<s;i++)e=zn(e,n.mixins[i],a);var r,p={};for(r in e)u(r);for(r in n)C(e,r)||u(r);function u(t){var i=Un[t]||Nn;p[t]=i(e[t],n[t],a,t)}return p}function jn(e,t,n,a){if("string"==typeof n){var i=e[t];if(C(i,n))return i[n];var s=k(n);if(C(i,s))return i[s];var r=M(s);return C(i,r)?i[r]:i[n]||i[s]||i[r]}}function Vn(e,t,n,a){var i=t[e],s=!C(n,e),r=n[e],p=Wn(Boolean,i.type);if(p>-1)if(s&&!C(i,"default"))r=!1;else if(""===r||r===A(e)){var u=Wn(String,i.type);(u<0||p<u)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(C(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:o(a)&&"Function"!==Qn(t.type)?a.call(e):a}}(a,i,e);var d=_e;Ae(!0),Re(r),Ae(d)}return r}var Gn=/^\s*function (\w+)/;function Qn(e){var t=e&&e.toString().match(Gn);return t?t[1]:""}function Hn(e,t){return Qn(e)===Qn(t)}function Wn(e,n){if(!t(n))return Hn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Hn(n[a],e))return a;return-1}function Kn(e){this._init(e)}function Jn(e){return e&&(Rn(e.Ctor.options)||e.tag)}function Zn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==u.call(a))&&e.test(n));var a}function Xn(e,t){var n=e.cache,a=e.keys,i=e._vnode,s=e.$vnode;for(var r in n){var o=n[r];if(o){var p=o.name;p&&!t(p)&&Yn(n,r,a,i)}}s.componentOptions.children=void 0}function Yn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,v(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=Mn++,n._isVue=!0,n.__v_skip=!0,n._scope=new Rt(!0),n._scope.parent=void 0,n._scope._vm=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=zn(_n(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&Ft(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=ct(n._renderChildren,i),t.$scopedSlots=a?ft(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return Ke(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return Ke(t,e,n,a,i,!0)};var s=a&&a.data;qe(t,"$attrs",s&&s.attrs||e,null,!0),qe(t,"$listeners",n._parentListeners||e,null,!0)}(n),Ut(n,"beforeCreate",void 0,!1),function(e){var t=kn(e.$options.inject,e);t&&(Ae(!1),Object.keys(t).forEach((function(n){qe(e,n,t[n])})),Ae(!0))}(n),bn(n),function(e){var t=e.$options.provide;if(t){var n=o(t)?t.call(e):t;if(!p(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=pe?Reflect.ownKeys(n):Object.keys(n),s=0;s<i.length;s++){var r=i[s];Object.defineProperty(a,r,Object.getOwnPropertyDescriptor(n,r))}}}(n),Ut(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Kn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Ee,e.prototype.$delete=Ie,e.prototype.$watch=function(e,t,n){var a=this;if(d(t))return Pn(a,e,t,n);(n=n||{}).user=!0;var i=new fn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'.concat(i.expression,'"');ge(),Jt(t,a,[i.value],a,s),Ce()}return function(){i.teardown()}}}(Kn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var s=0,r=e.length;s<r;s++)i.$on(e[s],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,s=e.length;i<s;i++)a.$off(e[i],n);return a}var r,o=a._events[e];if(!o)return a;if(!n)return a._events[e]=null,a;for(var p=o.length;p--;)if((r=o[p])===n||r.fn===n){o.splice(p,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?F(n):n;for(var a=F(arguments,1),i='event handler for "'.concat(e,'"'),s=0,r=n.length;s<r;s++)Jt(n[s],t,a,t,i)}return t}}(Kn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=Et(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var r=n;r&&r.$vnode&&r.$parent&&r.$vnode===r.$parent._vnode;)r.$parent.$el=r.$el,r=r.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Ut(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||v(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Ut(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Kn),function(e){lt(e.prototype),e.prototype.$nextTick=function(e){return un(e,this)},e.prototype._render=function(){var e=this,n=e.$options,a=n.render,i=n._parentVnode;i&&e._isMounted&&(e.$scopedSlots=ft(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&gt(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;var s,r=ue,o=Pt;try{de(e),Pt=e,s=a.call(e._renderProxy,e.$createElement)}catch(t){Kt(t,e,"render"),s=e._vnode}finally{Pt=o,de(r)}return t(s)&&1===s.length&&(s=s[0]),s instanceof le||(s=ce()),s.parent=i,s}}(Kn);var ea=[String,RegExp,Array],ta={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:ea,exclude:ea,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:Jn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&Yn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Yn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Xn(e,(function(e){return Zn(t,e)}))})),this.$watch("exclude",(function(t){Xn(e,(function(e){return!Zn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=Mt(e),n=t&&t.componentOptions;if(n){var a=Jn(n),i=this.include,s=this.exclude;if(i&&(!a||!Zn(i,a))||s&&a&&Zn(s,a))return t;var r=this.cache,o=this.keys,p=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;r[p]?(t.componentInstance=r[p].componentInstance,v(o,p),o.push(p)):(this.vnodeToCache=t,this.keyToCache=p),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return N}};Object.defineProperty(e,"config",t),e.util={warn:On,extend:R,mergeOptions:zn,defineReactive:qe},e.set=Ee,e.delete=Ie,e.nextTick=un,e.observable=function(e){return Re(e),e},e.options=Object.create(null),$.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,R(e.options.components,ta),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=F(arguments,1);return n.unshift(this),o(e.install)?e.install.apply(e,n):o(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=zn(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=Rn(e)||Rn(n.options),r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=zn(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)hn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)gn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,$.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=R({},r.options),i[a]=r,r}}(e),function(e){$.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&d(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&o(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Kn),Object.defineProperty(Kn.prototype,"$isServer",{get:ie}),Object.defineProperty(Kn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Kn,"FunctionalRenderContext",{value:An}),Kn.version="2.7.16";var na=T("style,class"),aa=T("input,textarea,option,select,progress"),ia=function(e,t,n){return"value"===n&&aa(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},sa=T("contenteditable,draggable,spellcheck"),ra=T("events,caret,typing,plaintext-only"),oa=function(e,t){return ca(t)||"false"===t?"false":"contenteditable"===e&&ra(t)?t:"true"},pa=T("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ua="http://www.w3.org/1999/xlink",da=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},la=function(e){return da(e)?e.slice(6,e.length):""},ca=function(e){return null==e||!1===e};function ya(e,t){return{staticClass:ma(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function ma(e,t){return e?t?e+" "+t:e:t||""}function fa(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,s=e.length;a<s;a++)i(t=fa(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):p(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Ta={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=T("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ba=T("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),va=function(e){return ha(e)||ba(e)};function ga(e){return ba(e)?"svg":"math"===e?"math":void 0}var Ca=Object.create(null),wa=T("text,number,password,search,email,tel,url");function Pa(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var ka=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Ta[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),Ma={create:function(e,t){_a(t)},update:function(e,t){e.data.ref!==t.data.ref&&(_a(e,!0),_a(t))},destroy:function(e){_a(e,!0)}};function _a(e,n){var a=e.data.ref;if(i(a)){var s=e.context,r=e.componentInstance||e.elm,p=n?null:r,u=n?void 0:r;if(o(a))Jt(a,s,[p],s,"template ref function");else{var d=e.data.refInFor,l="string"==typeof a||"number"==typeof a,c=De(a),y=s.$refs;if(l||c)if(d){var m=l?y[a]:a.value;n?t(m)&&v(m,r):t(m)?m.includes(r)||m.push(r):l?(y[a]=[r],Aa(s,a,y[a])):a.value=[r]}else if(l){if(n&&y[a]!==r)return;y[a]=u,Aa(s,a,p)}else if(c){if(n&&a.value!==r)return;a.value=p}}}}function Aa(e,t,n){var a=e._setupState;a&&C(a,t)&&(De(a[t])?a[t].value=n:a[t]=n)}var xa=new le("",{},[]),Fa=["create","activate","update","remove","destroy"];function Ra(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,s=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===s||wa(a)&&wa(s)}(e,t)||s(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function qa(e,t,n){var a,s,r={};for(a=t;a<=n;++a)i(s=e[a].key)&&(r[s]=a);return r}var Ea={create:Ia,update:Ia,destroy:function(e){Ia(e,xa)}};function Ia(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===xa,r=t===xa,o=Oa(e.data.directives,e.context),p=Oa(t.data.directives,t.context),u=[],d=[];for(n in p)a=o[n],i=p[n],a?(i.oldValue=a.value,i.oldArg=a.arg,Da(i,"update",t,e),i.def&&i.def.componentUpdated&&d.push(i)):(Da(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var l=function(){for(var n=0;n<u.length;n++)Da(u[n],"inserted",t,e)};s?ze(t,"insert",l):l()}if(d.length&&ze(t,"postpatch",(function(){for(var n=0;n<d.length;n++)Da(d[n],"componentUpdated",t,e)})),!s)for(n in o)p[n]||Da(o[n],"unbind",e,e,r)}(e,t)}var Sa=Object.create(null);function Oa(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Sa),i[Ua(a)]=a,t._setupState&&t._setupState.__sfc){var s=a.def||jn(t,"_setupState","v-"+a.name);a.def="function"==typeof s?{bind:s,update:s}:s}a.def=a.def||jn(t.$options,"directives",a.name)}return i}function Ua(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Da(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){Kt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Ba=[Ma,Ea];function $a(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var r,o,p=t.elm,u=e.data.attrs||{},d=t.data.attrs||{};for(r in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=t.data.attrs=R({},d)),d)o=d[r],u[r]!==o&&La(p,r,o,t.data.pre);for(r in(K||Z)&&d.value!==u.value&&La(p,"value",d.value),u)a(d[r])&&(da(r)?p.removeAttributeNS(ua,la(r)):sa(r)||p.removeAttribute(r))}}function La(e,t,n,a){a||e.tagName.indexOf("-")>-1?Na(e,t,n):pa(t)?ca(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):sa(t)?e.setAttribute(t,oa(t,n)):da(t)?ca(n)?e.removeAttributeNS(ua,la(t)):e.setAttributeNS(ua,t,n):Na(e,t,n)}function Na(e,t,n){if(ca(n))e.removeAttribute(t);else{if(K&&!J&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var za={create:$a,update:$a};function ja(e,t){var n=t.elm,s=t.data,r=e.data;if(!(a(s.staticClass)&&a(s.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ya(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=ya(t,n.data));return s=t.staticClass,r=t.class,i(s)||i(r)?ma(s,fa(r)):"";var s,r}(t),p=n._transitionClasses;i(p)&&(o=ma(o,fa(p))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Va,Ga,Qa,Ha,Wa,Ka,Ja={create:ja,update:ja},Za=/[\w).+\-_$\]]/;function Xa(e){var t,n,a,i,s,r=!1,o=!1,p=!1,u=!1,d=0,l=0,c=0,y=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(p)96===t&&92!==n&&(p=!1);else if(u)47===t&&92!==n&&(u=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||d||l||c){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:p=!0;break;case 40:c++;break;case 41:c--;break;case 91:l++;break;case 93:l--;break;case 123:d++;break;case 125:d--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&Za.test(f)||(u=!0)}}else void 0===i?(y=a+1,i=e.slice(0,a).trim()):T();function T(){(s||(s=[])).push(e.slice(y,a).trim()),y=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==y&&T(),s)for(a=0;a<s.length;a++)i=Ya(i,s[a]);return i}function Ya(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function ei(e,t){console.error("[Vue compiler]: ".concat(e))}function ti(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function ni(e,t,n,a,i){(e.props||(e.props=[])).push(li({name:t,value:n,dynamic:i},a)),e.plain=!1}function ai(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(li({name:t,value:n,dynamic:i},a)),e.plain=!1}function ii(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(li({name:t,value:n},a))}function si(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push(li({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function ri(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function oi(t,n,a,i,s,r,o,p){var u;(i=i||e).right?p?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(p?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=ri("!",n,p)),i.once&&(delete i.once,n=ri("~",n,p)),i.passive&&(delete i.passive,n=ri("&",n,p)),i.native?(delete i.native,u=t.nativeEvents||(t.nativeEvents={})):u=t.events||(t.events={});var d=li({value:a.trim(),dynamic:p},o);i!==e&&(d.modifiers=i);var l=u[n];Array.isArray(l)?s?l.unshift(d):l.push(d):u[n]=l?s?[d,l]:[l,d]:d,t.plain=!1}function pi(e,t,n){var a=ui(e,":"+t)||ui(e,"v-bind:"+t);if(null!=a)return Xa(a);if(!1!==n){var i=ui(e,t);if(null!=i)return JSON.stringify(i)}}function ui(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function di(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function li(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function ci(e,t,n){var a=n||{},i=a.number,s="$$v",r=s;a.trim&&(r="(typeof ".concat(s," === 'string'")+"? ".concat(s,".trim()")+": ".concat(s,")")),i&&(r="_n(".concat(r,")"));var o=yi(t,r);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(s,") {").concat(o,"}")}}function yi(e,t){var n=function(e){if(e=e.trim(),Va=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Va-1)return(Ha=e.lastIndexOf("."))>-1?{exp:e.slice(0,Ha),key:'"'+e.slice(Ha+1)+'"'}:{exp:e,key:null};for(Ga=e,Ha=Wa=Ka=0;!fi();)Ti(Qa=mi())?bi(Qa):91===Qa&&hi(Qa);return{exp:e.slice(0,Wa),key:e.slice(Wa+1,Ka)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function mi(){return Ga.charCodeAt(++Ha)}function fi(){return Ha>=Va}function Ti(e){return 34===e||39===e}function hi(e){var t=1;for(Wa=Ha;!fi();)if(Ti(e=mi()))bi(e);else if(91===e&&t++,93===e&&t--,0===t){Ka=Ha;break}}function bi(e){for(var t=e;!fi()&&(e=mi())!==t;);}var vi,gi="__r",Ci="__c";function wi(e,t,n){var a=vi;return function i(){null!==t.apply(null,arguments)&&Mi(e,i,n,a)}}var Pi=en&&!(ee&&Number(ee[1])<=53);function ki(e,t,n,a){if(Pi){var i=jt,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}vi.addEventListener(e,t,ne?{capture:n,passive:a}:n)}function Mi(e,t,n,a){(a||vi).removeEventListener(e,t._wrapper||t,n)}function _i(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},s=e.data.on||{};vi=t.elm||e.elm,function(e){if(i(e[gi])){var t=K?"change":"input";e[t]=[].concat(e[gi],e[t]||[]),delete e[gi]}i(e[Ci])&&(e.change=[].concat(e[Ci],e.change||[]),delete e[Ci])}(n),Ne(n,s,ki,Mi,wi,t.context),vi=void 0}}var Ai,xi={create:_i,update:_i,destroy:function(e){return _i(e,xa)}};function Fi(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,r,o=t.elm,p=e.data.domProps||{},u=t.data.domProps||{};for(n in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=t.data.domProps=R({},u)),p)n in u||(o[n]="");for(n in u){if(r=u[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),r===p[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=r;var d=a(r)?"":String(r);Ri(o,d)&&(o.value=d)}else if("innerHTML"===n&&ba(o.tagName)&&a(o.innerHTML)){(Ai=Ai||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var l=Ai.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;l.firstChild;)o.appendChild(l.firstChild)}else if(r!==p[n])try{o[n]=r}catch(e){}}}}function Ri(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return f(n)!==f(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var qi={create:Fi,update:Fi},Ei=w((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function Ii(e){var t=Si(e.style);return e.staticStyle?R(e.staticStyle,t):t}function Si(e){return Array.isArray(e)?q(e):"string"==typeof e?Ei(e):e}var Oi,Ui=/^--/,Di=/\s*!important$/,Bi=function(e,t,n){if(Ui.test(t))e.style.setProperty(t,n);else if(Di.test(n))e.style.setProperty(A(t),n.replace(Di,""),"important");else{var a=Li(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},$i=["Webkit","Moz","ms"],Li=w((function(e){if(Oi=Oi||document.createElement("div").style,"filter"!==(e=k(e))&&e in Oi)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<$i.length;n++){var a=$i[n]+t;if(a in Oi)return a}}));function Ni(e,t){var n=t.data,s=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(s.staticStyle)&&a(s.style))){var r,o,p=t.elm,u=s.staticStyle,d=s.normalizedStyle||s.style||{},l=u||d,c=Si(t.data.style)||{};t.data.normalizedStyle=i(c.__ob__)?R({},c):c;var y=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=Ii(i.data))&&R(a,n);(n=Ii(e.data))&&R(a,n);for(var s=e;s=s.parent;)s.data&&(n=Ii(s.data))&&R(a,n);return a}(t);for(o in l)a(y[o])&&Bi(p,o,"");for(o in y)r=y[o],Bi(p,o,null==r?"":r)}}var zi={create:Ni,update:Ni},ji=/\s+/;function Vi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(ji).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function Gi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(ji).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Qi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&R(t,Hi(e.name||"v")),R(t,e),t}return"string"==typeof e?Hi(e):void 0}}var Hi=w((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),Wi=H&&!J,Ki="transition",Ji="animation",Zi="transition",Xi="transitionend",Yi="animation",es="animationend";Wi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Zi="WebkitTransition",Xi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Yi="WebkitAnimation",es="webkitAnimationEnd"));var ts=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function ns(e){ts((function(){ts(e)}))}function as(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Vi(e,t))}function is(e,t){e._transitionClasses&&v(e._transitionClasses,t),Gi(e,t)}function ss(e,t,n){var a=os(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===Ki?Xi:es,p=0,u=function(){e.removeEventListener(o,d),n()},d=function(t){t.target===e&&++p>=r&&u()};setTimeout((function(){p<r&&u()}),s+1),e.addEventListener(o,d)}var rs=/\b(transform|all)(,|$)/;function os(e,t){var n,a=window.getComputedStyle(e),i=(a[Zi+"Delay"]||"").split(", "),s=(a[Zi+"Duration"]||"").split(", "),r=ps(i,s),o=(a[Yi+"Delay"]||"").split(", "),p=(a[Yi+"Duration"]||"").split(", "),u=ps(o,p),d=0,l=0;return t===Ki?r>0&&(n=Ki,d=r,l=s.length):t===Ji?u>0&&(n=Ji,d=u,l=p.length):l=(n=(d=Math.max(r,u))>0?r>u?Ki:Ji:null)?n===Ki?s.length:p.length:0,{type:n,timeout:d,propCount:l,hasTransform:n===Ki&&rs.test(a[Zi+"Property"])}}function ps(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return us(t)+us(e[n])})))}function us(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function ds(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var s=Qi(e.data.transition);if(!a(s)&&!i(n._enterCb)&&1===n.nodeType){for(var r=s.css,u=s.type,d=s.enterClass,l=s.enterToClass,c=s.enterActiveClass,y=s.appearClass,m=s.appearToClass,T=s.appearActiveClass,h=s.beforeEnter,b=s.enter,v=s.afterEnter,g=s.enterCancelled,C=s.beforeAppear,w=s.appear,P=s.afterAppear,k=s.appearCancelled,M=s.duration,_=qt,A=qt.$vnode;A&&A.parent;)_=A.context,A=A.parent;var x=!_._isMounted||!e.isRootInsert;if(!x||w||""===w){var F=x&&y?y:d,R=x&&T?T:c,q=x&&m?m:l,E=x&&C||h,I=x&&o(w)?w:b,S=x&&P||v,O=x&&k||g,U=f(p(M)?M.enter:M),B=!1!==r&&!J,$=ys(I),L=n._enterCb=D((function(){B&&(is(n,q),is(n,R)),L.cancelled?(B&&is(n,F),O&&O(n)):S&&S(n),n._enterCb=null}));e.data.show||ze(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),I&&I(n,L)})),E&&E(n),B&&(as(n,F),as(n,R),ns((function(){is(n,F),L.cancelled||(as(n,q),$||(cs(U)?setTimeout(L,U):ss(n,u,L)))}))),e.data.show&&(t&&t(),I&&I(n,L)),B||$||L()}}}function ls(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var s=Qi(e.data.transition);if(a(s)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var r=s.css,o=s.type,u=s.leaveClass,d=s.leaveToClass,l=s.leaveActiveClass,c=s.beforeLeave,y=s.leave,m=s.afterLeave,T=s.leaveCancelled,h=s.delayLeave,b=s.duration,v=!1!==r&&!J,g=ys(y),C=f(p(b)?b.leave:b),w=n._leaveCb=D((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(is(n,d),is(n,l)),w.cancelled?(v&&is(n,u),T&&T(n)):(t(),m&&m(n)),n._leaveCb=null}));h?h(P):P()}function P(){w.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),c&&c(n),v&&(as(n,u),as(n,l),ns((function(){is(n,u),w.cancelled||(as(n,d),g||(cs(C)?setTimeout(w,C):ss(n,o,w)))}))),y&&y(n,w),v||g||w())}}function cs(e){return"number"==typeof e&&!isNaN(e)}function ys(e){if(a(e))return!1;var t=e.fns;return i(t)?ys(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function ms(e,t){!0!==t.data.show&&ds(t)}var fs=function(e){var n,o,p={},u=e.modules,d=e.nodeOps;for(n=0;n<Fa.length;++n)for(p[Fa[n]]=[],o=0;o<u.length;++o)i(u[o][Fa[n]])&&p[Fa[n]].push(u[o][Fa[n]]);function l(e){var t=d.parentNode(e);i(t)&&d.removeChild(t,e)}function c(e,t,n,a,r,o,u){if(i(e.elm)&&i(o)&&(e=o[u]=me(e)),e.isRootInsert=!r,!function(e,t,n,a){var r=e.data;if(i(r)){var o=i(e.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(e,!1),i(e.componentInstance))return y(e,t),m(n,e.elm,a),s(o)&&function(e,t,n,a){for(var s,r=e;r.componentInstance;)if(i(s=(r=r.componentInstance._vnode).data)&&i(s=s.transition)){for(s=0;s<p.activate.length;++s)p.activate[s](xa,r);t.push(r);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var l=e.data,c=e.children,T=e.tag;i(T)?(e.elm=e.ns?d.createElementNS(e.ns,T):d.createElement(T,e),v(e),f(e,c,t),i(l)&&b(e,t),m(n,e.elm,a)):s(e.isComment)?(e.elm=d.createComment(e.text),m(n,e.elm,a)):(e.elm=d.createTextNode(e.text),m(n,e.elm,a))}}function y(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,h(e)?(b(e,t),v(e)):(_a(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?d.parentNode(n)===e&&d.insertBefore(e,t,n):d.appendChild(e,t))}function f(e,n,a){if(t(n))for(var i=0;i<n.length;++i)c(n[i],a,e.elm,null,!0,n,i);else r(e.text)&&d.appendChild(e.elm,d.createTextNode(String(e.text)))}function h(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function b(e,t){for(var a=0;a<p.create.length;++a)p.create[a](xa,e);i(n=e.data.hook)&&(i(n.create)&&n.create(xa,e),i(n.insert)&&t.push(e))}function v(e){var t;if(i(t=e.fnScopeId))d.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t),n=n.parent;i(t=qt)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t)}function g(e,t,n,a,i,s){for(;a<=i;++a)c(n[a],s,e,t,!1,n,a)}function C(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<p.destroy.length;++t)p.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)C(e.children[n])}function w(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(P(a),C(a)):l(a.elm))}}function P(e,t){if(i(t)||i(e.data)){var n,a=p.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&P(n,t),n=0;n<p.remove.length;++n)p.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else l(e.elm)}function k(e,t,n,a){for(var s=n;s<a;s++){var r=t[s];if(i(r)&&Ra(e,r))return s}}function M(e,t,n,r,o,u){if(e!==t){i(t.elm)&&i(r)&&(t=r[o]=me(t));var l=t.elm=e.elm;if(s(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?x(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(e.isStatic)&&t.key===e.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=e.componentInstance;else{var y,m=t.data;i(m)&&i(y=m.hook)&&i(y=y.prepatch)&&y(e,t);var f=e.children,T=t.children;if(i(m)&&h(t)){for(y=0;y<p.update.length;++y)p.update[y](e,t);i(y=m.hook)&&i(y=y.update)&&y(e,t)}a(t.text)?i(f)&&i(T)?f!==T&&function(e,t,n,s,r){for(var o,p,u,l=0,y=0,m=t.length-1,f=t[0],T=t[m],h=n.length-1,b=n[0],v=n[h],C=!r;l<=m&&y<=h;)a(f)?f=t[++l]:a(T)?T=t[--m]:Ra(f,b)?(M(f,b,s,n,y),f=t[++l],b=n[++y]):Ra(T,v)?(M(T,v,s,n,h),T=t[--m],v=n[--h]):Ra(f,v)?(M(f,v,s,n,h),C&&d.insertBefore(e,f.elm,d.nextSibling(T.elm)),f=t[++l],v=n[--h]):Ra(T,b)?(M(T,b,s,n,y),C&&d.insertBefore(e,T.elm,f.elm),T=t[--m],b=n[++y]):(a(o)&&(o=qa(t,l,m)),a(p=i(b.key)?o[b.key]:k(b,t,l,m))?c(b,s,e,f.elm,!1,n,y):Ra(u=t[p],b)?(M(u,b,s,n,y),t[p]=void 0,C&&d.insertBefore(e,u.elm,f.elm)):c(b,s,e,f.elm,!1,n,y),b=n[++y]);l>m?g(e,a(n[h+1])?null:n[h+1].elm,n,y,h,s):y>h&&w(t,l,m)}(l,f,T,n,u):i(T)?(i(e.text)&&d.setTextContent(l,""),g(l,null,T,0,T.length-1,n)):i(f)?w(f,0,f.length-1):i(e.text)&&d.setTextContent(l,""):e.text!==t.text&&d.setTextContent(l,t.text),i(m)&&i(y=m.hook)&&i(y=y.postpatch)&&y(e,t)}}}function _(e,t,n){if(s(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var A=T("attrs,class,staticClass,staticStyle,key");function x(e,t,n,a){var r,o=t.tag,p=t.data,u=t.children;if(a=a||p&&p.pre,t.elm=e,s(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(p)&&(i(r=p.hook)&&i(r=r.init)&&r(t,!0),i(r=t.componentInstance)))return y(t,n),!0;if(i(o)){if(i(u))if(e.hasChildNodes())if(i(r=p)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var d=!0,l=e.firstChild,c=0;c<u.length;c++){if(!l||!x(l,u[c],n,a)){d=!1;break}l=l.nextSibling}if(!d||l)return!1}else f(t,u,n);if(i(p)){var m=!1;for(var T in p)if(!A(T)){m=!0,b(t,n);break}!m&&p.class&&cn(p.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!a(t)){var o,u=!1,l=[];if(a(e))u=!0,c(t,l);else{var y=i(e.nodeType);if(!y&&Ra(e,t))M(e,t,l,null,null,r);else{if(y){if(1===e.nodeType&&e.hasAttribute(B)&&(e.removeAttribute(B),n=!0),s(n)&&x(e,t,l))return _(t,l,!0),e;o=e,e=new le(d.tagName(o).toLowerCase(),{},[],void 0,o)}var m=e.elm,f=d.parentNode(m);if(c(t,l,m._leaveCb?null:f,d.nextSibling(m)),i(t.parent))for(var T=t.parent,b=h(t);T;){for(var v=0;v<p.destroy.length;++v)p.destroy[v](T);if(T.elm=t.elm,b){for(var g=0;g<p.create.length;++g)p.create[g](xa,T);var P=T.data.hook.insert;if(P.merged)for(var k=P.fns.slice(1),A=0;A<k.length;A++)k[A]()}else _a(T);T=T.parent}i(f)?w([e],0,0):i(e.tag)&&C(e)}}return _(t,l,u),t.elm}i(e)&&C(e)}}({nodeOps:ka,modules:[za,Ja,xi,qi,zi,H?{create:ms,activate:ms,remove:function(e,t){!0!==e.data.show?ls(e,t):t()}}:{}].concat(Ba)});J&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&Ps(e,"input")}));var Ts={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?ze(n,"postpatch",(function(){Ts.componentUpdated(e,t,n)})):hs(e,t,n.context),e._vOptions=[].map.call(e.options,gs)):("textarea"===n.tag||wa(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Cs),e.addEventListener("compositionend",ws),e.addEventListener("change",ws),J&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){hs(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,gs);i.some((function(e,t){return!O(e,a[t])}))&&(e.multiple?t.value.some((function(e){return vs(e,i)})):t.value!==t.oldValue&&vs(t.value,i))&&Ps(e,"change")}}};function hs(e,t,n){bs(e,t),(K||Z)&&setTimeout((function(){bs(e,t)}),0)}function bs(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,p=e.options.length;o<p;o++)if(r=e.options[o],i)s=U(a,gs(r))>-1,r.selected!==s&&(r.selected=s);else if(O(gs(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function vs(e,t){return t.every((function(t){return!O(t,e)}))}function gs(e){return"_value"in e?e._value:e.value}function Cs(e){e.target.composing=!0}function ws(e){e.target.composing&&(e.target.composing=!1,Ps(e.target,"input"))}function Ps(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function ks(e){return!e.componentInstance||e.data&&e.data.transition?e:ks(e.componentInstance._vnode)}var Ms={model:Ts,show:{bind:function(e,t,n){var a=t.value,i=(n=ks(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,ds(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=ks(n)).data&&n.data.transition?(n.data.show=!0,a?ds(n,(function(){e.style.display=e.__vOriginalDisplay})):ls(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},_s={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function As(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?As(Mt(t.children)):e}function xs(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[k(a)]=i[a];return t}function Fs(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var Rs=function(e){return e.tag||mt(e)},qs=function(e){return"show"===e.name},Es={name:"transition",props:_s,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(Rs)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=As(i);if(!s)return i;if(this._leaving)return Fs(e,i);var o="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var p=(s.data||(s.data={})).transition=xs(this),u=this._vnode,d=As(u);if(s.data.directives&&s.data.directives.some(qs)&&(s.data.show=!0),d&&d.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,d)&&!mt(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var l=d.data.transition=R({},p);if("out-in"===a)return this._leaving=!0,ze(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Fs(e,i);if("in-out"===a){if(mt(s))return u;var c,y=function(){c()};ze(p,"afterEnter",y),ze(p,"enterCancelled",y),ze(l,"delayLeave",(function(e){c=e}))}}return i}}},Is=R({tag:String,moveClass:String},_s);delete Is.mode;var Ss={props:Is,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=Et(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=xs(this),o=0;o<i.length;o++)(d=i[o]).tag&&null!=d.key&&0!==String(d.key).indexOf("__vlist")&&(s.push(d),n[d.key]=d,(d.data||(d.data={})).transition=r);if(a){var p=[],u=[];for(o=0;o<a.length;o++){var d;(d=a[o]).data.transition=r,d.data.pos=d.elm.getBoundingClientRect(),n[d.key]?p.push(d):u.push(d)}this.kept=e(t,null,p),this.removed=u}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Os),e.forEach(Us),e.forEach(Ds),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;as(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Xi,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Xi,e),n._moveCb=null,is(n,t))})}})))},methods:{hasMove:function(e,t){if(!Wi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){Gi(n,e)})),Vi(n,t),n.style.display="none",this.$el.appendChild(n);var a=os(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function Os(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Us(e){e.data.newPos=e.elm.getBoundingClientRect()}function Ds(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),s.transitionDuration="0s"}}var Bs={Transition:Es,TransitionGroup:Ss};Kn.config.mustUseProp=ia,Kn.config.isReservedTag=va,Kn.config.isReservedAttr=na,Kn.config.getTagNamespace=ga,Kn.config.isUnknownElement=function(e){if(!H)return!0;if(va(e))return!1;if(e=e.toLowerCase(),null!=Ca[e])return Ca[e];var t=document.createElement(e);return e.indexOf("-")>-1?Ca[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Ca[e]=/HTMLUnknownElement/.test(t.toString())},R(Kn.options.directives,Ms),R(Kn.options.components,Bs),Kn.prototype.__patch__=H?fs:E,Kn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=ce),Ut(e,"beforeMount"),a=function(){e._update(e._render(),n)},new fn(e,a,E,{before:function(){e._isMounted&&!e._isDestroyed&&Ut(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var s=0;s<i.length;s++)i[s].run();return null==e.$vnode&&(e._isMounted=!0,Ut(e,"mounted")),e}(this,e=e&&H?Pa(e):void 0,t)},H&&setTimeout((function(){N.devtools&&se&&se.emit("init",Kn)}),0);var $s,Ls=/\{\{((?:.|\r?\n)+?)\}\}/g,Ns=/[-.*+?^${}()|[\]\/\\]/g,zs=w((function(e){var t=e[0].replace(Ns,"\\$&"),n=e[1].replace(Ns,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),js={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ui(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=pi(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},Vs={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ui(e,"style");n&&(e.staticStyle=JSON.stringify(Ei(n)));var a=pi(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},Gs=T("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Qs=T("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Hs=T("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Ws=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ks=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Js="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(z.source,"]*"),Zs="((?:".concat(Js,"\\:)?").concat(Js,")"),Xs=new RegExp("^<".concat(Zs)),Ys=/^\s*(\/?)>/,er=new RegExp("^<\\/".concat(Zs,"[^>]*>")),tr=/^<!DOCTYPE [^>]+>/i,nr=/^<!\--/,ar=/^<!\[/,ir=T("script,style,textarea",!0),sr={},rr={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},or=/&(?:lt|gt|quot|amp|#39);/g,pr=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,ur=T("pre,textarea",!0),dr=function(e,t){return e&&ur(e)&&"\n"===t[0]};function lr(e,t){var n=t?pr:or;return e.replace(n,(function(e){return rr[e]}))}var cr,yr,mr,fr,Tr,hr,br,vr,gr=/^@|^v-on:/,Cr=/^v-|^@|^:|^#/,wr=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Pr=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,kr=/^\(|\)$/g,Mr=/^\[.*\]$/,_r=/:(.*)$/,Ar=/^:|^\.|^v-bind:/,xr=/\.[^.\]]+(?=[^\]]*$)/g,Fr=/^v-slot(:|$)|^#/,Rr=/[\r\n]/,qr=/[ \f\t\r\n]+/g,Er=w((function(e){return($s=$s||document.createElement("div")).innerHTML=e,$s.textContent})),Ir="_empty_";function Sr(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:Nr(t),rawAttrsMap:{},parent:n,children:[]}}function Or(e,t){cr=t.warn||ei,hr=t.isPreTag||I,br=t.mustUseProp||I,vr=t.getTagNamespace||I;t.isReservedTag;mr=ti(t.modules,"transformNode"),fr=ti(t.modules,"preTransformNode"),Tr=ti(t.modules,"postTransformNode"),yr=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,p=!1;function u(e){if(d(e),o||e.processed||(e=Ur(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&Br(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,u=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),u&&u.if&&Br(u,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,u;e.children=e.children.filter((function(e){return!e.slotScope})),d(e),e.pre&&(o=!1),hr(e.tag)&&(p=!1);for(var l=0;l<Tr.length;l++)Tr[l](e,t)}function d(e){if(!p)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||I,o=t.canBeLeftOpenTag||I,p=0,u=function(){if(n=e,a&&ir(a)){var u=0,c=a.toLowerCase(),y=sr[c]||(sr[c]=new RegExp("([\\s\\S]*?)(</"+c+"[^>]*>)","i"));w=e.replace(y,(function(e,n,a){return u=a.length,ir(c)||"noscript"===c||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),dr(c,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),p+=e.length-w.length,e=w,l(c,p-u,p)}else{var m=e.indexOf("<");if(0===m){if(nr.test(e)){var f=e.indexOf("--\x3e");if(f>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,f),p,p+f+3),d(f+3),"continue"}if(ar.test(e)){var T=e.indexOf("]>");if(T>=0)return d(T+2),"continue"}var h=e.match(tr);if(h)return d(h[0].length),"continue";var b=e.match(er);if(b){var v=p;return d(b[0].length),l(b[1],v,p),"continue"}var g=function(){var t=e.match(Xs);if(t){var n={tagName:t[1],attrs:[],start:p};d(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(Ys))&&(i=e.match(Ks)||e.match(Ws));)i.start=p,d(i[0].length),i.end=p,n.attrs.push(i);if(a)return n.unarySlash=a[1],d(a[0].length),n.end=p,n}}();if(g)return function(e){var n=e.tagName,p=e.unarySlash;s&&("p"===a&&Hs(n)&&l(a),o(n)&&a===n&&l(n));for(var u=r(n)||!!p,d=e.attrs.length,c=new Array(d),y=0;y<d;y++){var m=e.attrs[y],f=m[3]||m[4]||m[5]||"",T="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;c[y]={name:m[1],value:lr(f,T)}}u||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:c,start:e.start,end:e.end}),a=n),t.start&&t.start(n,c,u,e.start,e.end)}(g),dr(g.tagName,e)&&d(1),"continue"}var C=void 0,w=void 0,P=void 0;if(m>=0){for(w=e.slice(m);!(er.test(w)||Xs.test(w)||nr.test(w)||ar.test(w)||(P=w.indexOf("<",1))<0);)m+=P,w=e.slice(m);C=e.substring(0,m)}m<0&&(C=e),C&&d(C.length),t.chars&&C&&t.chars(C,p-C.length,p)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==u(););function d(t){p+=t,e=e.substring(t)}function l(e,n,s){var r,o;if(null==n&&(n=p),null==s&&(s=p),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var u=i.length-1;u>=r;u--)t.end&&t.end(i[u].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}l()}(e,{warn:cr,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,d,l){var c=a&&a.ns||vr(e);K&&"svg"===c&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];zr.test(a.name)||(a.name=a.name.replace(jr,""),t.push(a))}return t}(s));var y,m=Sr(e,s,a);c&&(m.ns=c),"style"!==(y=m).tag&&("script"!==y.tag||y.attrsMap.type&&"text/javascript"!==y.attrsMap.type)||ie()||(m.forbidden=!0);for(var f=0;f<fr.length;f++)m=fr[f](m,t)||m;o||(function(e){null!=ui(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),hr(m.tag)&&(p=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(Dr(m),function(e){var t=ui(e,"v-if");if(t)e.if=t,Br(e,{exp:t,block:e});else{null!=ui(e,"v-else")&&(e.else=!0);var n=ui(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=ui(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),r?u(m):(a=m,i.push(m))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],u(s)},chars:function(e,t,n){if(a&&(!K||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,u=a.children;if(e=p||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:Er(e):u.length?r?"condense"===r&&Rr.test(e)?"":" ":s?" ":"":""){p||"condense"!==r||(e=e.replace(qr," "));var d=void 0,l=void 0;!o&&" "!==e&&(d=function(e,t){var n=t?zs(t):Ls;if(n.test(e)){for(var a,i,s,r=[],o=[],p=n.lastIndex=0;a=n.exec(e);){(i=a.index)>p&&(o.push(s=e.slice(p,i)),r.push(JSON.stringify(s)));var u=Xa(a[1].trim());r.push("_s(".concat(u,")")),o.push({"@binding":u}),p=i+a[0].length}return p<e.length&&(o.push(s=e.slice(p)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,yr))?l={type:2,expression:d.expression,tokens:d.tokens,text:e}:" "===e&&u.length&&" "===u[u.length-1].text||(l={type:3,text:e}),l&&u.push(l)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function Ur(e,t){var n;!function(e){var t=pi(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=pi(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ui(e,"scope"),e.slotScope=t||ui(e,"slot-scope")):(t=ui(e,"slot-scope"))&&(e.slotScope=t);var n,a=pi(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||ai(e,"slot",a,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot"))),"template"===e.tag){if(n=di(e,Fr)){var i=$r(n),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=n.value||Ir}}else if(n=di(e,Fr)){var o=e.scopedSlots||(e.scopedSlots={}),p=$r(n),u=p.name,d=(r=p.dynamic,o[u]=Sr("template",[],e));d.slotTarget=u,d.slotTargetDynamic=r,d.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=d,!0})),d.slotScope=n.value||Ir,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=pi(n,"name")),function(e){var t;(t=pi(e,"is"))&&(e.component=t),null!=ui(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<mr.length;a++)e=mr[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,p,u=e.attrsList;for(t=0,n=u.length;t<n;t++)if(a=i=u[t].name,s=u[t].value,Cr.test(a))if(e.hasBindings=!0,(r=Lr(a.replace(Cr,"")))&&(a=a.replace(xr,"")),Ar.test(a))a=a.replace(Ar,""),s=Xa(s),(p=Mr.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!p&&"innerHtml"===(a=k(a))&&(a="innerHTML"),r.camel&&!p&&(a=k(a)),r.sync&&(o=yi(s,"$event"),p?oi(e,'"update:"+('.concat(a,")"),o,null,!1,0,u[t],!0):(oi(e,"update:".concat(k(a)),o,null,!1,0,u[t]),A(a)!==k(a)&&oi(e,"update:".concat(A(a)),o,null,!1,0,u[t])))),r&&r.prop||!e.component&&br(e.tag,e.attrsMap.type,a)?ni(e,a,s,u[t],p):ai(e,a,s,u[t],p);else if(gr.test(a))a=a.replace(gr,""),(p=Mr.test(a))&&(a=a.slice(1,-1)),oi(e,a,s,r,!1,0,u[t],p);else{var d=(a=a.replace(Cr,"")).match(_r),l=d&&d[1];p=!1,l&&(a=a.slice(0,-(l.length+1)),Mr.test(l)&&(l=l.slice(1,-1),p=!0)),si(e,a,i,s,l,p,r,u[t])}else ai(e,a,JSON.stringify(s),u[t]),!e.component&&"muted"===a&&br(e.tag,e.attrsMap.type,a)&&ni(e,a,"true",u[t])}(e),e}function Dr(e){var t;if(t=ui(e,"v-for")){var n=function(e){var t=e.match(wr);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(kr,""),i=a.match(Pr);return i?(n.alias=a.replace(Pr,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&R(e,n)}}function Br(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function $r(e){var t=e.name.replace(Fr,"");return t||"#"!==e.name[0]&&(t="default"),Mr.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function Lr(e){var t=e.match(xr);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function Nr(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var zr=/^xmlns:NS\d+/,jr=/^NS\d+:/;function Vr(e){return Sr(e.tag,e.attrsList.slice(),e.parent)}var Gr,Qr,Hr=[js,Vs,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=pi(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=ui(e,"v-if",!0),s=i?"&&(".concat(i,")"):"",r=null!=ui(e,"v-else",!0),o=ui(e,"v-else-if",!0),p=Vr(e);Dr(p),ii(p,"type","checkbox"),Ur(p,t),p.processed=!0,p.if="(".concat(a,")==='checkbox'")+s,Br(p,{exp:p.if,block:p});var u=Vr(e);ui(u,"v-for",!0),ii(u,"type","radio"),Ur(u,t),Br(p,{exp:"(".concat(a,")==='radio'")+s,block:u});var d=Vr(e);return ui(d,"v-for",!0),ii(d,":type",a),Ur(d,t),Br(p,{exp:i,block:d}),r?p.else=!0:o&&(p.elseif=o),p}}}}],Wr={expectHTML:!0,modules:Hr,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return ci(e,a,i),!1;if("select"===s)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),s="var $$selectedVal = ".concat(i,";");oi(e,"change",s="".concat(s," ").concat(yi(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=pi(e,"value")||"null",s=pi(e,"true-value")||"true",r=pi(e,"false-value")||"false";ni(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===s?":(".concat(t,")"):":_q(".concat(t,",").concat(s,")"))),oi(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(s,"):(").concat(r,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(yi(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(yi(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(yi(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=pi(e,"value")||"null";i=a?"_n(".concat(i,")"):i,ni(e,"checked","_q(".concat(t,",").concat(i,")")),oi(e,"change",yi(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,p=!s&&"range"!==a,u=s?"change":"range"===a?gi:"input",d="$event.target.value";o&&(d="$event.target.value.trim()"),r&&(d="_n(".concat(d,")"));var l=yi(t,d);p&&(l="if($event.target.composing)return;".concat(l)),ni(e,"value","(".concat(t,")")),oi(e,u,l,null,!0),(o||r)&&oi(e,"blur","$forceUpdate()")}(e,a,i);else if(!N.isReservedTag(s))return ci(e,a,i),!1;return!0},text:function(e,t){t.value&&ni(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&ni(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:Gs,mustUseProp:ia,canBeLeftOpenTag:Qs,isReservedTag:va,getTagNamespace:ga,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(Hr)},Kr=w((function(e){return T("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Jr(e,t){e&&(Gr=Kr(t.staticKeys||""),Qr=t.isReservedTag||I,Zr(e),Xr(e,!1))}function Zr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||h(e.tag)||!Qr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(Gr))))}(e),1===e.type){if(!Qr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Zr(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;Zr(i),i.static||(e.static=!1)}}}function Xr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Xr(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)Xr(e.ifConditions[n].block,t)}}var Yr=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,eo=/\([^)]*?\);*$/,to=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,no={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},ao={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},io=function(e){return"if(".concat(e,")return null;")},so={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:io("$event.target !== $event.currentTarget"),ctrl:io("!$event.ctrlKey"),shift:io("!$event.shiftKey"),alt:io("!$event.altKey"),meta:io("!$event.metaKey"),left:io("'button' in $event && $event.button !== 0"),middle:io("'button' in $event && $event.button !== 1"),right:io("'button' in $event && $event.button !== 2")};function ro(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=oo(e[s]);e[s]&&e[s].dynamic?i+="".concat(s,",").concat(r,","):a+='"'.concat(s,'":').concat(r,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function oo(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return oo(e)})).join(","),"]");var t=to.test(e.value),n=Yr.test(e.value),a=to.test(e.value.replace(eo,""));if(e.modifiers){var i="",s="",r=[],o=function(t){if(so[t])s+=so[t],no[t]&&r.push(t);else if("exact"===t){var n=e.modifiers;s+=io(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else r.push(t)};for(var p in e.modifiers)o(p);r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(po).join("&&"),")return null;")}(r)),s&&(i+=s);var u=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(u,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function po(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=no[e],a=ao[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var uo={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:E},lo=function(e){this.options=e,this.warn=e.warn||ei,this.transforms=ti(e.modules,"transformCode"),this.dataGenFns=ti(e.modules,"genData"),this.directives=R(R({},uo),e.directives);var t=e.isReservedTag||I;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function co(e,t){var n=new lo(t),a=e?"script"===e.tag?"null":yo(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function yo(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return mo(e,t);if(e.once&&!e.onceProcessed)return fo(e,t);if(e.for&&!e.forProcessed)return bo(e,t);if(e.if&&!e.ifProcessed)return To(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=wo(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),s=e.attrs||e.dynamicAttrs?Mo((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:k(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=",".concat(s)),r&&(i+="".concat(s?"":",null",",").concat(r)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:wo(t,n,!0);return"_c(".concat(e,",").concat(vo(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=vo(e,t));var s=void 0,r=t.options.bindings;i&&r&&!1!==r.__isScriptSetup&&(s=function(e,t){var n=k(t),a=M(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},s=i("setup-const")||i("setup-reactive-const");if(s)return s;var r=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return r||void 0}(r,e.tag)),s||(s="'".concat(e.tag,"'"));var o=e.inlineTemplate?null:wo(e,t,!0);n="_c(".concat(s).concat(a?",".concat(a):"").concat(o?",".concat(o):"",")")}for(var p=0;p<t.transforms.length;p++)n=t.transforms[p](e,n);return n}return wo(e,t)||"void 0"}function mo(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(yo(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function fo(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return To(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(yo(e,t),",").concat(t.onceId++,",").concat(n,")"):yo(e,t)}return mo(e,t)}function To(e,t,n,a){return e.ifProcessed=!0,ho(e.ifConditions.slice(),t,n,a)}function ho(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(s(i.block),":").concat(ho(e,t,n,a)):"".concat(s(i.block));function s(e){return n?n(e,t):e.once?fo(e,t):yo(e,t)}}function bo(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?",".concat(e.iterator1):"",o=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(s).concat(r).concat(o,"){")+"return ".concat((n||yo)(e,t))+"})"}function vo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",p=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var u=t.directives[s.name];u&&(r=!!u(e,s,t.warn)),r&&(p=!0,o+='{name:"'.concat(s.name,'",rawName:"').concat(s.rawName,'"').concat(s.value?",value:(".concat(s.value,"),expression:").concat(JSON.stringify(s.value)):"").concat(s.arg?",arg:".concat(s.isDynamicArg?s.arg:'"'.concat(s.arg,'"')):"").concat(s.modifiers?",modifiers:".concat(JSON.stringify(s.modifiers)):"","},"))}return p?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(Mo(e.attrs),",")),e.props&&(n+="domProps:".concat(Mo(e.props),",")),e.events&&(n+="".concat(ro(e.events,!1),",")),e.nativeEvents&&(n+="".concat(ro(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||go(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==Ir||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return Co(t[e],n)})).join(",");return"scopedSlots:_u([".concat(r,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=co(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);s&&(n+="".concat(s,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(Mo(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function go(e){return 1===e.type&&("slot"===e.tag||e.children.some(go))}function Co(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return To(e,t,Co,"null");if(e.for&&!e.forProcessed)return bo(e,t,Co);var a=e.slotScope===Ir?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(wo(e,t)||"undefined",":undefined"):wo(e,t)||"undefined":yo(e,t),"}"),s=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(s,"}")}function wo(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return"".concat((a||yo)(r,t)).concat(o)}var p=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(Po(i)||i.ifConditions&&i.ifConditions.some((function(e){return Po(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,u=i||ko;return"[".concat(s.map((function(e){return u(e,t)})).join(","),"]").concat(p?",".concat(p):"")}}function Po(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ko(e,t){return 1===e.type?yo(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:_o(JSON.stringify(n.text)),")");var n}function Mo(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=_o(i.value);i.dynamic?n+="".concat(i.name,",").concat(s,","):t+='"'.concat(i.name,'":').concat(s,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function _o(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function Ao(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),E}}function xo(e){var t=Object.create(null);return function(n,a,i){(a=R({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},p=[];return o.render=Ao(r.render,p),o.staticRenderFns=r.staticRenderFns.map((function(e){return Ao(e,p)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var Fo,Ro,qo=(Fo=function(e,t){var n=Or(e.trim(),t);!1!==t.optimize&&Jr(n,t);var a=co(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=R(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=Fo(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:xo(t)}}),Eo=qo(Wr).compileToFunctions;function Io(e){return(Ro=Ro||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',Ro.innerHTML.indexOf("&#10;")>0}var So=!!H&&Io(!1),Oo=!!H&&Io(!0),Uo=w((function(e){var t=Pa(e);return t&&t.innerHTML})),Do=Kn.prototype.$mount;function Bo(e,t){for(var n in t)e[n]=t[n];return e}Kn.prototype.$mount=function(e,t){if((e=e&&Pa(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=Uo(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=Eo(a,{outputSourceRange:!1,shouldDecodeNewlines:So,shouldDecodeNewlinesForHref:Oo,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return Do.call(this,e,t)},Kn.compile=Eo;var $o=/[!'()*]/g,Lo=function(e){return"%"+e.charCodeAt(0).toString(16)},No=/%2C/g,zo=function(e){return encodeURIComponent(e).replace($o,Lo).replace(No,",")};function jo(e){try{return decodeURIComponent(e)}catch(e){}return e}var Vo=function(e){return null==e||"object"==typeof e?e:String(e)};function Go(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=jo(n.shift()),i=n.length>0?jo(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Qo(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return zo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(zo(t)):a.push(zo(t)+"="+zo(e)))})),a.join("&")}return zo(t)+"="+zo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Ho=/\/?$/;function Wo(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=Ko(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Xo(t,i),matched:e?Zo(e):[]};return n&&(r.redirectedFrom=Xo(n,i)),Object.freeze(r)}function Ko(e){if(Array.isArray(e))return e.map(Ko);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Ko(e[n]);return t}return e}var Jo=Wo(null,{path:"/"});function Zo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Xo(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Qo)(a)+i}function Yo(e,t,n){return t===Jo?e===t:!!t&&(e.path&&t.path?e.path.replace(Ho,"")===t.path.replace(Ho,"")&&(n||e.hash===t.hash&&ep(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&ep(e.query,t.query)&&ep(e.params,t.params)))}function ep(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?ep(s,r):String(s)===String(r)}))}function tp(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var np={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,p=i.$route,u=i._routerViewCache||(i._routerViewCache={}),d=0,l=!1;i&&i._routerRoot!==i;){var c=i.$vnode?i.$vnode.data:{};c.routerView&&d++,c.keepAlive&&i._directInactive&&i._inactive&&(l=!0),i=i.$parent}if(s.routerViewDepth=d,l){var y=u[o],m=y&&y.component;return m?(y.configProps&&ap(m,s,y.route,y.configProps),r(m,s,a)):r()}var f=p.matched[d],T=f&&f.components[o];if(!f||!T)return u[o]=null,r();u[o]={component:T},s.registerRouteInstance=function(e,t){var n=f.instances[o];(t&&n!==e||!t&&n===e)&&(f.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){f.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[o]&&(f.instances[o]=e.componentInstance),tp(p)};var h=f.props&&f.props[o];return h&&(Bo(u[o],{route:p,configProps:h}),ap(T,s,p,h)),r(T,s,a)}};function ap(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=Bo({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function ip(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function sp(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var rp=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},op=function e(t,n,a){return rp(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return bp(e,t)}(t,n):rp(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return bp(new RegExp("(?:"+i.join("|")+")",vp(a)),n)}(t,n,a):function(e,t,n){return gp(cp(e,n),t,n)}(t,n,a)},pp=cp,up=fp,dp=gp,lp=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function cp(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=lp.exec(e));){var p=n[0],u=n[1],d=n.index;if(r+=e.slice(s,d),s=d+p.length,u)r+=u[1];else{var l=e[s],c=n[2],y=n[3],m=n[4],f=n[5],T=n[6],h=n[7];r&&(a.push(r),r="");var b=null!=c&&null!=l&&l!==c,v="+"===T||"*"===T,g="?"===T||"*"===T,C=n[2]||o,w=m||f;a.push({name:y||i++,prefix:c||"",delimiter:C,optional:g,repeat:v,partial:b,asterisk:!!h,pattern:w?hp(w):h?".*":"[^"+Tp(C)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function yp(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function mp(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function fp(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",vp(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?yp:encodeURIComponent,o=0;o<e.length;o++){var p=e[o];if("string"!=typeof p){var u,d=s[p.name];if(null==d){if(p.optional){p.partial&&(i+=p.prefix);continue}throw new TypeError('Expected "'+p.name+'" to be defined')}if(rp(d)){if(!p.repeat)throw new TypeError('Expected "'+p.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(p.optional)continue;throw new TypeError('Expected "'+p.name+'" to not be empty')}for(var l=0;l<d.length;l++){if(u=r(d[l]),!n[o].test(u))throw new TypeError('Expected all "'+p.name+'" to match "'+p.pattern+'", but received `'+JSON.stringify(u)+"`");i+=(0===l?p.prefix:p.delimiter)+u}}else{if(u=p.asterisk?mp(d):r(d),!n[o].test(u))throw new TypeError('Expected "'+p.name+'" to match "'+p.pattern+'", but received "'+u+'"');i+=p.prefix+u}}else i+=p}return i}}function Tp(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function hp(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function bp(e,t){return e.keys=t,e}function vp(e){return e&&e.sensitive?"":"i"}function gp(e,t,n){rp(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=Tp(o);else{var p=Tp(o.prefix),u="(?:"+o.pattern+")";t.push(o),o.repeat&&(u+="(?:"+p+u+")*"),s+=u=o.optional?o.partial?p+"("+u+")?":"(?:"+p+"("+u+"))?":p+"("+u+")"}}var d=Tp(n.delimiter||"/"),l=s.slice(-d.length)===d;return a||(s=(l?s.slice(0,-d.length):s)+"(?:"+d+"(?=$))?"),s+=i?"$":a&&l?"":"(?="+d+"|$)",bp(new RegExp("^"+s,vp(n)),t)}op.parse=pp,op.compile=function(e,t){return fp(cp(e,t),t)},op.tokensToFunction=up,op.tokensToRegExp=dp;var Cp=Object.create(null);function wp(e,t,n){t=t||{};try{var a=Cp[e]||(Cp[e]=op.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function Pp(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=Bo({},e)).params;return s&&"object"==typeof s&&(i.params=Bo({},s)),i}if(!i.path&&i.params&&t){(i=Bo({},i))._normalized=!0;var r=Bo(Bo({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=wp(o,r,t.path)}return i}var p=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),u=t&&t.path||"/",d=p.path?ip(p.path,u,n||i.append):u,l=function(e,t,n){void 0===t&&(t={});var a,i=n||Go;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(Vo):Vo(r)}return a}(p.query,i.query,a&&a.options.parseQuery),c=i.hash||p.hash;return c&&"#"!==c.charAt(0)&&(c="#"+c),{_normalized:!0,path:d,query:l,hash:c}}var kp,Mp=function(){},_p={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,p={},u=n.options.linkActiveClass,d=n.options.linkExactActiveClass,l=null==u?"router-link-active":u,c=null==d?"router-link-exact-active":d,y=null==this.activeClass?l:this.activeClass,m=null==this.exactActiveClass?c:this.exactActiveClass,f=r.redirectedFrom?Wo(null,Pp(r.redirectedFrom),null,n):r;p[m]=Yo(a,f,this.exactPath),p[y]=this.exact||this.exactPath?p[m]:function(e,t){return 0===e.path.replace(Ho,"/").indexOf(t.path.replace(Ho,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var T=p[m]?this.ariaCurrentValue:null,h=function(e){Ap(e)&&(t.replace?n.replace(s,Mp):n.push(s,Mp))},b={click:Ap};Array.isArray(this.event)?this.event.forEach((function(e){b[e]=h})):b[this.event]=h;var v={class:p},g=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:h,isActive:p[y],isExactActive:p[m]});if(g){if(1===g.length)return g[0];if(g.length>1||!g.length)return 0===g.length?e():e("span",{},g)}if("a"===this.tag)v.on=b,v.attrs={href:o,"aria-current":T};else{var C=xp(this.$slots.default);if(C){C.isStatic=!1;var w=C.data=Bo({},C.data);for(var P in w.on=w.on||{},w.on){var k=w.on[P];P in b&&(w.on[P]=Array.isArray(k)?k:[k])}for(var M in b)M in w.on?w.on[M].push(b[M]):w.on[M]=h;var _=C.data.attrs=Bo({},C.data.attrs);_.href=o,_["aria-current"]=T}else v.on=b}return e(this.tag,v,this.$slots.default)}};function Ap(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function xp(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=xp(t.children)))return t}}var Fp="undefined"!=typeof window;function Rp(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){qp(s,r,o,e,i)}));for(var p=0,u=s.length;p<u;p++)"*"===s[p]&&(s.push(s.splice(p,1)[0]),u--,p--);return{pathList:s,pathMap:r,nameMap:o}}function qp(e,t,n,a,i,s){var r=a.path,o=a.name,p=a.pathToRegexpOptions||{},u=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:sp(t.path+"/"+e)}(r,i,p.strict);"boolean"==typeof a.caseSensitive&&(p.sensitive=a.caseSensitive);var d={path:u,regex:Ep(u,p),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?sp(s+"/"+a.path):void 0;qp(e,t,n,a,d,i)})),t[d.path]||(e.push(d.path),t[d.path]=d),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],c=0;c<l.length;++c){var y={path:l[c],children:a.children};qp(e,t,n,y,i,d.path||"/")}o&&(n[o]||(n[o]=d))}function Ep(e,t){return op(e,[],t)}function Ip(e,t){var n=Rp(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var p=Pp(e,n,!1,t),u=p.name;if(u){var d=s[u];if(!d)return o(null,p);var l=d.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof p.params&&(p.params={}),n&&"object"==typeof n.params)for(var c in n.params)!(c in p.params)&&l.indexOf(c)>-1&&(p.params[c]=n.params[c]);return p.path=wp(d.path,p.params),o(d,p,r)}if(p.path){p.params={};for(var y=0;y<a.length;y++){var m=a[y],f=i[m];if(Sp(f.regex,p.path,p.params))return o(f,p,r)}}return o(null,p)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(Wo(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var p=i,u=p.name,d=p.path,l=n.query,c=n.hash,y=n.params;if(l=p.hasOwnProperty("query")?p.query:l,c=p.hasOwnProperty("hash")?p.hash:c,y=p.hasOwnProperty("params")?p.params:y,u)return s[u],r({_normalized:!0,name:u,query:l,hash:c,params:y},void 0,n);if(d){var m=function(e,t){return ip(e,t.parent?t.parent.path:"/",!0)}(d,e);return r({_normalized:!0,path:wp(m,y),query:l,hash:c},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:wp(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):Wo(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;Rp([t||e],a,i,s,n),n&&n.alias.length&&Rp(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){Rp(e,a,i,s)}}}function Sp(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?jo(a[i]):a[i])}return!0}var Op=Fp&&window.performance&&window.performance.now?window.performance:Date;function Up(){return Op.now().toFixed(3)}var Dp=Up();function Bp(){return Dp}function $p(e){return Dp=e}var Lp=Object.create(null);function Np(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=Bo({},window.history.state);return n.key=Bp(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Vp),function(){window.removeEventListener("popstate",Vp)}}function zp(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=Bp();if(e)return Lp[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){Kp(e,s)})).catch((function(e){})):Kp(r,s))}))}}function jp(){var e=Bp();e&&(Lp[e]={x:window.pageXOffset,y:window.pageYOffset})}function Vp(e){jp(),e.state&&e.state.key&&$p(e.state.key)}function Gp(e){return Hp(e.x)||Hp(e.y)}function Qp(e){return{x:Hp(e.x)?e.x:window.pageXOffset,y:Hp(e.y)?e.y:window.pageYOffset}}function Hp(e){return"number"==typeof e}var Wp=/^#\d/;function Kp(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Wp.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Hp((n=s).x)?n.x:0,y:Hp(n.y)?n.y:0})}else Gp(e)&&(t=Qp(e))}else a&&Gp(e)&&(t=Qp(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Jp,Zp=Fp&&(-1===(Jp=window.navigator.userAgent).indexOf("Android 2.")&&-1===Jp.indexOf("Android 4.0")||-1===Jp.indexOf("Mobile Safari")||-1!==Jp.indexOf("Chrome")||-1!==Jp.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Xp(e,t){jp();var n=window.history;try{if(t){var a=Bo({},n.state);a.key=Bp(),n.replaceState(a,"",e)}else n.pushState({key:$p(Up())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Yp(e){Xp(e,!0)}var eu={redirected:2,aborted:4,cancelled:8,duplicated:16};function tu(e,t){return nu(e,t,eu.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function nu(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var au=["params","query","hash"];function iu(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function su(e,t){return iu(e)&&e._isRouter&&(null==t||e.type===t)}function ru(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}function ou(e,t){return pu(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function pu(e){return Array.prototype.concat.apply([],e)}var uu="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function du(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var lu=function(e,t){this.router=e,this.base=function(e){if(!e)if(Fp){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Jo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function cu(e,t,n,a){var i=ou(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=kp.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return pu(a?i.reverse():i)}function yu(e,t){if(t)return function(){return e.apply(t,arguments)}}lu.prototype.listen=function(e){this.cb=e},lu.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},lu.prototype.onError=function(e){this.errorCbs.push(e)},lu.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(su(e,eu.redirected)&&s===Jo||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},lu.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!su(e)&&iu(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},p=e.matched.length-1,u=i.matched.length-1;if(Yo(e,i)&&p===u&&e.matched[p]===i.matched[u])return this.ensureURL(),e.hash&&zp(this.router,i,e,!1),o(((r=nu(s=i,e,eu.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var d,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),c=l.updated,y=l.deactivated,m=l.activated,f=[].concat(function(e){return cu(e,"beforeRouteLeave",yu,!0)}(y),this.router.beforeHooks,function(e){return cu(e,"beforeRouteUpdate",yu)}(c),m.map((function(e){return e.beforeEnter})),(d=m,function(e,t,n){var a=!1,i=0,s=null;ou(d,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var p,u=du((function(t){var a;((a=t).__esModule||uu&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:kp.extend(t),r.components[o]=t,--i<=0&&n()})),d=du((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=iu(e)?e:new Error(t),n(s))}));try{p=e(u,d)}catch(e){d(e)}if(p)if("function"==typeof p.then)p.then(u,d);else{var l=p.component;l&&"function"==typeof l.then&&l.then(u,d)}}})),a||n()})),T=function(t,n){if(a.pending!==e)return o(tu(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return nu(e,t,eu.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):iu(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return nu(e,t,eu.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return au.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};ru(f,T,(function(){var n=function(e){return cu(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(m);ru(n.concat(a.router.resolveHooks),T,(function(){if(a.pending!==e)return o(tu(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){tp(e)}))}))}))},lu.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},lu.prototype.setupListeners=function(){},lu.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Jo,this.pending=null};var mu=function(e){function t(t,n){e.call(this,t,n),this._startLocation=fu(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Zp&&n;a&&this.listeners.push(Np());var i=function(){var n=e.current,i=fu(e.base);e.current===Jo&&i===e._startLocation||e.transitionTo(i,(function(e){a&&zp(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Xp(sp(a.base+e.fullPath)),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Yp(sp(a.base+e.fullPath)),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(fu(this.base)!==this.current.fullPath){var t=sp(this.base+this.current.fullPath);e?Xp(t):Yp(t)}},t.prototype.getCurrentLocation=function(){return fu(this.base)},t}(lu);function fu(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(sp(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var Tu=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=fu(e);if(!/^\/#/.test(t))return window.location.replace(sp(e+"/#"+t)),!0}(this.base)||hu()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Zp&&t;n&&this.listeners.push(Np());var a=function(){var t=e.current;hu()&&e.transitionTo(bu(),(function(a){n&&zp(e.router,a,t,!0),Zp||Cu(a.fullPath)}))},i=Zp?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){gu(e.fullPath),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Cu(e.fullPath),zp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;bu()!==t&&(e?gu(t):Cu(t))},t.prototype.getCurrentLocation=function(){return bu()},t}(lu);function hu(){var e=bu();return"/"===e.charAt(0)||(Cu("/"+e),!1)}function bu(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function vu(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function gu(e){Zp?Xp(vu(e)):window.location.hash=e}function Cu(e){Zp?Yp(vu(e)):window.location.replace(vu(e))}var wu=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){su(e,eu.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(lu),Pu=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ip(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Zp&&!1!==e.fallback,this.fallback&&(t="hash"),Fp||(t="abstract"),this.mode=t,t){case"history":this.history=new mu(this,e.base);break;case"hash":this.history=new Tu(this,e.base,this.fallback);break;case"abstract":this.history=new wu(this,e.base)}},ku={currentRoute:{configurable:!0}};Pu.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},ku.currentRoute.get=function(){return this.history&&this.history.current},Pu.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof mu||n instanceof Tu){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Zp&&i&&"fullPath"in e&&zp(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},Pu.prototype.beforeEach=function(e){return _u(this.beforeHooks,e)},Pu.prototype.beforeResolve=function(e){return _u(this.resolveHooks,e)},Pu.prototype.afterEach=function(e){return _u(this.afterHooks,e)},Pu.prototype.onReady=function(e,t){this.history.onReady(e,t)},Pu.prototype.onError=function(e){this.history.onError(e)},Pu.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},Pu.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},Pu.prototype.go=function(e){this.history.go(e)},Pu.prototype.back=function(){this.go(-1)},Pu.prototype.forward=function(){this.go(1)},Pu.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},Pu.prototype.resolve=function(e,t,n){var a=Pp(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?sp(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},Pu.prototype.getRoutes=function(){return this.matcher.getRoutes()},Pu.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Jo&&this.history.transitionTo(this.history.getCurrentLocation())},Pu.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Jo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Pu.prototype,ku);var Mu=Pu;function _u(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}Pu.install=function e(t){if(!e.installed||kp!==t){e.installed=!0,kp=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",np),t.component("RouterLink",_p);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Pu.version="3.6.5",Pu.isNavigationFailure=su,Pu.NavigationFailureType=eu,Pu.START_LOCATION=Jo,Fp&&window.Vue&&window.Vue.use(Pu);var Au=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function xu(e,t,n,a,i,s,r,o){var p,u="function"==typeof e?e.options:e;if(t&&(u.render=t,u.staticRenderFns=n,u._compiled=!0),a&&(u.functional=!0),s&&(u._scopeId="data-v-"+s),r?(p=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},u._ssrRegister=p):i&&(p=o?function(){i.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:i),p)if(u.functional){u._injectStyles=p;var d=u.render;u.render=function(e,t){return p.call(t),d(e,t)}}else{var l=u.beforeCreate;u.beforeCreate=l?[].concat(l,p):[p]}return{exports:e,options:u}}Au._withStripped=!0,n(884);const Fu=xu({},Au,[],!1,null,null,null).exports;var Ru=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};Ru._withStripped=!0;var qu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};qu._withStripped=!0;const Eu=JSON.parse('{"UU":"hardhat-docgen","Jk":"https://github.com/ItsNickBarry/hardhat-docgen"}'),Iu=xu({data:function(){return{repository:Eu.Jk,name:Eu.UU}},methods:{openLink(e){window.open(e,"_blank")}}},qu,[],!1,null,null,null).exports;var Su=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};Su._withStripped=!0;const Ou=xu({},Su,[],!1,null,null,null).exports;var Uu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Uu._withStripped=!0;var Du=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};Du._withStripped=!0;const Bu={components:{MemberSection:xu({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Du,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},$u=xu(Bu,Uu,[],!1,null,null,null).exports;var Lu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};Lu._withStripped=!0;var Nu=xu({components:{Member:$u},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Lu,[],!1,null,null,null);const zu=xu({components:{Member:$u,MemberSet:Nu.exports,HeaderBar:Ou,FooterBar:Iu},props:{json:{type:Object,default:()=>new Object}}},Ru,[],!1,null,null,null).exports;var ju=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};ju._withStripped=!0;var Vu=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};Vu._withStripped=!0;var Gu=xu({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Vu,[],!1,null,null,null);const Qu=xu({components:{Branch:Gu.exports,FooterBar:Iu},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},ju,[],!1,null,null,null).exports;Kn.use(Mu);const Hu={"contracts/auxiliary/CommissionSplitter.sol:CommissionSplitter":{source:"contracts/auxiliary/CommissionSplitter.sol",name:"CommissionSplitter",details:"Contract that split his balance between two addresses based on a proportion defined by Governance.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"SplitExecuted(uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"acTokenPctToRecipient1_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"acTokenPctToRecipient2_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"feeTokenPctToRecipient1_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"feeTokenPctToRecipient2_",type:"uint256"}],name:"SplitExecuted",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"acToken()":{inputs:[],name:"acToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"acTokenAddressRecipient1()":{inputs:[],name:"acTokenAddressRecipient1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"acTokenAddressRecipient2()":{inputs:[],name:"acTokenAddressRecipient2",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"acTokenPctToRecipient1()":{inputs:[],name:"acTokenPctToRecipient1",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenAddressRecipient1()":{inputs:[],name:"feeTokenAddressRecipient1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenAddressRecipient2()":{inputs:[],name:"feeTokenAddressRecipient2",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPctToRecipient1()":{inputs:[],name:"feeTokenPctToRecipient1",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize(address,address,address,address,address,uint256,address,address,uint256)":{inputs:[{internalType:"address",name:"governorAddress_",type:"address"},{internalType:"contract IERC20",name:"acToken_",type:"address"},{internalType:"contract IERC20",name:"feeToken_",type:"address"},{internalType:"address",name:"acTokenAddressRecipient1_",type:"address"},{internalType:"address",name:"acTokenAddressRecipient2_",type:"address"},{internalType:"uint256",name:"acTokenPctToRecipient1_",type:"uint256"},{internalType:"address",name:"feeTokenAddressRecipient1_",type:"address"},{internalType:"address",name:"feeTokenAddressRecipient2_",type:"address"},{internalType:"uint256",name:"feeTokenPctToRecipient1_",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{acTokenAddressRecipient1_:"address who receives acTokenPctToRecipient1",acTokenAddressRecipient2_:"address who receives (100% - acTokenPctToRecipient1)",acTokenPctToRecipient1_:"percentage of the acToken balance to send to acTokenAddressRecipient1 [PREC]",acToken_:"collateral asset contract",feeTokenAddressRecipient1_:"address who receives feeTokenPctToRecipient1",feeTokenAddressRecipient2_:"address who receives (100% - feeTokenPctToRecipient1)",feeTokenPctToRecipient1_:"percentage of the feeToken balance to send to acTokenAddressRecipient1 [PREC]",feeToken_:"fee token contract",governorAddress_:"governor address"},notice:"contract initializer"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setAcToken(address)":{inputs:[{internalType:"contract IERC20",name:"newAcToken_",type:"address"}],name:"setAcToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{newAcToken_:"new AC token contract"},notice:"sets new AC token"},"setAcTokenAddressRecipient1(address)":{inputs:[{internalType:"address",name:"acTokenAddressRecipient1_",type:"address"}],name:"setAcTokenAddressRecipient1",outputs:[],stateMutability:"nonpayable",type:"function",params:{acTokenAddressRecipient1_:"new recipient1 address"},notice:"sets new recipient1 for AC token"},"setAcTokenAddressRecipient2(address)":{inputs:[{internalType:"address",name:"acTokenAddressRecipient2_",type:"address"}],name:"setAcTokenAddressRecipient2",outputs:[],stateMutability:"nonpayable",type:"function",params:{acTokenAddressRecipient2_:"new recipient1 address"},notice:"sets new recipient2 for AC token"},"setAcTokenPctToRecipient1(uint256)":{inputs:[{internalType:"uint256",name:"acTokenPctToRecipient1_",type:"uint256"}],name:"setAcTokenPctToRecipient1",outputs:[],stateMutability:"nonpayable",type:"function",params:{acTokenPctToRecipient1_:"new percentage for recipient1 [PREC]"},notice:"sets new percentage of AC token for recipient1"},"setFeeToken(address)":{inputs:[{internalType:"contract IERC20",name:"newFeeToken_",type:"address"}],name:"setFeeToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{newFeeToken_:"new fee token contract"},notice:"sets new fee token"},"setFeeTokenAddressRecipient1(address)":{inputs:[{internalType:"address",name:"feeTokenAddressRecipient1_",type:"address"}],name:"setFeeTokenAddressRecipient1",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeTokenAddressRecipient1_:"new recipient1 address"},notice:"sets new recipient1 for fee token"},"setFeeTokenAddressRecipient2(address)":{inputs:[{internalType:"address",name:"feeTokenAddressRecipient2_",type:"address"}],name:"setFeeTokenAddressRecipient2",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeTokenAddressRecipient2_:"new recipient2 address"},notice:"sets new recipient2 for fee token"},"setFeeTokenPctToRecipient1(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPctToRecipient1_",type:"uint256"}],name:"setFeeTokenPctToRecipient1",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeTokenPctToRecipient1_:"new percentage for recipient1 [PREC]"},notice:"sets new percentage of fee token for recipient1"},"split()":{inputs:[],name:"split",outputs:[],stateMutability:"nonpayable",type:"function",notice:"splits all the acToken and feeToken balances to the recipients addresses"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/collateral/coinbase/MocCACoinbase.sol:MocCACoinbase":{source:"contracts/collateral/coinbase/MocCACoinbase.sol",name:"MocCACoinbase",title:"MocCACoinbase: Moc Collateral Asset Coinbase",notice:"Moc protocol implementation using network Coinbase as Collateral Asset",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"coinbaseFailedTransferFallback()":{inputs:[],name:"coinbaseFailedTransferFallback",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize((((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256,bool),address,address,address,uint256,address),uint256,address))":{inputs:[{components:[{components:[{components:[{internalType:"address payable",name:"mocQueueAddress",type:"address"},{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"},{internalType:"bool",name:"allowDifferentRecipient",type:"bool"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams",type:"tuple"},{internalType:"uint256",name:"transferMaxGas",type:"uint256"},{internalType:"address",name:"coinbaseFailedTransferFallback",type:"address"}],internalType:"struct MocCACoinbase.InitializeParams",name:"initializeParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract      mocQueueAddress address for MocQueue contract      transferMaxGas max amount of gas forwarded on AC transfer      coinbaseFailedTransferFallback address who receives the funds when the coinbase unlock fails",params:{initializeParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TC nor fees, will be return to sender",params:{qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mintTCandTP(address,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTP(address,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",details:"any extra value, not spent on TP nor fees, will be return to sender",params:{qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends coinbase as Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTP(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTransferMaxGas(uint256)":{inputs:[{internalType:"uint256",name:"transferMaxGas_",type:"uint256"}],name:"setTransferMaxGas",outputs:[],stateMutability:"nonpayable",type:"function",params:{transferMaxGas_:"new max amount of gas forwarded on AC transfer"},notice:"sets max amount of gas forwarded on AC transfer"},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTC_:"amount of Collateral to swap",qTPmin_:"minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTC(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTP(address,address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferMaxGas()":{inputs:[],name:"transferMaxGas",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function must be overridden by the AC implementation",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/collateral/rc20/MocCARC20.sol:MocCARC20":{source:"contracts/collateral/rc20/MocCARC20.sol",name:"MocCARC20",title:"MocCARC20: Moc Collateral Asset RC20",notice:"Moc protocol implementation using a RC20 as Collateral Asset.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acToken()":{inputs:[],name:"acToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize((((address,address,address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,address,address,uint256,bool),address,address,address,uint256,address),address))":{inputs:[{components:[{components:[{components:[{internalType:"address payable",name:"mocQueueAddress",type:"address"},{internalType:"address",name:"feeTokenAddress",type:"address"},{internalType:"address",name:"feeTokenPriceProviderAddress",type:"address"},{internalType:"address",name:"tcTokenAddress",type:"address"},{internalType:"address",name:"mocFeeFlowAddress",type:"address"},{internalType:"address",name:"mocAppreciationBeneficiaryAddress",type:"address"},{internalType:"uint256",name:"protThrld",type:"uint256"},{internalType:"uint256",name:"liqThrld",type:"uint256"},{internalType:"uint256",name:"feeRetainer",type:"uint256"},{internalType:"uint256",name:"tcMintFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPFee",type:"uint256"},{internalType:"uint256",name:"feeTokenPct",type:"uint256"},{internalType:"uint256",name:"successFee",type:"uint256"},{internalType:"uint256",name:"appreciationFactor",type:"uint256"},{internalType:"uint256",name:"bes",type:"uint256"},{internalType:"address",name:"tcInterestCollectorAddress",type:"address"},{internalType:"uint256",name:"tcInterestRate",type:"uint256"},{internalType:"uint256",name:"tcInterestPaymentBlockSpan",type:"uint256"},{internalType:"address",name:"maxAbsoluteOpProviderAddress",type:"address"},{internalType:"address",name:"maxOpDiffProviderAddress",type:"address"},{internalType:"uint256",name:"decayBlockSpan",type:"uint256"},{internalType:"bool",name:"allowDifferentRecipient",type:"bool"}],internalType:"struct MocBaseBucket.InitializeBaseBucketParams",name:"initializeBaseBucketParams",type:"tuple"},{internalType:"address",name:"governorAddress",type:"address"},{internalType:"address",name:"pauserAddress",type:"address"},{internalType:"address",name:"mocCoreExpansion",type:"address"},{internalType:"uint256",name:"emaCalculationBlockSpan",type:"uint256"},{internalType:"address",name:"mocVendors",type:"address"}],internalType:"struct MocCore.InitializeCoreParams",name:"initializeCoreParams",type:"tuple"},{internalType:"address",name:"acTokenAddress",type:"address"}],internalType:"struct MocCARC20.InitializeParams",name:"initializeParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"governorAddress The address that will define when a change contract is authorized      pauserAddress The address that is authorized to pause this contract      acTokenAddress Collateral Asset Token contract address      tcTokenAddress Collateral Token contract address      mocFeeFlowAddress Moc Fee Flow contract address      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address      protThrld protected state threshold [PREC]      liqThrld liquidation coverage threshold [PREC]      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]      successFee pct of the gain because Pegged Tokens devaluation that is transferred        in Collateral Asset to Moc Fee Flow during the settlement [PREC]      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]      bes number of blocks between settlements      tcInterestCollectorAddress TC interest collector address      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment      maxAbsoluteOpProviderAddress max absolute operation provider address      maxOpDiffProviderAddress max operation difference provider address      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation      mocVendors address for MocVendors contract      mocQueueAddress address for MocQueue contract",params:{initializeParams_:"contract initializer params"},notice:"contract initializer"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTC(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTC_:"amount of Collateral Token to mint",recipient_:"address who receives the Collateral Token",vendor_:"address who receives a markup, `0x0` if not using a vendor, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mintTCandTP(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Collateral Token and Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not  Requires prior sender approval of Collateral Asset to this contract  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTP(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"mintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent",qTP_:"amount of Pegged Token to mint",recipient_:"address who receives the Pegged Token",tp_:"Pegged Token address to mint",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Asset and recipient receives Pegged Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not   Requires prior sender approval of Collateral Asset to this contract"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTP(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"refreshACBalance()":{inputs:[],name:"refreshACBalance",outputs:[],stateMutability:"nonpayable",type:"function",details:"Intended to be use as notification after an RC20 AC transfer to this contract",notice:"Refreshes the AC holdings for the Bucket"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTP(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"Maximum amount of Collateral Asset that can be spent in fees",qTC_:"Amount of owned Collateral Token to swap",qTPmin_:"Minimum amount of Pegged Token that `recipient_` expects to receive",recipient_:"Address who receives the Pegged Token",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends a Collateral Token and recipient receives Pegged Token.  `vendor_` receives a markup in Fee Token if possible or in qAC if not."},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTC(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTCmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTCmin_:"minimum amount of Collateral Token that `recipient_` expects to receive",qTP_:"amount of owned Pegged Token to swap",recipient_:"address who receives the Collateral Token",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives Collateral Token  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTP(address,address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tpFrom_",type:"address"},{internalType:"address",name:"tpTo_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qTPmin_",type:"uint256"},{internalType:"uint256",name:"qACmax_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"swapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmax_:"maximum amount of Collateral Asset that can be spent in fees",qTP_:"amount of owned Pegged Token to swap",qTPmin_:"minimum amount of target Pegged Token that `recipient_` expects to receive",recipient_:"address who receives the target Pegged Token",tpFrom_:"owned Pegged Token address",tpTo_:"target Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends a Pegged Token and recipient receives another one  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function must be overridden by the AC implementation",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocBaseBucket.sol:MocBaseBucket":{source:"contracts/core/MocBaseBucket.sol",name:"MocBaseBucket",title:"MocBaseBucket: Moc Collateral Bag",details:"Abstracts all rw operations on the main bucket and expose all calculations relative to its state.",notice:"MocBaseBucket holds Bucket Zero state, both for the Collateral Bag and PeggedTokens Items.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCommons.sol:MocCommons":{source:"contracts/core/MocCommons.sol",name:"MocCommons",title:"MocCommons",details:"To bypass the 24kb size limitation on MocCore we use MocCoreExpansion contract. Some functions  are implemented there and MocCore delegates calls to it. To achieve that, we need both to have the  exact same storage layout and be able to access the same common functions.  MocCommons contract serves as the last shared ancestor in the line of inheritance for them,  and all storage variables must be either declared here or in a parent contract.  Declaring variables after this point could result in storage collisions.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCore.sol:MocCore":{source:"contracts/core/MocCore.sol",name:"MocCore",title:"MocCore",notice:"MocCore nucleates all the basic MoC functionality and tool set. It allows Collateral asset aware contracts to implement the main mint/redeem operations.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocCoreExpansion.sol:MocCoreExpansion":{source:"contracts/core/MocCoreExpansion.sol",name:"MocCoreExpansion",title:"MocCoreExpansion",details:"IMPORTANT NOTES:  1. MocCore and MocCoreExpansion must have always the same storage layout to avoid collisions  2. Because MocCore is upgradeable and delegates calls to MocCoreExpansion, it cannot be upgradeable because      a proxy contract cannot delegate calls to another proxy contract. So, for any MocCoreExpansion upgrade      you must deploy a new implementation and set it to MocCore.",notice:"This contract is used as an expansion of MocCore because 24kb size limitation  MocCore delegate some function calls to it.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is called by MocCore contract using it's context with delegate call  Checks done there:  -  onlyAuthorizedChanger: the caller must have governance authorization.tpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements:  - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is called by MocCore contract using it's context with delegate call  Checks done there:  -  onlyAuthorizedChanger: the caller must have governance authorization.tpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address,address,address,uint256)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"sender_",type:"address"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"uint256",name:"mocACBalance",type:"uint256"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"This function is called by MocCore contract using it's context with delegate call  The equivalent AC given the liquidation frozen price(qACRedeemed) is transferred  to the `recipient_` by MocCore contract  Checks done there:  -  notPaused: the contract must be unpaused",params:{recipient_:"address who receives the AC",sender_:"address owner of the TP to be redeemed",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTCandTPto((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"mintTCandTPto",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"i_ Pegged Token index      qTP_ amount of Pegged Token to mint      qACmax_ maximum amount of Collateral Asset that can be spent      sender_ address who sends Collateral Asset      recipient_ address who receives the Collateral Token and Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is applied",params:{params_:"mint TC and TP function parameters"},returns:{feeCalcs:"platform fee detail breakdown",qACtotalNeeded:"amount of AC used to mint Collateral Token and Pegged Token",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTCtoMint:"amount of Collateral Token minted"},notice:"mint Collateral Token and Pegged Token in exchange for Collateral Asset  This operation is done without checking coverage  Collateral Token and Pegged Token are minted in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qAC sent are insufficient."},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPto((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"redeemTCandTPto",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"i_ Pegged Token index      qTC_ amount of Collateral Token to redeem      qTP_ maximum amount of Pegged Token to redeem      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive      sender_ address who sends Collateral Token and Pegged Token      recipient_ address who receives the Collateral Asset      vendor_ address who receives a markup. If its address(0) no markup is applied",params:{params_:"redeem TC and TP function parameters"},returns:{feeCalcs:"platform fee detail breakdown",qACtoRedeem:"amount of AC sent to `recipient_`",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoRedeem:"amount of Pegged Token redeemed"},notice:"redeem Collateral Asset in exchange for Collateral Token and Pegged Token  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPto((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"swapTCforTPto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calli_ Pegged Token index      qTC_ amount of Collateral Token to swap      qTPmin_ minimum amount of Pegged Token Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Collateral Token      recipient_ address who receives the Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TC for TP function parameters"},returns:{qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoMint:"amount of Pegged Token minted"},notice:"swap Collateral Token to Pegged Token"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCto((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"swapTPforTCto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calli_ Pegged Token index      qTP_ amount Pegged Token to swap      qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Pegged Token      recipient_ address who receives Collateral Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TP for TC function parameters"},returns:{feeCalcs:"struct with:",qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTCtoMint:"amount of Collateral Token minted"},notice:"swap Pegged Token to Collateral Token"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPto((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"swapTPforTPto",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPtoMint",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"payable",type:"function",details:"This function is called by MocCore contract using it's context with delegate calliFrom_ owned Pegged Token index      iTo_ target Pegged Token index      qTP_ amount of owned Pegged Token to swap      qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive      qACmax_ maximum amount of Collateral Asset that can be spent in fees      sender_ address who sends the Pegged Token      recipient_ address who receives the target Pegged Token      vendor_ address who receives a markup. If its address(0) no markup is appliedqACFee amount of AC needed to pay fees      qFeeToken amount of Fee Token needed to pay fess      qACVendorMarkup amount of AC needed to pay vendor markup      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup",params:{params_:"swap TP for TP function parameters"},returns:{feeCalcs:"struct with:",qACSurcharges:"amount of AC used to pay fees and markup",qFeeTokenTotalNeeded:"amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead",qTPtoMint:"amount of Pegged Token minted"},notice:"swap Pegged Token to another one  This operation is done without checking coverage unless the target coverage for  received Pegged Token is greater than the Pegged Token sent"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocEma.sol:MocEma":{source:"contracts/core/MocEma.sol",name:"MocEma",title:"MocEma: Exponential Moving Average",details:"More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing",notice:"Moc Ema, provides a set of methods that allows to calculate and track Exponential Moving Average for each of the pegged Tokens.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/core/MocOperations.sol:MocOperations":{source:"contracts/core/MocOperations.sol",name:"MocOperations",title:"MocOperations",notice:"All the Moc Protocol operations are grouped in this contract",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"ContractLiquidated()":{anonymous:!1,inputs:[],name:"ContractLiquidated",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"LiqTPRedeemed(address,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"}],name:"LiqTPRedeemed",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"PeggedTokenChange(uint256,(address,address,uint256,uint256,uint256,uint256,uint256))":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"i_",type:"uint256"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],indexed:!1,internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"PeggedTokenChange",type:"event"},"SettlementExecuted()":{anonymous:!1,inputs:[],name:"SettlementExecuted",type:"event"},"SuccessFeeDistributed(uint256,uint256[])":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"mocGain_",type:"uint256"},{indexed:!1,internalType:"uint256[]",name:"tpGain_",type:"uint256[]"}],name:"SuccessFeeDistributed",type:"event"},"TCInterestPayment(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"interestAmount_",type:"uint256"}],name:"TCInterestPayment",type:"event"},"TPemaUpdated(uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"i_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"oldTPema_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newTPema_",type:"uint256"}],name:"TPemaUpdated",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"absoluteAccumulator()":{inputs:[],name:"absoluteAccumulator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"addPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"addPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to add      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - tpTokenAddress must be a MocRC20, with mint, burn roles already settled  for this contract",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"add a Pegged Token to the protocol"},"allowDifferentRecipient()":{inputs:[],name:"allowDifferentRecipient",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"appreciationFactor()":{inputs:[],name:"appreciationFactor",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bes()":{inputs:[],name:"bes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"bns()":{inputs:[],name:"bns",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calcCtargemaCA()":{inputs:[],name:"calcCtargemaCA",outputs:[{internalType:"uint256",name:"ctargemaCA",type:"uint256"}],stateMutability:"view",type:"function",details:"qAC = nTP / pACtp      ctargemaCA = ∑(ctargemaTP * qAC) / ∑(qAC)",returns:{ctargemaCA:"[PREC]"},notice:"calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decayBlockSpan()":{inputs:[],name:"decayBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"differentialAccumulator()":{inputs:[],name:"differentialAccumulator",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"editPeggedToken((address,address,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],name:"editPeggedToken",outputs:[],stateMutability:"nonpayable",type:"function",details:"Note that the ema value, should consider `nextEmaCalculation`  This function is implemented in MocCoreExpansion but with this contract contexttpTokenAddress Pegged Token contract address to identify the token to edit      priceProviderAddress Pegged Token price provider contract address      tpCtarg Pegged Token target coverage [PREC]      tpMintFee additional fee pct applied on mint [PREC]      tpRedeemFee additional fee pct applied on redeem [PREC]      tpEma initial Pegged Token exponential moving average [PREC]      tpEmaSf Pegged Token smoothing factor [PREC]  Requirements: - the caller must have governance authorization. - the tpTokenAddress must exists",params:{peggedTokenParams_:"params of Pegged Token to add"},notice:"modifies a Pegged Token of the protocol"},"emaCalculationBlockSpan()":{inputs:[],name:"emaCalculationBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"evalLiquidation()":{inputs:[],name:"evalLiquidation",outputs:[],stateMutability:"nonpayable",type:"function",notice:"evaluates if liquidation threshold has been reached and liq is Enabled. If so forces contracts liquidation, blocking all mint & redeem operations. May emit a {ContractLiquidated} event."},"execMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params_",type:"tuple"}],name:"execMintTC",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCto for details"},"execMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params_",type:"tuple"}],name:"execMintTCandTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTCandTPto for details"},"execMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params_",type:"tuple"}],name:"execMintTP",outputs:[{internalType:"uint256",name:"qACtotalNeeded",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _mintTPto for details"},"execRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params_",type:"tuple"}],name:"execRedeemTC",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCto for details"},"execRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params_",type:"tuple"}],name:"execRedeemTCandTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qTPRedeemed",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTCandTPto for details"},"execRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params_",type:"tuple"}],name:"execRedeemTP",outputs:[{internalType:"uint256",name:"qACtoRedeem",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _redeemTPto for details"},"execSettlement()":{inputs:[],name:"execSettlement",outputs:[],stateMutability:"nonpayable",type:"function",notice:"this function is executed during settlement.  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee"},"execSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params_",type:"tuple"}],name:"execSwapTCforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTCforTPto for details"},"execSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params_",type:"tuple"}],name:"execSwapTPforTC",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTCMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTCto for details"},"execSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params_",type:"tuple"}],name:"execSwapTPforTP",outputs:[{internalType:"uint256",name:"qACSurcharges",type:"uint256"},{internalType:"uint256",name:"qTPMinted",type:"uint256"},{internalType:"uint256",name:"qFeeTokenTotalNeeded",type:"uint256"},{components:[{internalType:"uint256",name:"qACFee",type:"uint256"},{internalType:"uint256",name:"qFeeToken",type:"uint256"},{internalType:"uint256",name:"qACVendorMarkup",type:"uint256"},{internalType:"uint256",name:"qFeeTokenVendorMarkup",type:"uint256"}],internalType:"struct MocCommons.FeeCalcs",name:"feeCalcs",type:"tuple"}],stateMutability:"nonpayable",type:"function",notice:"executes Operation based on params, only mocQueue allowed see MocCore _swapTPforTPto for details"},"feeRetainer()":{inputs:[],name:"feeRetainer",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeToken()":{inputs:[],name:"feeToken",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTokenPct()":{inputs:[],name:"feeTokenPct",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"feeTokenPriceProvider()":{inputs:[],name:"feeTokenPriceProvider",outputs:[{internalType:"contract IPriceProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"getBts()":{inputs:[],name:"getBts",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"get the number of blocks remaining for settlement"},"getCglb()":{inputs:[],name:"getCglb",outputs:[{internalType:"uint256",name:"cglob",type:"uint256"}],stateMutability:"view",type:"function",returns:{cglob:"[PREC]"},notice:"get bucket global coverage"},"getLckAC()":{inputs:[],name:"getLckAC",outputs:[{internalType:"uint256",name:"lckAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{lckAC:"[PREC]"},notice:"get amount of Collateral Asset locked by Pegged Token"},"getLeverageTC()":{inputs:[],name:"getLeverageTC",outputs:[{internalType:"uint256",name:"leverageTC",type:"uint256"}],stateMutability:"view",type:"function",returns:{leverageTC:"[PREC]"},notice:"get Collateral Token leverage"},"getPACtp(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getPACtp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{tp_:"Pegged Token address"},returns:{_0:"price [PREC]"},notice:"get how many Pegged Token equal 1 Collateral Asset"},"getPTCac()":{inputs:[],name:"getPTCac",outputs:[{internalType:"uint256",name:"pTCac",type:"uint256"}],stateMutability:"view",type:"function",returns:{pTCac:"[PREC]"},notice:"get Collateral Token price"},"getTCAvailableToRedeem()":{inputs:[],name:"getTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"tcAvailableToRedeem",type:"uint256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TC available to redeem. Consider it an approximation.",returns:{tcAvailableToRedeem:"[N]"},notice:"get amount of Collateral Token available to redeem"},"getTPAvailableToMint(address)":{inputs:[{internalType:"address",name:"tp_",type:"address"}],name:"getTPAvailableToMint",outputs:[{internalType:"int256",name:"tpAvailableToMint",type:"int256"}],stateMutability:"view",type:"function",details:"because it is a view function we are not calculating the new ema,  since we are using the last ema calculation, this may differ a little from the real amount  of TP available to mint. Consider it an approximation.",params:{tp_:"Pegged Token address"},returns:{tpAvailableToMint:"[N]"},notice:"get amount of Pegged Token available to mint"},"getTotalACavailable()":{inputs:[],name:"getTotalACavailable",outputs:[{internalType:"uint256",name:"totalACavailable",type:"uint256"}],stateMutability:"view",type:"function",returns:{totalACavailable:"[N]"},notice:"get total Collateral Asset available"},"getTpAmount()":{inputs:[],name:"getTpAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"return current amount of Tps"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"isLiquidationReached()":{inputs:[],name:"isLiquidationReached",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",returns:{_0:"true if liquidation state is reached, false otherwise"},notice:"If liquidation is enabled, verifies if forced liquidation has been reached, checking if globalCoverage <= liquidation"},"lastOperationBlockNumber()":{inputs:[],name:"lastOperationBlockNumber",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liqEnabled()":{inputs:[],name:"liqEnabled",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"liqRedeemTP(address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"address",name:"recipient_",type:"address"}],name:"liqRedeemTP",outputs:[{internalType:"uint256",name:"qACRedeemed",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{recipient_:"address who receives the AC",tp_:"Pegged Token address"},returns:{qACRedeemed:"amount of AC sent to `recipient_`"},notice:"Allow redeem on liquidation state, user Peg balance gets burned and he receives the equivalent AC given the liquidation frozen price."},"liqThrld()":{inputs:[],name:"liqThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"liquidated()":{inputs:[],name:"liquidated",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxAbsoluteOpProvider()":{inputs:[],name:"maxAbsoluteOpProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxOpDiffProvider()":{inputs:[],name:"maxOpDiffProvider",outputs:[{internalType:"contract IDataProvider",name:"",type:"address"}],stateMutability:"view",type:"function"},"maxQACToMintTP()":{inputs:[],name:"maxQACToMintTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"maxQACToRedeemTP()":{inputs:[],name:"maxQACToRedeemTP",outputs:[{internalType:"uint256",name:"maxQAC",type:"uint256"}],stateMutability:"view",type:"function",returns:{maxQAC:"minimum regarding maxAbsoluteOperation and maxOperationalDifference"},notice:"gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators // TODO: move this function to a MocView contract"},"mintTCandTPFee()":{inputs:[],name:"mintTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mocAppreciationBeneficiaryAddress()":{inputs:[],name:"mocAppreciationBeneficiaryAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocFeeFlowAddress()":{inputs:[],name:"mocFeeFlowAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocQueue()":{inputs:[],name:"mocQueue",outputs:[{internalType:"address payable",name:"",type:"address"}],stateMutability:"view",type:"function"},"mocVendors()":{inputs:[],name:"mocVendors",outputs:[{internalType:"contract MocVendors",name:"",type:"address"}],stateMutability:"view",type:"function"},"nACcb()":{inputs:[],name:"nACcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nTCcb()":{inputs:[],name:"nTCcb",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextEmaCalculation()":{inputs:[],name:"nextEmaCalculation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"nextTCInterestPayment()":{inputs:[],name:"nextTCInterestPayment",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pegContainer(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"pegContainer",outputs:[{internalType:"uint256",name:"nTP",type:"uint256"},{internalType:"contract IPriceProvider",name:"priceProvider",type:"address"}],stateMutability:"view",type:"function"},"peggedTokenIndex(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"peggedTokenIndex",outputs:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"exists",type:"bool"}],stateMutability:"view",type:"function"},"protThrld()":{inputs:[],name:"protThrld",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"qACLockedInPending()":{inputs:[],name:"qACLockedInPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTC(uint256,uint256,address,address)":{inputs:[{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"amount of Collateral Token to redeem",recipient_:"address who receives the Collateral Asset",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Collateral Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"redeemTCandTP(address,uint256,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTC_",type:"uint256"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"Minimum amount of Collateral Asset that `recipient_` expects to receive",qTC_:"Maximum amount of Collateral Token to redeem",qTP_:"Maximum amount of Pegged Token to redeem",recipient_:"Address who receives the Collateral Asset",tp_:"Pegged Token address",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not  This operation is done without checking coverage  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price  and global coverage are not modified.  Reverts if qTP sent are insufficient."},"redeemTCandTPFee()":{inputs:[],name:"redeemTCandTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"redeemTP(address,uint256,uint256,address,address)":{inputs:[{internalType:"address",name:"tp_",type:"address"},{internalType:"uint256",name:"qTP_",type:"uint256"},{internalType:"uint256",name:"qACmin_",type:"uint256"},{internalType:"address",name:"recipient_",type:"address"},{internalType:"address",name:"vendor_",type:"address"}],name:"redeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",params:{qACmin_:"minimum amount of Collateral Asset that `recipient_` expects to receive",qTP_:"amount of Pegged Token to redeem",recipient_:"address who receives the Collateral Asset",tp_:"Pegged Token address to redeem",vendor_:"address who receives a markup, `0x0` if not using a vendor"},returns:{operId:"Identifier to track the Operation lifecycle"},notice:"caller sends Pegged Token and recipient receives Collateral Asset  `vendor_` receives a markup in Fee Token if possible or in qAC if not"},"setAllowDifferentRecipient(bool)":{inputs:[{internalType:"bool",name:"allowDifferentRecipient_",type:"bool"}],name:"setAllowDifferentRecipient",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets allowDifferentRecipient param",params:{allowDifferentRecipient_:"allows users operate using another address as the recipient of the tokens"}},"setAppreciationFactor(uint256)":{inputs:[{internalType:"uint256",name:"appreciationFactor_",type:"uint256"}],name:"setAppreciationFactor",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets appreciation Factor value.",params:{appreciationFactor_:"pct of the gain because Pegged Tokens devaluation that is returned in Pegged Tokens to appreciation beneficiary during the settlement [PREC]"}},"setBes(uint256)":{inputs:[{internalType:"uint256",name:"bes_",type:"uint256"}],name:"setBes",outputs:[],stateMutability:"nonpayable",type:"function",details:"bns is not automatically updated, you have to wait until next settlement to be made : bns = block.number + bes*",params:{bes_:"number of blocks between settlements"}},"setDecayBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"decayBlockSpan_",type:"uint256"}],name:"setDecayBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets flux capacitor decay block span",params:{decayBlockSpan_:"flux capacitor decay block span"}},"setEmaCalculationBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"blockSpan_",type:"uint256"}],name:"setEmaCalculationBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"nextEmaCalculation is not automatically updated, you have to wait until next  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan*",params:{blockSpan_:"Defines how many blocks should pass between EMA calculations"}},"setFeeRetainer(uint256)":{inputs:[{internalType:"uint256",name:"feeRetainer_",type:"uint256"}],name:"setFeeRetainer",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee pct to be retainer on AC fees payments as AC re-injection.",params:{feeRetainer_:"pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenAddress_",type:"address"}],name:"setFeeTokenAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token contract address",params:{mocFeeTokenAddress_:"Fee Token new contract address"}},"setFeeTokenPct(uint256)":{inputs:[{internalType:"uint256",name:"feeTokenPct_",type:"uint256"}],name:"setFeeTokenPct",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.",params:{feeTokenPct_:"pct applied on the top of the operation`s fee when using Fee Token  as fee payment method [PREC]  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setFeeTokenPriceProviderAddress(address)":{inputs:[{internalType:"address",name:"mocFeeTokenPriceProviderAddress_",type:"address"}],name:"setFeeTokenPriceProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Fee Token price provider contract address",params:{mocFeeTokenPriceProviderAddress_:"Fee Token price provider new contract address"}},"setLiqEnabled(bool)":{inputs:[{internalType:"bool",name:"liqEnabled_",type:"bool"}],name:"setLiqEnabled",outputs:[],stateMutability:"nonpayable",type:"function",details:"enables and disables the liquidation mechanism.",params:{liqEnabled_:"is liquidation enabled"}},"setLiqThrld(uint256)":{inputs:[{internalType:"uint256",name:"liqThrld_",type:"uint256"}],name:"setLiqThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the liq threshold configuration param",params:{liqThrld_:"liquidation threshold"}},"setMaxAbsoluteOpProviderAddress(address)":{inputs:[{internalType:"address",name:"maxAbsoluteOpProviderAddress_",type:"address"}],name:"setMaxAbsoluteOpProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max absolute operation provider address",params:{maxAbsoluteOpProviderAddress_:"max absolute operation provider address"}},"setMaxOpDiffProviderAddress(address)":{inputs:[{internalType:"address",name:"maxOpDiffProviderAddress_",type:"address"}],name:"setMaxOpDiffProviderAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets max operation difference provider address",params:{maxOpDiffProviderAddress_:"max operation difference provider address"}},"setMintTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"mintTCandTPFee_",type:"uint256"}],name:"setMintTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when mint Collateral Token and Pegged Token in one operation.",params:{mintTCandTPFee_:"additional fee pct applied on mint Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setMocAppreciationBeneficiaryAddress(address)":{inputs:[{internalType:"address",name:"mocAppreciationBeneficiaryAddress_",type:"address"}],name:"setMocAppreciationBeneficiaryAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Appreciation Beneficiary Address",params:{mocAppreciationBeneficiaryAddress_:"moc Appreciation Beneficiary new address"}},"setMocCoreExpansion(address)":{inputs:[{internalType:"address",name:"mocCoreExpansion_",type:"address"}],name:"setMocCoreExpansion",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Core Expansion contract address",params:{mocCoreExpansion_:"moc core expansion new contract address"}},"setMocFeeFlowAddress(address)":{inputs:[{internalType:"address",name:"mocFeeFlowAddress_",type:"address"}],name:"setMocFeeFlowAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Fee Flow contract address",params:{mocFeeFlowAddress_:"moc Fee Flow new contract address"}},"setMocQueue(address)":{inputs:[{internalType:"address payable",name:"mocQueueAddress_",type:"address"}],name:"setMocQueue",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Queue contract address",params:{mocQueueAddress_:"moc queue new contract address"}},"setMocVendors(address)":{inputs:[{internalType:"address",name:"mocVendors_",type:"address"}],name:"setMocVendors",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets Moc Vendors contract address",params:{mocVendors_:"moc Vendors new contract address"}},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setProtThrld(uint256)":{inputs:[{internalType:"uint256",name:"protThrld_",type:"uint256"}],name:"setProtThrld",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the value of the protected threshold configuration param",params:{protThrld_:"coverage protected state threshold [PREC]"}},"setRedeemTCandTPFee(uint256)":{inputs:[{internalType:"uint256",name:"redeemTCandTPFee_",type:"uint256"}],name:"setRedeemTCandTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when redeem Collateral Token and Pegged Token in one operation.",params:{redeemTCandTPFee_:"additional fee pct applied on redeem Collateral Token and Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSuccessFee(uint256)":{inputs:[{internalType:"uint256",name:"successFee_",type:"uint256"}],name:"setSuccessFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets success Fee value.",params:{successFee_:"pct of the gain because Pegged Tokens devaluation that is transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]"}},"setSwapTCforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTCforTPFee_",type:"uint256"}],name:"setSwapTCforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap Collateral Token for a Pegged Token.",params:{swapTCforTPFee_:"additional fee pct applied on swap Collateral Token for a Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTCFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTCFee_",type:"uint256"}],name:"setSwapTPforTCFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for Collateral Token.",params:{swapTPforTCFee_:"additional fee pct applied on swap a Pegged Token for Collateral Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setSwapTPforTPFee(uint256)":{inputs:[{internalType:"uint256",name:"swapTPforTPFee_",type:"uint256"}],name:"setSwapTPforTPFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged when swap a Pegged Token for another Pegged Token.",params:{swapTPforTPFee_:"additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTCInterestCollectorAddress(address)":{inputs:[{internalType:"address",name:"tcInterestCollectorAddress_",type:"address"}],name:"setTCInterestCollectorAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest collector address",params:{tcInterestCollectorAddress_:"TC interest collector address"}},"setTCInterestPaymentBlockSpan(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestPaymentBlockSpan_",type:"uint256"}],name:"setTCInterestPaymentBlockSpan",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest payment block spannextTCInterestPayment is not automatically updated, you have to wait until next  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan",params:{tcInterestPaymentBlockSpan_:"amount of blocks to wait for next TC interest payment"}},"setTCInterestRate(uint256)":{inputs:[{internalType:"uint256",name:"tcInterestRate_",type:"uint256"}],name:"setTCInterestRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets TC interest rate",params:{tcInterestRate_:"pct interest charged to TC holders on the total collateral in the protocol [PREC]"}},"setTcMintFee(uint256)":{inputs:[{internalType:"uint256",name:"tcMintFee_",type:"uint256"}],name:"setTcMintFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral mint.",params:{tcMintFee_:"addition fee pct applied on Collateral Tokens mint [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"setTcRedeemFee(uint256)":{inputs:[{internalType:"uint256",name:"tcRedeemFee_",type:"uint256"}],name:"setTcRedeemFee",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets the fee charged on Token Collateral redeem.",params:{tcRedeemFee_:"addition fee pct applied on Collateral Tokens redeem [PREC] 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18"}},"shouldCalculateEma()":{inputs:[],name:"shouldCalculateEma",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the necessary span has pass since last ema update"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"successFee()":{inputs:[],name:"successFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTCforTPFee()":{inputs:[],name:"swapTCforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTCFee()":{inputs:[],name:"swapTPforTCFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"swapTPforTPFee()":{inputs:[],name:"swapTPforTPFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcHoldersInterestPayment()":{inputs:[],name:"tcHoldersInterestPayment",outputs:[],stateMutability:"nonpayable",type:"function",details:"-   The amount is not differential, it's a snapshot of the moment it's executed  -   It does not check coverage",notice:"executes the interest payment of the TC holders  can only be executed after a block span"},"tcInterestCollectorAddress()":{inputs:[],name:"tcInterestCollectorAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"tcInterestPaymentBlockSpan()":{inputs:[],name:"tcInterestPaymentBlockSpan",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcInterestRate()":{inputs:[],name:"tcInterestRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcMintFee()":{inputs:[],name:"tcMintFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcRedeemFee()":{inputs:[],name:"tcRedeemFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tcToken()":{inputs:[],name:"tcToken",outputs:[{internalType:"contract MocTC",name:"",type:"address"}],stateMutability:"view",type:"function"},"tpCtarg(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpCtarg",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpEma(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpEma",outputs:[{internalType:"uint256",name:"ema",type:"uint256"},{internalType:"uint256",name:"sf",type:"uint256"}],stateMutability:"view",type:"function"},"tpLiqPrices(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpLiqPrices",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpMintFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpMintFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpRedeemFees(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"tpRedeemFees",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"tpTokens(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"tpTokens",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"unlockACInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qACToUnlock_",type:"uint256"}],name:"unlockACInPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function must be overridden by the AC implementation",params:{owner_:"funds owner, address to be returned to",qACToUnlock_:"AC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's funds"},"unlockTCInPending(address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"uint256",name:"qTCToUnlock_",type:"uint256"}],name:"unlockTCInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTCToUnlock_:"TC amount to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unlockTPInPending(address,address,uint256)":{inputs:[{internalType:"address",name:"owner_",type:"address"},{internalType:"contract IERC20Upgradeable",name:"tpToken_",type:"address"},{internalType:"uint256",name:"qTPToUnlock_",type:"uint256"}],name:"unlockTPInPending",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner_:"funds owner, address to be returned to",qTPToUnlock_:"TP amount to be unlocked",tpToken_:"TP to be unlocked"},notice:"while executing a pending Operation, if it fails we need to unlock user's tokens"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateEmas()":{inputs:[],name:"updateEmas",outputs:[],stateMutability:"nonpayable",type:"function",details:"All price provider prices must be available, fails if not",notice:"If time, calculates the EMA for all the Pegged Token prices."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/governance/Governed.sol:Governed":{source:"contracts/governance/Governed.sol",name:"Governed",title:"Governed",details:"This contract is not usable on its own since it does not have any _productive useful_ behavior The only purpose of this contract is to define some useful modifiers and functions to be used on the governance aspect of the child contract",notice:"Base contract to be inherited by governed contracts",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"}}},"contracts/governance/MocUpgradable.sol:MocUpgradable":{source:"contracts/governance/MocUpgradable.sol",name:"MocUpgradable",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/governance/Stoppable.sol:Stoppable":{source:"contracts/governance/Stoppable.sol",name:"Stoppable",title:"Stoppable",details:"This contract was heavily based on the _Pausable_ contract of openzeppelin-eth but it was modified in order to being able to turn on and off its stoppability",notice:"Allow a contract to be paused through the stopper subsystem. This contracts is able to disable the stoppability feature through governance.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"}}},"contracts/governance/changerTemplates/AddPeggedTokenChangerTemplate.sol:AddPeggedTokenChangerTemplate":{source:"contracts/governance/changerTemplates/AddPeggedTokenChangerTemplate.sol",name:"AddPeggedTokenChangerTemplate",title:"AddPeggedTokenChangerTemplate",details:"This template only considers adding MocRC20, they are governed and use EnumerableAccessControl for roles. For any other type of Pegged Token it must be modified to achieve similar validations",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus governance system. It allows the addition of a new Pegged Token to the system.",constructor:{inputs:[{internalType:"contract MocCore",name:"mocCore_",type:"address"},{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"peggedTokenParams_",type:"tuple"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"getPeggedTokenParams()":{inputs:[],name:"getPeggedTokenParams",outputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns the Pegged Token Params configurations that's going to be added"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCore",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/governance/changerTemplates/EditPeggedTokenChangerTemplate.sol:EditPeggedTokenChangerTemplate":{source:"contracts/governance/changerTemplates/EditPeggedTokenChangerTemplate.sol",name:"EditPeggedTokenChangerTemplate",title:"EditPeggedTokenChangerTemplate",details:"IMPORTANT: This template provides a basic framework for Pegged Token params editions, but it's not intended to be use out of the box. Depending on the combination of params you need to edit, you'll need to generate new methods, disable others and adjust the  `PARAMS_CHANGED` config. In this example, only the priceProvider address is used as showcase. Also please notice that params values, are not verify on the target contract, so it's desirable that the changer itself do it. See `AditPeggedTokenChangerTemplate.sol` for reference.",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus  governance system. It allows the edition of an existent Pegged Token to the system.",constructor:{inputs:[{internalType:"contract MocCore",name:"mocCore_",type:"address"},{internalType:"contract IMocRC20",name:"tpToEdit_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"getPeggedTokenParams()":{inputs:[],name:"getPeggedTokenParams",outputs:[{components:[{internalType:"address",name:"tpTokenAddress",type:"address"},{internalType:"address",name:"priceProviderAddress",type:"address"},{internalType:"uint256",name:"tpCtarg",type:"uint256"},{internalType:"uint256",name:"tpMintFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemFee",type:"uint256"},{internalType:"uint256",name:"tpEma",type:"uint256"},{internalType:"uint256",name:"tpEmaSf",type:"uint256"}],internalType:"struct PeggedTokenParams",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns the Pegged Token Params configurations that's going to be edited"},"mocCore()":{inputs:[],name:"mocCore",outputs:[{internalType:"contract MocCore",name:"",type:"address"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"paramSet()":{inputs:[],name:"paramSet",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setPriceProvider(address)":{inputs:[{internalType:"address",name:"priceProvider_",type:"address"}],name:"setPriceProvider",outputs:[],stateMutability:"nonpayable",type:"function",params:{priceProvider_:"new pegged token price provider"},notice:"contract initializer"},"tpToEdit()":{inputs:[],name:"tpToEdit",outputs:[{internalType:"contract IMocRC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}}},"contracts/governance/changerTemplates/GovernanceChangerTemplate.sol:GovernanceChangerTemplate":{source:"contracts/governance/changerTemplates/GovernanceChangerTemplate.sol",name:"GovernanceChangerTemplate",title:"GovernanceChangerTemplate",notice:"This contract is a ChangeContract intended to be used with Moc Aeropulus  governance system.",constructor:{inputs:[{internalType:"contract Governed",name:"governed_",type:"address"},{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture",notice:"Execute the changes."},"governed()":{inputs:[],name:"governed",outputs:[{internalType:"contract Governed",name:"",type:"address"}],stateMutability:"view",type:"function"},"newGovernor()":{inputs:[],name:"newGovernor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/governance/changerTemplates/UpgraderUUPSChangerTemplate.sol:UpgraderUUPSChangerTemplate":{source:"contracts/governance/changerTemplates/UpgraderUUPSChangerTemplate.sol",name:"UpgraderUUPSChangerTemplate",title:"UpgraderUUPSChangerTemplate",notice:"This contract is a ChangeContract intended to be used when upgrading a MOC UUPS contract, through the Moc upgradeability system. This doesn't initialize the upgraded contract, that should be done extending this one or taking it as a guide",methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called by the governor, but this contract does not check that explicitly because it is not its responsibility in the current architecture IMPORTANT: This function should not be overridden, you should only redefine _beforeUpgrade and _afterUpgrade methods to use this template",notice:"Execute the changes."},"newImplementation()":{inputs:[],name:"newImplementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxy()":{inputs:[],name:"proxy",outputs:[{internalType:"contract UUPSUpgradeable",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IChangeContract.sol:IChangeContract":{source:"contracts/interfaces/IChangeContract.sol",name:"IChangeContract",title:"IChangeContract",details:"If you plan to do some changes to a system governed by this project you should write a contract that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance system is fully in place.",notice:"This interface is the one used by the governance system.",methods:{"execute()":{inputs:[],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Override this function with a recipe of the changes to be done when this ChangeContract is executed"}}},"contracts/interfaces/IDataProvider.sol:IDataProvider":{source:"contracts/interfaces/IDataProvider.sol",name:"IDataProvider",title:"IDataProvider",details:"https://github.com/money-on-chain/Amphiraos-Oracle",notice:"Amphiraos-Oracle Interface for peeking the data from an oracle",methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"data",type:"bytes32"},{internalType:"bool",name:"valid",type:"bool"}],stateMutability:"view",type:"function",params:{data:"peeked",valid:"true if the data is valid"},notice:"returns the given `data` if `valid`"}}},"contracts/interfaces/IDispatcher.sol:IDispatcher":{source:"contracts/interfaces/IDispatcher.sol",name:"IDispatcher",title:"IDispatcher TODO: add doc",methods:{"getCombinedCglb(uint256)":{inputs:[{internalType:"uint256",name:"localCglb_",type:"uint256"}],name:"getCombinedCglb",outputs:[{internalType:"uint256",name:"combinedCglb",type:"uint256"}],stateMutability:"view",type:"function"},"getRealTCAvailableToRedeem(uint256)":{inputs:[{internalType:"uint256",name:"localTCAvailableToRedeem_",type:"uint256"}],name:"getRealTCAvailableToRedeem",outputs:[{internalType:"uint256",name:"realTCAvailableToRedeem_",type:"uint256"}],stateMutability:"view",type:"function"},"getRealTPAvailableToMint(uint256)":{inputs:[{internalType:"uint256",name:"localTPAvailableToMint_",type:"uint256"}],name:"getRealTPAvailableToMint",outputs:[{internalType:"uint256",name:"realTCAvailableToMint_",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IGovernor.sol:IGovernor":{source:"contracts/interfaces/IGovernor.sol",name:"IGovernor",title:"IGovernor",details:"This interface **MUST** be compatible with the corresponding Governance instance used on Production, from https://github.com/money-on-chain/Areopagus-Governance",notice:"Governor interface. This functions should be overwritten to enable the communication with the rest of the system",methods:{"executeChange(address)":{inputs:[{internalType:"contract IChangeContract",name:"changeContract_",type:"address"}],name:"executeChange",outputs:[],stateMutability:"nonpayable",type:"function",details:"This function should be protected somehow to only execute changes that benefit the system. This decision process is independent of this architecture therefore is independent of this interface too",params:{changeContract_:"Address of the contract that will execute the changes"},notice:"Function to be called to make the changes described in changeContract"},"isAuthorizedChanger(address)":{inputs:[{internalType:"address",name:"changer_",type:"address"}],name:"isAuthorizedChanger",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{changer_:"Address of the contract that will execute the changes"},notice:"Returns whether this `changer_` is authorized to execute changes."}}},"contracts/interfaces/IMocRC20.sol:IMocRC20":{source:"contracts/interfaces/IMocRC20.sol",name:"IMocRC20",title:"IMocRC20",notice:"Base Moc ERC20 Token Interface: burn, mint. It can be both Pegs and Collateral Tokens.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. See {ERC20-_burn}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/interfaces/IPriceProvider.sol:IPriceProvider":{source:"contracts/interfaces/IPriceProvider.sol",name:"IPriceProvider",title:"IPriceFeed",details:"https://github.com/money-on-chain/Amphiraos-Oracle",notice:"Amphiraos-Oracle Interface for peeking the price of a given asset",methods:{"peek()":{inputs:[],name:"peek",outputs:[{internalType:"bytes32",name:"price",type:"bytes32"},{internalType:"bool",name:"valid",type:"bool"}],stateMutability:"view",type:"function",params:{price:"assetPrice",valid:"true if the price is valid"},notice:"returns the given `price` for the asset if `valid`"}}},"contracts/queue/MocQueue.sol:MocQueue":{source:"contracts/queue/MocQueue.sol",name:"MocQueue",title:"MocQueue: Allows queue Operation deferral execution processing",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"OperationError(uint256,bytes4,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"bytes4",name:"errorCode_",type:"bytes4"},{indexed:!1,internalType:"string",name:"msg_",type:"string"}],name:"OperationError",type:"event"},"OperationExecuted(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"executor",type:"address"},{indexed:!0,internalType:"uint256",name:"operId_",type:"uint256"}],name:"OperationExecuted",type:"event"},"OperationQueued(address,uint256,uint8)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"bucket_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"enum MocQueueExecFees.OperType",name:"operType_",type:"uint8"}],name:"OperationQueued",type:"event"},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"TCMinted(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCMinted",type:"event"},"TCRedeemed(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCRedeemed",type:"event"},"TCSwappedForTP(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCSwappedForTP",type:"event"},"TCandTPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCandTPMinted",type:"event"},"TCandTPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TCandTPRedeemed",type:"event"},"TPMinted(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPMinted",type:"event"},"TPRedeemed(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qAC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPRedeemed",type:"event"},"TPSwappedForTC(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tp_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTP_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTC_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPSwappedForTC",type:"event"},"TPSwappedForTP(address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"tpFrom_",type:"address"},{indexed:!1,internalType:"address",name:"tpTo_",type:"address"},{indexed:!0,internalType:"address",name:"sender_",type:"address"},{indexed:!0,internalType:"address",name:"recipient_",type:"address"},{indexed:!1,internalType:"uint256",name:"qTPfrom_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qTPto_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACfee_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeToken_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qACVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"uint256",name:"qFeeTokenVendorMarkup_",type:"uint256"},{indexed:!1,internalType:"address",name:"vendor_",type:"address"},{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"}],name:"TPSwappedForTP",type:"event"},"UnhandledError(uint256,bytes)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"operId_",type:"uint256"},{indexed:!1,internalType:"bytes",name:"reason_",type:"bytes"}],name:"UnhandledError",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"execFee(uint8)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"",type:"uint8"}],name:"execFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"execute(address)":{inputs:[{internalType:"address",name:"executionFeeRecipient",type:"address"}],name:"execute",outputs:[],stateMutability:"nonpayable",type:"function",details:"does not revert on Operation failure, throws Process and Error events according to the Oper type and result",notice:"Processes Operations in the queue"},"firstOperId()":{inputs:[],name:"firstOperId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getAndVerifyExecFee(uint8,uint256)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"operType_",type:"uint8"},{internalType:"uint256",name:"value_",type:"uint256"}],name:"getAndVerifyExecFee",outputs:[{internalType:"uint256",name:"currentExecFee",type:"uint256"}],stateMutability:"view",type:"function",details:"only used for coinbase flavor",params:{operType_:"operation type registered",value_:"value sent to pay execution fee"},returns:{currentExecFee:"execution fee required for the operation"},notice:"get execution fee for the operation requested  reverts if value sent is not enough to pay the execution fee"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint128,uint128,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{internalType:"address",name:"governor_",type:"address"},{internalType:"address",name:"pauser_",type:"address"},{internalType:"uint128",name:"minOperWaitingBlk_",type:"uint128"},{internalType:"uint128",name:"maxOperPerBatch_",type:"uint128"},{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"isEmpty()":{inputs:[],name:"isEmpty",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue is empty"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"maxOperPerBatch()":{inputs:[],name:"maxOperPerBatch",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function"},"minOperWaitingBlk()":{inputs:[],name:"minOperWaitingBlk",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function"},"mocOperations()":{inputs:[],name:"mocOperations",outputs:[{internalType:"contract MocOperations",name:"",type:"address"}],stateMutability:"view",type:"function"},"operIdCount()":{inputs:[],name:"operIdCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operationsMintTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTC",outputs:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsMintTCandTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTCandTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsMintTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsMintTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTC",outputs:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTCandTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTCandTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsRedeemTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsRedeemTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTCforTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTCforTP",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTPforTC(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTPforTC",outputs:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"operationsSwapTPforTP(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"operationsSwapTPforTP",outputs:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],stateMutability:"view",type:"function"},"opersInfo(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"opersInfo",outputs:[{internalType:"enum MocQueueExecFees.OperType",name:"operType",type:"uint8"},{internalType:"uint248",name:"queuedBlk",type:"uint248"}],stateMutability:"view",type:"function"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"queueMintTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTCParams",name:"params",type:"tuple"}],name:"queueMintTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueMintTCandTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.MintTCandTPParams",name:"params",type:"tuple"}],name:"queueMintTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueMintTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.MintTPParams",name:"params",type:"tuple"}],name:"queueMintTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueRedeemTC((uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCore.RedeemTCParams",name:"params",type:"tuple"}],name:"queueRedeemTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"registered enqueuer can queue an Operations"},"queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTCandTPParams",name:"params",type:"tuple"}],name:"queueRedeemTCandTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueRedeemTP((address,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qACmin",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.RedeemTPParams",name:"params",type:"tuple"}],name:"queueRedeemTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTC",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTCforTPParams",name:"params",type:"tuple"}],name:"queueSwapTCforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tp",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTCmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTCParams",name:"params",type:"tuple"}],name:"queueSwapTPforTC",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))":{inputs:[{components:[{internalType:"address",name:"tpFrom",type:"address"},{internalType:"address",name:"tpTo",type:"address"},{internalType:"uint256",name:"qTP",type:"uint256"},{internalType:"uint256",name:"qTPmin",type:"uint256"},{internalType:"uint256",name:"qACmax",type:"uint256"},{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"address",name:"vendor",type:"address"}],internalType:"struct MocCommons.SwapTPforTPParams",name:"params",type:"tuple"}],name:"queueSwapTPforTP",outputs:[{internalType:"uint256",name:"operId",type:"uint256"}],stateMutability:"payable",type:"function",returns:{operId:"Identifier to track the Operation lifecycle"},notice:"Registered enqueuer can queue an Operations"},"readyToExecute()":{inputs:[],name:"readyToExecute",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue has at least one Operation ready to be executed"},"registerBucket(address)":{inputs:[{internalType:"contract MocOperations",name:"bucket_",type:"address"}],name:"registerBucket",outputs:[],stateMutability:"nonpayable",type:"function",details:"in order to operate, the queue needs to be whitelisted as ENQUEUER_ROLE on the bucket as well",params:{bucket_:"address of the mocOperations implementation to interact with May emit a {RoleGranted} event for ENQUEUER role"},notice:"registers the mocOperations bucket that would operate over this queue"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setMaxOperPerBatch(uint128)":{inputs:[{internalType:"uint128",name:"maxOperPerBatch_",type:"uint128"}],name:"setMaxOperPerBatch",outputs:[],stateMutability:"nonpayable",type:"function",params:{maxOperPerBatch_:"maximum amount of operations allowed on a batch to avoid going over the block gas limit"},notice:"sets Moc Queue maximum amount of operations per execution batch"},"setMinOperWaitingBlk(uint128)":{inputs:[{internalType:"uint128",name:"minOperWaitingBlk_",type:"uint128"}],name:"setMinOperWaitingBlk",outputs:[],stateMutability:"nonpayable",type:"function",params:{minOperWaitingBlk_:"minimum amount of blocks an operation needs to remain in the queue before it can be executed"},notice:"sets Moc Queue minimum operation waiting blocks"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateExecutionFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"updateExecutionFees",outputs:[],stateMutability:"nonpayable",type:"function",details:"When the changer is executed there could be pending operations on the queue, thats means that  users have already paid for those operations, so, two situations could occur:  1. If execution fees are decreased, the executor will receive all the new fees and the       remaining funds will stay in this contract  2. If execution fees are increased, the executor will receive less fees, unless this contract has funds       remaining from another execution fee update (1.) or previously sent by another address",params:{mocQueueExecFeesParams_:"new execution fees"},notice:"Updates executions fees with absolute values for each operation type"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/queue/MocQueueExecFees.sol:MocQueueExecFees":{source:"contracts/queue/MocQueueExecFees.sol",name:"MocQueueExecFees",title:"MocQueue Execution Fee: Handles Queuing execution fees",receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"execFee(uint8)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"",type:"uint8"}],name:"execFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getAndVerifyExecFee(uint8,uint256)":{inputs:[{internalType:"enum MocQueueExecFees.OperType",name:"operType_",type:"uint8"},{internalType:"uint256",name:"value_",type:"uint256"}],name:"getAndVerifyExecFee",outputs:[{internalType:"uint256",name:"currentExecFee",type:"uint256"}],stateMutability:"view",type:"function",details:"only used for coinbase flavor",params:{operType_:"operation type registered",value_:"value sent to pay execution fee"},returns:{currentExecFee:"execution fee required for the operation"},notice:"get execution fee for the operation requested  reverts if value sent is not enough to pay the execution fee"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isEmpty()":{inputs:[],name:"isEmpty",outputs:[{internalType:"bool",name:"isEmpty",type:"bool"}],stateMutability:"view",type:"function",notice:"true if the queue is empty"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"updateExecutionFees((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tcMintExecFee",type:"uint256"},{internalType:"uint256",name:"tcRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"tpMintExecFee",type:"uint256"},{internalType:"uint256",name:"tpRedeemExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTPExecFee",type:"uint256"},{internalType:"uint256",name:"swapTPforTCExecFee",type:"uint256"},{internalType:"uint256",name:"swapTCforTPExecFee",type:"uint256"},{internalType:"uint256",name:"redeemTCandTPExecFee",type:"uint256"},{internalType:"uint256",name:"mintTCandTPExecFee",type:"uint256"}],internalType:"struct MocQueueExecFees.InitializeMocQueueExecFeesParams",name:"mocQueueExecFeesParams_",type:"tuple"}],name:"updateExecutionFees",outputs:[],stateMutability:"nonpayable",type:"function",details:"When the changer is executed there could be pending operations on the queue, thats means that  users have already paid for those operations, so, two situations could occur:  1. If execution fees are decreased, the executor will receive all the new fees and the       remaining funds will stay in this contract  2. If execution fees are increased, the executor will receive less fees, unless this contract has funds       remaining from another execution fee update (1.) or previously sent by another address",params:{mocQueueExecFeesParams_:"new execution fees"},notice:"Updates executions fees with absolute values for each operation type"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/tokens/MocRC20.sol:MocRC20":{source:"contracts/tokens/MocRC20.sol",name:"MocRC20",title:"MocRC20",details:"ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.",notice:"Base Moc ERC20 Token: burn, mint. It can be both Pegs and Collateral Tokens.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. * See {ERC20-_burn}. Requirements: - the caller must have the `BURNER_ROLE`."},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,address,address)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"admin_",type:"address"},{internalType:"contract IGovernor",name:"governor_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"See {__MocRC20_init}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferAllRoles(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"transferAllRoles",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants all `roles` to `account` while sender renounces to all ``role`` If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. - no one else must have any other role May emit a {RoleGranted x3, RoleRevoked x3} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/tokens/MocTC.sol:MocTC":{source:"contracts/tokens/MocTC.sol",name:"MocTC",title:"MocTC",details:"ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.",notice:"Base Moc  ERC20 Collateral Tokens: Allows burn, mint and pause.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event",details:"Emitted when the pause is triggered by `account`."},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event",details:"Emitted when the pause is lifted by `account`."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns a specific `amount` of tokens for `to`. * See {ERC20-_burn}. Requirements: - the caller must have the `BURNER_ROLE`."},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(string,string,address,address)":{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"address",name:"admin_",type:"address"},{internalType:"contract IGovernor",name:"governor_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `PAUSER_ROLE` to `admin` address. See {MocRC20-constructor}."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Creates `amount` new tokens for `to`. See {ERC20-_mint}. Requirements: - the caller must have the `MINTER_ROLE`."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Pauses the contract. See {ERC20PausableUpgradeable-_pause}. Requirements: - the caller must have the `PAUSER_ROLE`."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferAllRoles(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"transferAllRoles",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants all `roles` to `account` while sender renounces to all ``role``. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. - no one else must have any other role May emit a {RoleGranted x4, RoleRevoked x4} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/utils/MocAccessControlled.sol:MocAccessControlled":{source:"contracts/utils/MocAccessControlled.sol",name:"MocAccessControlled",title:"MocAccessControlled",details:"grant and revoke functions are overwritten so that they are also      compatible with governance authorization mechanism.",notice:"Extends Moc Upgradable capabilities, with access control capabilities",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event",details:"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event",details:"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event",details:"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/utils/MocHelper.sol:MocHelper":{source:"contracts/utils/MocHelper.sol",name:"MocHelper"},"contracts/vendors/MocVendors.sol:MocVendors":{source:"contracts/vendors/MocVendors.sol",name:"MocVendors",title:"MocVendors",notice:"MocVendors allows a third-party to add a markup to all operations  A vendor can set a markup themselves or ask vendors guardian to do it on their behalf.  Considerations:  - Theres is not a markup limit or restriction  - The currency that the vendor receives is always the same that is used to pay fees(AC or Fee Token)  - A malicious vendor front running an operation increasing the markup is protected in some way      by the maximum (AC or Fee Token) that the user expect to spend(or de minimum that expect to receive)",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event",details:"Emitted when the admin account has changed."},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event",details:"Emitted when the beacon is changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation is upgraded."},"VendorMarkupChanged(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"vendorAddress_",type:"address"},{indexed:!1,internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"VendorMarkupChanged",type:"event"}},methods:{"changeGovernor(address)":{inputs:[{internalType:"contract IGovernor",name:"newGovernor_",type:"address"}],name:"changeGovernor",outputs:[],stateMutability:"nonpayable",type:"function",params:{newGovernor_:"New governor address"},notice:"Change the contract's governor. Should be called through the old governance system"},"governor()":{inputs:[],name:"governor",outputs:[{internalType:"contract IGovernor",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"The address of the contract which governs this one"},"initialize(address,address,address)":{inputs:[{internalType:"address",name:"vendorsGuardianAddress_",type:"address"},{internalType:"address",name:"governorAddress_",type:"address"},{internalType:"address",name:"pauserAddress_",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{governorAddress_:"The address that will define when a change contract is authorized",pauserAddress_:"The address that is authorized to pause this contract",vendorsGuardianAddress_:"The address authorized to change a vendor's markup"},notice:"contract initializer"},"makeStoppable()":{inputs:[],name:"makeStoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches ON the stoppability of the contract. It can be paused or unpaused  Doesn't change the pause state, if the contract was already paused it cannot be operated"},"makeUnstoppable()":{inputs:[],name:"makeUnstoppable",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",notice:"Switches OFF the stoppability of the contract. It cannot be paused or unpaused Doesn't change the pause state, if the contract was already paused it cannot be operated"},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to pause, triggers stopped state"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns true if paused"},"pauser()":{inputs:[],name:"pauser",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"proxiableUUID()":{inputs:[],name:"proxiableUUID",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."},"setMarkup(uint256)":{inputs:[{internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"setMarkup",outputs:[],stateMutability:"nonpayable",type:"function",params:{newMarkup_:"new markup applied to vendor [PREC]"},notice:"vendor sets its own markup"},"setPauser(address)":{inputs:[{internalType:"address",name:"newPauser_",type:"address"}],name:"setPauser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should be called through governance",params:{newPauser_:"Address of the new pauser"},notice:"Changes the address which is enable to pause this contract"},"setVendorMarkup(address,uint256)":{inputs:[{internalType:"address",name:"vendorAddress_",type:"address"},{internalType:"uint256",name:"newMarkup_",type:"uint256"}],name:"setVendorMarkup",outputs:[],stateMutability:"nonpayable",type:"function",params:{newMarkup_:"new markup applied to vendor [PREC]",vendorAddress_:"vendor address to change markup"},notice:"guardian sets a vendor markup"},"setVendorsGuardianAddress(address)":{inputs:[{internalType:"address",name:"vendorsGuardianAddress_",type:"address"}],name:"setVendorsGuardianAddress",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets the address which will be authorized to set a vendor markup.",params:{vendorsGuardianAddress_:"Address which will be authorized to set a vendor markup."}},"stoppable()":{inputs:[],name:"stoppable",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",details:"Should only be called by the pauser and when it is stoppable",notice:"Called by the owner to unpause, returns to normal state"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow-reachable":"delegatecall",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"vendorMarkup(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"vendorMarkup",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"vendorsGuardianAddress()":{inputs:[],name:"vendorsGuardianAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}}};new Kn({el:"#app",router:new Mu({routes:[{path:"/",component:Qu,props:()=>({json:Hu})},{path:"*",component:zu,props:e=>({json:Hu[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(Fu)})})()})();